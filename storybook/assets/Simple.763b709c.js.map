{"version":3,"file":"Simple.763b709c.js","sources":["../../../core/dist/renderer/dragUtils.js","../../../core/dist/renderer/AttrMapSvg.js","../../../core/dist/renderer/AttrHelper.js","../../../core/dist/renderer/Circle.js","../../../core/dist/renderer/Ellipse.js","../../../core/dist/renderer/Equation.js","../../../core/dist/renderer/not_found.js","../../../core/dist/renderer/Image.js","../../../core/dist/renderer/Line.js","../../../core/dist/renderer/Path.js","../../../core/dist/renderer/Polygon.js","../../../core/dist/renderer/Polyline.js","../../../core/dist/renderer/Rectangle.js","../../../core/dist/renderer/Text.js","../../../core/dist/renderer/shapeMap.js","../../../core/dist/renderer/Renderer.js","../../../core/dist/index.js","../../src/fetchPathResolver.ts","../../src/Simple.tsx"],"sourcesContent":["import { genOptProblem } from \"@penrose/optimizer\";\n/**\n * Retrieve data from drag events and update varying state accordingly\n */\nexport const dragUpdate = (state, id, dx, dy) => {\n    const xs = [...state.varyingValues];\n    const { constraintSets, optStages } = state;\n    const { inputMask, objMask, constrMask } = constraintSets[optStages[0]];\n    const gradMask = [...inputMask];\n    for (const shape of state.shapes) {\n        if (shape.properties.name.contents === id) {\n            for (const id of dragShape(shape, [dx, dy], xs)) {\n                gradMask[id] = false;\n            }\n        }\n    }\n    const updated = Object.assign(Object.assign({}, state), { params: genOptProblem(gradMask, objMask, constrMask), varyingValues: xs });\n    return updated;\n};\n// TODO: factor out position props in shapedef\n// return: a list of updated ids\nconst dragShape = (shape, offset, xs) => {\n    const { shapeType, properties } = shape;\n    switch (shapeType) {\n        case \"Path\":\n            console.log(\"Path drag unimplemented\", shape); // Just to prevent crashing on accidental drag\n            return [];\n        case \"Polygon\":\n            console.log(\"Polygon drag unimplemented\", shape); // Just to prevent crashing on accidental drag\n            return [];\n        case \"Polyline\":\n            console.log(\"Polyline drag unimplemented\", shape); // Just to prevent crashing on accidental drag\n            return [];\n        case \"Line\":\n            return moveProperties(properties, [\"start\", \"end\"], offset, xs);\n        default:\n            return moveProperties(properties, [\"center\"], offset, xs);\n    }\n};\n/**\n * For each of the specified properties listed in `propPairs`, subtract a number from the original value.\n */\nconst moveProperties = (properties, propsToMove, [dx, dy], xs) => {\n    const ids = [];\n    for (const propertyID of propsToMove) {\n        const value = properties[propertyID];\n        if (value.tag === \"VectorV\") {\n            const [x, y] = value.contents;\n            if (typeof x !== \"number\" && x.tag === \"Input\") {\n                xs[x.key] += dx;\n                ids.push(x.key);\n            }\n            if (typeof y !== \"number\" && y.tag === \"Input\") {\n                xs[y.key] += dy;\n                ids.push(y.key);\n            }\n        }\n    }\n    return ids;\n};\n//# sourceMappingURL=dragUtils.js.map","/**\n * Mapping from internal \"non-kebab\" Penrose names to SVG \"kebab\" names\n */\nexport const attrMapSvg = {\n    accentHeight: \"accent-height\",\n    alignmentBaseline: \"alignment-baseline\",\n    arabicForm: \"arabic-form\",\n    baselineShift: \"baseline-shift\",\n    capHeight: \"cap-height\",\n    clipPath: \"clip-path\",\n    clipRule: \"clip-rule\",\n    colorInterpolation: \"color-interpolation\",\n    colorInterpolationFilters: \"color-interpolation-filters\",\n    colorProfile: \"color-profile\",\n    colorRendering: \"color-rendering\",\n    dominantBaseline: \"dominant-baseline\",\n    enableBackground: \"enable-background\",\n    fillOpacity: \"fill-opacity\",\n    fillRule: \"fill-rule\",\n    floodColor: \"flood-color\",\n    floodOpacity: \"flood-opacity\",\n    fontFamily: \"font-family\",\n    fontSize: \"font-size\",\n    fontSizeAdjust: \"font-size-adjust\",\n    fontStretch: \"font-stretch\",\n    fontStyle: \"font-style\",\n    fontVariant: \"font-variant\",\n    fontWeight: \"font-weight\",\n    glyphName: \"glyph-name\",\n    glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n    glyphOrientationVertical: \"glyph-orientation-vertical\",\n    horizAdvX: \"horiz-adv-x\",\n    horizOriginX: \"horiz-origin-x\",\n    imageRendering: \"image-rendering\",\n    letterSpacing: \"letter-spacing\",\n    lightingColor: \"lighting-color\",\n    markerEnd: \"marker-end\",\n    markerMid: \"marker-mid\",\n    markerStart: \"marker-start\",\n    overlinePosition: \"overline-position\",\n    overlineThickness: \"overline-thickness\",\n    panose1: \"panose-1\",\n    paintOrder: \"paint-order\",\n    pointerEvents: \"pointer-events\",\n    renderingIntent: \"rendering-intent\",\n    shapeRendering: \"shape-rendering\",\n    stopColor: \"stop-color\",\n    stopOpacity: \"stop-opacity\",\n    strikethroughPosition: \"strikethrough-position\",\n    strikethroughThickness: \"strikethrough-thickness\",\n    strokeDasharray: \"stroke-dasharray\",\n    strokeDashoffset: \"stroke-dashoffset\",\n    strokeLinecap: \"stroke-linecap\",\n    strokeLinejoin: \"stroke-linejoin\",\n    strokeMiterlimit: \"stroke-miterlimit\",\n    strokeOpacity: \"stroke-opacity\",\n    strokeWidth: \"stroke-width\",\n    textAnchor: \"text-anchor\",\n    textDecoration: \"text-decoration\",\n    textRendering: \"text-rendering\",\n    transformOrigin: \"transform-origin\",\n    underlinePosition: \"underline-position\",\n    underlineThickness: \"underline-thickness\",\n    unicodeBidi: \"unicode-bidi\",\n    unicodeRange: \"unicode-range\",\n    unitsPerEm: \"units-per-em\",\n    vAlphabetic: \"v-alphabetic\",\n    vHanging: \"v-hanging\",\n    vIdeographic: \"v-ideographic\",\n    vMathematical: \"v-mathematical\",\n    vectorEffect: \"vector-effect\",\n    vertAdvY: \"vert-adv-y\",\n    vertOriginX: \"vert-origin-x\",\n    vertOriginY: \"vert-origin-y\",\n    wordSpacing: \"word-spacing\",\n    writingMode: \"writing-mode\",\n};\n//# sourceMappingURL=AttrMapSvg.js.map","/**\n * Provides an assortment of utility functions shared across shapes that computes\n * output SVG properties using the optimized shape properties as input.\n */\nimport { toFontRule } from \"../utils/CollectLabels\";\nimport { toScreen, toSvgOpacityProperty, toSvgPaintProperty } from \"../utils/Util\";\nimport { attrMapSvg } from \"./AttrMapSvg\";\n/**\n * Auto-map to SVG any input properties for which we lack specific logic.\n *\n * Apply a map, AttrMapSvg, to perform any target-specific property name translation,\n * i.e., map from Penrose camel case formal to SVG mixed-case/kebab format.  Property names\n * not found in the map are mapped straight across.\n *\n * Note: Right now we are neither validating the SVG property names nor its contents.  The\n * thinking is to add an optional validator to the end of the pipeline at some point rather\n * than implement validation for all passthrough SVG properties inside Penrose.\n *\n * Note: This is an \"escape hatch\" for \"passthrough\" SVG properties we don't currently support.\n *\n * Note: SVG property names are case sensitive.\n */\nexport const attrAutoFillSvg = ({ properties }, elem, attrAlreadyMapped) => {\n    // Internal properties to never auto-map to SVG\n    const attrToNeverAutoMap = [\n        \"strokeStyle\",\n        \"name\",\n        \"ensureOnCanvas\",\n    ];\n    // Merge the mapped and never-map properties.  Convert to Set\n    const attrToNotAutoMap = new Set(attrAlreadyMapped.concat(attrToNeverAutoMap));\n    // Map unknown/unseen attributes with values to SVG output.\n    // This is the \"escape hatch\" for properties we don't support.\n    //\n    // NOTE: `style` is handled as a special case, because some of\n    // the built-in properties will write to it __and__ the user\n    // should be able to append to it. Therefore, we check if there's\n    // an existing value in `style` and append to it if true.\n    for (const propName in properties) {\n        const propValue = properties[propName].contents.toString();\n        // Only map properties with values and that we have not previously mapped\n        if (propValue !== \"\" && !attrToNotAutoMap.has(propName)) {\n            // If a mapping rule exists, apply it; otherwise, map straight across\n            if (propName in attrMapSvg) {\n                const mappedPropName = attrMapSvg[propName];\n                if (!elem.hasAttribute(mappedPropName)) {\n                    elem.setAttribute(mappedPropName, propValue);\n                }\n            }\n            else if (propName === \"style\" && propValue !== \"\") {\n                const style = elem.getAttribute(propName);\n                if (style === null) {\n                    elem.setAttribute(propName, propValue);\n                }\n                else {\n                    elem.setAttribute(propName, `${style}${propValue}`);\n                }\n            }\n            else {\n                if (!elem.hasAttribute(propName)) {\n                    elem.setAttribute(propName, propValue);\n                }\n            }\n        }\n    }\n};\n/**\n * Maps fillColor --> fill, fill-opacity\n */\nexport const attrFill = ({ properties }, elem) => {\n    const color = properties.fillColor;\n    const alpha = toSvgOpacityProperty(color.contents);\n    elem.setAttribute(\"fill\", toSvgPaintProperty(color.contents));\n    // Fill opacity only relevant if fill is present\n    if (color.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"fill-opacity\", alpha.toString());\n    }\n    return [\"fillColor\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center --> cx, cy\n */\nexport const attrCenter = ({ properties }, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen(center.contents, canvasSize);\n    elem.setAttribute(\"cx\", x.toString());\n    elem.setAttribute(\"cy\", y.toString());\n    return [\"center\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps scale --> transform\n */\nexport const attrScale = ({ properties }, elem) => {\n    let scale = properties.scale.contents;\n    scale = scale || 1;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null ? `scale(${scale})` : transform + `scale{${scale}}`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"scale\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> transform\n */\nexport const attrTransformCoords = ({ properties }, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen(center.contents, canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `translate(${x - w.contents / 2}, ${y - h.contents / 2})`\n            : transform + `translate(${x - w.contents / 2}, ${y - h.contents / 2})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> x, y\n */\nexport const attrXY = ({ properties }, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen(center.contents, canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"x\", (x - w.contents / 2).toString());\n    elem.setAttribute(\"y\", (y - h.contents / 2).toString());\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height, rotation --> transform\n *\n * Rotates a GPI by n degrees about a center\n * Note: elem must be `transform`able\n * NOTE: must be called before transform translate coords (matrix rules)\n * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform\n */\nexport const attrRotation = ({ properties }, canvasSize, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    const center = properties.center;\n    const rotation = properties.rotation.contents;\n    const [x, y] = toScreen(center.contents, canvasSize);\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `rotate(${rotation}, ${x - w.contents / 2}, ${y - h.contents / 2})`\n            : transform +\n                `rotate(${rotation}, ${x - w.contents / 2}, ${y - h.contents / 2})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"rotation\", \"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps width, height --> width, height\n */\nexport const attrWH = ({ properties }, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"width\", w.contents.toString());\n    elem.setAttribute(\"height\", h.contents.toString());\n    return [\"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps cornerRadius --> rx\n */\nexport const attrCornerRadius = ({ properties }, elem) => {\n    const rx = properties.cornerRadius;\n    elem.setAttribute(\"rx\", rx.contents.toString());\n    return [\"cornerRadius\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps data --> d\n */\nexport const attrPathData = ({ properties }, elem) => {\n    const d = properties.data;\n    elem.setAttribute(\"d\", d.contents.toString());\n    return [\"data\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps string --> new TextNode\n */\nexport const attrString = ({ properties }, elem) => {\n    const str = properties.string;\n    const text = document.createTextNode(str.contents.toString());\n    elem.appendChild(text);\n    return [\"string\"]; // Return array of input properties programatically mapped\n};\nexport const DASH_ARRAY = \"7,5\";\n/**\n * Maps strokeColor --> stroke, stroke-opacity\n *      strokeWidth --> stroke-width\n *      strokeDasharray, strokeStyle --> stroke-dasharray\n *      strokeLinecap --> stroke-linecap\n */\nexport const attrStroke = ({ properties }, elem) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const strokeColor = properties.strokeColor;\n    const strokeAlpha = toSvgOpacityProperty(strokeColor.contents);\n    const thickness = properties.strokeWidth.contents;\n    elem.setAttribute(\"stroke\", toSvgPaintProperty(strokeColor.contents));\n    attrMapped.push(\"strokeColor\", \"strokeWidth\");\n    // Stroke opacity, width, and dashiness only relevant if stroke is present\n    if (strokeColor.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"stroke-opacity\", strokeAlpha.toString());\n        elem.setAttribute(\"stroke-width\", thickness.toString());\n        if (\"strokeDasharray\" in properties &&\n            properties.strokeDasharray.contents !== \"\") {\n            elem.setAttribute(\"stroke-dasharray\", properties.strokeDasharray.contents);\n        }\n        else if (\"strokeStyle\" in properties &&\n            properties.strokeStyle.contents === \"dashed\") {\n            elem.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n            attrMapped.push(\"strokeDasharray\", \"strokeStyle\");\n        }\n        if (\"strokeLinecap\" in properties &&\n            properties.strokeLinecap.contents !== \"\") {\n            elem.setAttribute(\"stroke-linecap\", properties.strokeLinecap.contents);\n        }\n        else {\n            elem.setAttribute(\"stroke-linecap\", \"butt\");\n        }\n        attrMapped.push(\"strokeLinecap\");\n    }\n    return attrMapped; // Return array of input properties programatically mapped\n};\n/**\n * Maps name --> new Title\n */\nexport const attrTitle = ({ properties }, elem) => {\n    const name = properties.name;\n    const title = document.createElementNS(\"http://www.w3.org/2000/svg\", \"title\");\n    title.textContent = name.contents;\n    elem.appendChild(title);\n    return [\"name\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps fontFamily, fontSize, fontStretch, fontStyle, fontVariant, fontWeight, lineHeight -> font\n */\nexport const attrFont = (shape, elem) => {\n    const fontString = toFontRule(shape);\n    const existingStyle = elem.getAttribute(\"style\");\n    // TODO: check if `lineHeight` is valid\n    elem.setAttribute(\"style\", existingStyle\n        ? `${existingStyle}; font: ${fontString};`\n        : `font: ${fontString};`);\n    return [\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStretch\",\n        \"fontStyle\",\n        \"fontVariant\",\n        \"fontWeight\",\n        \"lineHeigh\",\n    ]; // Return array of input properties programatically mapped\n};\n/**\n * Maps points -> points\n */\nexport const attrPolyPoints = (shape, canvasSize, elem) => {\n    const points = shape.properties.points;\n    const pointsTransformed = points.contents.map((p) => toScreen(p, canvasSize));\n    elem.setAttribute(\"points\", pointsTransformed.toString());\n    return [\"points\"];\n};\n//# sourceMappingURL=AttrHelper.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst Circle = ({ shape, canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Fill the output SVG attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Circle;\n//# sourceMappingURL=Circle.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst Ellipse = ({ shape, canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"ellipse\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Ellipse;\n//# sourceMappingURL=Ellipse.js.map","import { getAdValueAsString } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrFill, attrFont, attrRotation, attrStroke, attrTitle, attrTransformCoords, attrWH, } from \"./AttrHelper\";\nconst Equation = ({ shape, canvasSize, labels }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Indicator: pre-rendered label was found\n    let labelFound = false;\n    const retrievedLabel = labels.get(getAdValueAsString(shape.properties.name));\n    if (retrievedLabel && retrievedLabel.tag === \"EquationData\") {\n        // Clone the retrieved node first to avoid mutating existing labels\n        const renderedLabel = retrievedLabel.rendered.cloneNode(true);\n        const g = renderedLabel.getElementsByTagName(\"g\")[0];\n        attrToNotAutoMap.push(...attrFill(shape, g));\n        // Map Width/Height\n        attrToNotAutoMap.push(...attrWH(shape, renderedLabel));\n        g.setAttribute(\"stroke\", \"none\");\n        g.setAttribute(\"stroke-width\", \"0\");\n        const fontSize = shape.properties.fontSize;\n        renderedLabel.setAttribute(\"style\", `font-size: ${fontSize.contents}`);\n        // Append the element & indicate the rendered label was found\n        elem.appendChild(renderedLabel);\n        labelFound = true;\n    }\n    if (!labelFound) {\n        // Fallback case: generate plain-text (non-rendered) label from string\n        const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        txt.textContent = getAdValueAsString(shape.properties.string);\n        attrToNotAutoMap.push(\"string\");\n        elem.appendChild(txt);\n        // Map the attributes we have\n        attrToNotAutoMap.push(...attrFill(shape, elem));\n        attrToNotAutoMap.push(...attrWH(shape, elem));\n        attrToNotAutoMap.push(...attrStroke(shape, elem));\n        attrToNotAutoMap.push(...attrFont(shape, elem));\n    }\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Equation;\n//# sourceMappingURL=Equation.js.map","export const image = `<?xml version='1.0' encoding='UTF-8' standalone='no'?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n<!-- https://commons.wikimedia.org/wiki/File:Tox_hallucin.svg -->\n<svg\n   xmlns:dc='http://purl.org/dc/elements/1.1/'\n   xmlns:cc='http://creativecommons.org/ns#'\n   xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'\n   xmlns:svg='http://www.w3.org/2000/svg'\n   xmlns='http://www.w3.org/2000/svg'\n   xmlns:xlink='http://www.w3.org/1999/xlink'\n   xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'\n   xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'\n   width='100%'\n   height='100%'\n   id='svg2'\n   sodipodi:version='0.32'\n preserveAspectRatio='none'  inkscape:version='0.46'\n viewBox='0 0 300 300'  version='1.0'\n   sodipodi:docname='tox hallucin.svg'\n   inkscape:output_extension='org.inkscape.output.svg.inkscape'>\n  <defs\n     id='defs4'>\n    <linearGradient\n       inkscape:collect='always'\n       id='linearGradient3191'>\n      <stop\n         style='stop-color:#ff8d00;stop-opacity:1;'\n         offset='0'\n         id='stop3193' />\n      <stop\n         style='stop-color:#ff8d00;stop-opacity:0;'\n         offset='1'\n         id='stop3195' />\n    </linearGradient>\n    <linearGradient\n       id='linearGradient3175'>\n      <stop\n         style='stop-color:#00ccff;stop-opacity:1;'\n         offset='0'\n         id='stop3177' />\n      <stop\n         style='stop-color:#ff1300;stop-opacity:0;'\n         offset='1'\n         id='stop3179' />\n    </linearGradient>\n    <linearGradient\n       id='linearGradient3155'>\n      <stop\n         style='stop-color:#ffffff;stop-opacity:1;'\n         offset='0'\n         id='stop3157' />\n      <stop\n         style='stop-color:#efff00;stop-opacity:1;'\n         offset='1'\n         id='stop3159' />\n    </linearGradient>\n    <inkscape:perspective\n       sodipodi:type='inkscape:persp3d'\n       inkscape:vp_x='0 : 526.18109 : 1'\n       inkscape:vp_y='0 : 1000 : 0'\n       inkscape:vp_z='744.09448 : 526.18109 : 1'\n       inkscape:persp3d-origin='372.04724 : 350.78739 : 1'\n       id='perspective10' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3155'\n       id='radialGradient3161'\n       cx='88.527176'\n       cy='113.77536'\n       fx='88.527176'\n       fy='113.77536'\n       r='138.2794'\n       gradientUnits='userSpaceOnUse'\n       gradientTransform='matrix(0.999944,-1.9657533,1.153884,0.5869605,-136.45929,210.24015)' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3155'\n       id='radialGradient3227'\n       gradientUnits='userSpaceOnUse'\n       gradientTransform='matrix(0.999944,-1.9657533,1.153884,0.5869605,-136.45929,210.24015)'\n       cx='88.527176'\n       cy='113.77536'\n       fx='88.527176'\n       fy='113.77536'\n       r='138.2794' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3191'\n       id='radialGradient3197'\n       cx='70.968475'\n       cy='160.37096'\n       fx='70.968475'\n       fy='160.37096'\n       r='21.348242'\n       gradientTransform='matrix(1,0,0,0.9729729,0,4.3343583)'\n       gradientUnits='userSpaceOnUse' />\n  </defs>\n  <sodipodi:namedview\n     id='base'\n     pagecolor='#ffffff'\n     bordercolor='#666666'\n     borderopacity='1.0'\n     gridtolerance='10000'\n     guidetolerance='10'\n     objecttolerance='10'\n     inkscape:pageopacity='0.0'\n     inkscape:pageshadow='2'\n     inkscape:zoom='1.624463'\n     inkscape:cx='101.39954'\n     inkscape:cy='85.047263'\n     inkscape:document-units='px'\n     inkscape:current-layer='layer1'\n     showgrid='false'\n     inkscape:window-width='1073'\n     inkscape:window-height='720'\n     inkscape:window-x='9'\n     inkscape:window-y='37' />\n  <metadata\n     id='metadata7'>\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=''>\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource='http://purl.org/dc/dcmitype/StillImage' />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label='Layer 1'\n     inkscape:groupmode='layer'\n     id='layer1'>\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#efff00;fill-opacity:1.0;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path2383'\n       sodipodi:cx='149.64484'\n       sodipodi:cy='150.35516'\n       sodipodi:rx='138.2794'\n       sodipodi:ry='138.2794'\n       d='M 287.92424,150.35516 A 138.2794,138.2794 0 1 1 11.365433,150.35516 A 138.2794,138.2794 0 1 1 287.92424,150.35516 z' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3161'\n       sodipodi:cx='103.94469'\n       sodipodi:cy='104.13142'\n       sodipodi:rx='24.748737'\n       sodipodi:ry='37.476658'\n       d='M 128.69342,104.13142 A 24.748737,37.476658 0 1 1 79.19595,104.13142 A 24.748737,37.476658 0 1 1 128.69342,104.13142 z'\n       transform='matrix(-0.9582289,-0.2860021,-0.2860021,0.9582289,325.97792,44.974994)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3167'\n       sodipodi:cx='106.5'\n       sodipodi:cy='114'\n       sodipodi:rx='9.5'\n       sodipodi:ry='10'\n       d='M 116,114 A 9.5,10 0 1 1 97,114 A 9.5,10 0 1 1 116,114 z'\n       transform='matrix(1.6054105,0,0,1.4584426,27.357721,-51.363012)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3168'\n       sodipodi:cx='103.94469'\n       sodipodi:cy='104.13142'\n       sodipodi:rx='24.748737'\n       sodipodi:ry='37.476658'\n       d='M 128.69342,104.13142 A 24.748737,37.476658 0 1 1 79.19595,104.13142 A 24.748737,37.476658 0 1 1 128.69342,104.13142 z'\n       transform='matrix(-0.9532299,0.302246,0.302246,0.9532299,175.23598,-14.157525)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3170'\n       sodipodi:cx='106.5'\n       sodipodi:cy='114'\n       sodipodi:rx='9.5'\n       sodipodi:ry='10'\n       d='M 116,114 A 9.5,10 0 1 1 97,114 A 9.5,10 0 1 1 116,114 z'\n       transform='matrix(1.5359163,0,0,1.6024784,-55.141915,-65.123921)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924528999999999;stroke:#000000;stroke-width:4.92309473;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3195'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,0.2640954,-11.044101)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:4.92309475;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3197'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,152.64503,26.616757)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924528999999999;stroke:#000000;stroke-width:4.92309473;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3199'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,208.91913,1.5592222)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3201'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,107.50785,6.167405)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3203'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,18.350997,91.123147)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3205'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,241.47652,68.717237)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3207'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,190.12964,149.00508)' />\n    <path\n       id='path3209'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 61.524095,141.5056 L 61.524095,150.8265 M 61.557643,163.12376 L 61.557643,172.44466 M 75.425271,156.87515 L 66.971345,156.87515 M 56.778194,157.01501 L 48.324268,157.01501 M 71.584095,145.37378 L 65.167078,152.13403 M 56.725303,161.07608 L 50.308286,167.83633 M 71.085092,166.09132 L 64.953634,160.27118 M 57.464465,153.35509 L 51.333007,147.53495' />\n    <path\n       id='path3221'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 86.725071,37.423625 L 86.725071,46.744525 M 86.758619,59.041785 L 86.758619,68.362685 M 100.62625,52.793175 L 92.172321,52.793175 M 81.97917,52.933035 L 73.525244,52.933035 M 96.785071,41.291805 L 90.368054,48.052055 M 81.926279,56.994105 L 75.509262,63.754355 M 96.286068,62.009345 L 90.15461,56.189205 M 82.665441,49.273115 L 76.533983,43.452975' />\n    <path\n       id='path3223'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 253.0319,128.4217 L 253.0319,137.7426 M 253.06544,150.03986 L 253.06544,159.36076 M 266.93307,143.79125 L 258.47915,143.79125 M 248.286,143.93111 L 239.83207,143.93111 M 263.0919,132.28988 L 256.67488,139.05013 M 248.2331,147.99218 L 241.81609,154.75243 M 262.59289,153.00742 L 256.46144,147.18728 M 248.97227,140.27119 L 242.84081,134.45105' />\n    <path\n       id='path3225'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 279.70375,5.2605113 L 279.70375,14.581411 M 279.73729,26.878671 L 279.73729,36.199571 M 293.60492,20.630061 L 285.151,20.630061 M 274.95784,20.769921 L 266.50392,20.769921 M 289.76375,9.1286912 L 283.34673,15.888941 M 274.90495,24.830991 L 268.48794,31.591241 M 289.26474,29.846231 L 283.13328,24.026091 M 275.64412,17.110001 L 269.51266,11.289861'\n       inkscape:transform-center-x='-6.2757294'\n       inkscape:transform-center-y='-7.0601956' />\n    <path\n       style='fill:#ffffff;fill-opacity:0.47924529;fill-rule:evenodd;stroke:#000000;stroke-width:1.2715199px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1'\n       d='M 99.300775,203.95684 L 55.102321,211.07101 C 63.275993,251.4092 43.33167,297.03463 67.500148,296.25246 C 91.668625,295.4703 75.132299,239.93649 75.132299,227.42183 C 75.132299,214.90716 96.756726,203.17467 99.300775,203.95684 z'\n       id='path3227'\n       sodipodi:nodetypes='ccssc' />\n    <path\n       style='fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:10;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 46.678979,210.37636 C 46.678979,210.37636 61.688317,182.90612 101.76017,180.50181 C 148.43916,177.70107 158.61785,218.03349 198.85245,218.77857 C 250.19932,219.71215 256.73439,187.03686 256.73439,187.03686 L 257.66797,186.10329 C 255.4936,218.71891 214.56016,233.58514 186.79701,232.12826 C 154.98692,230.45901 145.34234,210.03157 116.69745,202.90772 C 90.073723,196.28652 46.678979,210.37636 46.678979,210.37636 z'\n       id='path3193'\n       sodipodi:nodetypes='cssccssc' />\n  </g>\n</svg>`;\n//# sourceMappingURL=not_found.js.map","import { attrAutoFillSvg, attrRotation, attrTransformCoords, attrWH, } from \"./AttrHelper\";\nimport * as notFound from \"./not_found\";\nconst Image = async ({ shape, canvasSize, pathResolver, }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    const path = shape.properties.href.contents;\n    let rawSVG = await pathResolver(path);\n    if (rawSVG === undefined) {\n        console.error(`Could not resolve image path ${path}`);\n        rawSVG = notFound.image;\n    }\n    attrToNotAutoMap.push(\"href\");\n    elem.innerHTML = rawSVG;\n    // We assume the first svg element in the file is the one to display\n    const svg = elem.querySelector(\"svg\");\n    const defs = svg.getElementsByTagName(\"defs\");\n    /**\n     * HACK:\n     * We generate Unique IDs because of potential collisions when multiple images\n     * are integrated in one diagram.\n     */\n    if (defs.length > 0) {\n        defs[0].querySelectorAll(\"*\").forEach((node) => {\n            if (node.id !== \"\") {\n                // BUG: not matching on fill=\"url(#...)\", only hrefs\n                const users = svg.querySelectorAll(`[*|href=\"#${node.id}\"]:not([href])`);\n                users.forEach((user) => {\n                    const unique = `${shape.properties.name.contents}-ns-${node.id}`;\n                    user.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", \"#\" + unique);\n                    node.setAttribute(\"id\", unique);\n                });\n            }\n        });\n    }\n    attrToNotAutoMap.push(...attrWH(shape, svg));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Image;\n//# sourceMappingURL=Image.js.map","import { getArrowhead, round2, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrTitle, DASH_ARRAY } from \"./AttrHelper\";\nexport const arrowHead = (id, color, opacity, arrow, size, flip) => {\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute(\"id\", id);\n    marker.setAttribute(\"markerUnits\", \"strokeWidth\");\n    marker.setAttribute(\"markerWidth\", round2(arrow.width * size).toString());\n    marker.setAttribute(\"markerHeight\", round2(arrow.height * size).toString());\n    marker.setAttribute(\"viewBox\", arrow.viewbox);\n    marker.setAttribute(\"refX\", arrow.refX.toString());\n    marker.setAttribute(\"refY\", arrow.refY.toString());\n    if (flip) {\n        marker.setAttribute(\"orient\", \"auto\");\n    }\n    else {\n        marker.setAttribute(\"orient\", \"auto-start-reverse\");\n    }\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"d\", arrow.path);\n    if (arrow.fillKind === \"stroke\") {\n        path.setAttribute(\"fill\", \"none\");\n        marker.setAttribute(\"stroke\", color);\n        marker.setAttribute(\"stroke-opacity\", opacity.toString());\n    } /* if (arrow.fillKind === \"fill\") */\n    else {\n        path.setAttribute(\"fill\", color);\n        path.setAttribute(\"fill-opacity\", opacity.toString());\n    }\n    if (arrow.style) {\n        Object.entries(arrow.style).forEach(([key, value]) => {\n            path.setAttribute(key, value);\n        });\n    }\n    marker.appendChild(path);\n    return marker;\n};\nconst makeRoomForArrows = (shape, startArrowhead, endArrowhead) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const [lineSX, lineSY] = shape.properties.start\n        .contents;\n    const [lineEX, lineEY] = shape.properties.end\n        .contents;\n    const startArrowheadSize = shape.properties\n        .startArrowheadSize.contents;\n    const endArrowheadSize = shape.properties.endArrowheadSize\n        .contents;\n    const thickness = shape.properties.strokeWidth.contents;\n    attrMapped.push(\"start\", \"end\", \"startArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\", \"strokeWidth\");\n    // height * size = Penrose computed arrow size\n    // multiplied by thickness since the arrow size uses markerUnits, which is strokeWidth by default:\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerUnits\n    const length = Math.sqrt((lineSX - lineEX) ** 2 + (lineSY - lineEY) ** 2);\n    // Subtract off the arrowHeight from each side.\n    // See https://math.stackexchange.com/a/2045181 for a derivation.\n    let arrowSX, arrowSY;\n    if (startArrowhead) {\n        const startFlip = shape.properties.flipStartArrowhead.contents;\n        const startArrowWidth = (startFlip\n            ? startArrowhead.refX\n            : startArrowhead.width - startArrowhead.refX) *\n            startArrowheadSize *\n            thickness;\n        const dx = (startArrowWidth / length) * (lineSX - lineEX);\n        [arrowSX, arrowSY] = [\n            lineSX - (startFlip ? -startArrowhead.refX : dx),\n            lineSY - (startArrowWidth / length) * (lineSY - lineEY),\n        ];\n    }\n    else {\n        [arrowSX, arrowSY] = [lineSX, lineSY];\n    }\n    let arrowEX, arrowEY;\n    if (endArrowhead) {\n        const endArrowWidth = (endArrowhead.width - endArrowhead.refX) * endArrowheadSize * thickness;\n        [arrowEX, arrowEY] = [\n            lineEX - (endArrowWidth / length) * (lineEX - lineSX),\n            lineEY - (endArrowWidth / length) * (lineEY - lineSY),\n        ];\n    }\n    else {\n        [arrowEX, arrowEY] = [lineEX, lineEY];\n    }\n    return [\n        [\n            [arrowSX, arrowSY],\n            [arrowEX, arrowEY],\n        ],\n        attrMapped,\n    ];\n};\nconst Line = ({ shape, canvasSize }) => {\n    const startArrowhead = getArrowhead(shape.properties.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.properties.endArrowhead.contents);\n    const [[[arrowSX, arrowSY], [arrowEX, arrowEY]], attrToNotAutoMap,] = makeRoomForArrows(shape, startArrowhead, endArrowhead);\n    const [sx, sy] = toScreen([arrowSX, arrowSY], canvasSize);\n    const [ex, ey] = toScreen([arrowEX, arrowEY], canvasSize);\n    const path = `M ${sx} ${sy} L ${ex} ${ey}`;\n    const color = toSvgPaintProperty(shape.properties.strokeColor.contents);\n    const thickness = shape.properties.strokeWidth.contents;\n    const opacity = toSvgOpacityProperty(shape.properties.strokeColor.contents);\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const startArrowId = shape.properties.name.contents + \"-startArrowId\";\n    const endArrowId = shape.properties.name.contents + \"-endArrowId\";\n    if (startArrowhead) {\n        const startArrowheadSize = shape.properties\n            .startArrowheadSize.contents;\n        const flip = shape.properties.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, color, opacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowheadSize = shape.properties\n            .endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, color, opacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"strokeColor\", \"strokeWidth\", \"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\");\n    const pathElem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    pathElem.setAttribute(\"d\", path);\n    // Opacity and width only relevant if stroke is present\n    if (shape.properties.strokeColor.contents.tag !== \"NONE\") {\n        pathElem.setAttribute(\"stroke-opacity\", opacity.toString());\n        pathElem.setAttribute(\"stroke-width\", thickness.toString());\n    }\n    pathElem.setAttribute(\"stroke\", color);\n    // factor out an AttrHelper\n    if (\"strokeDasharray\" in shape.properties &&\n        shape.properties.strokeDasharray.contents !== \"\") {\n        pathElem.setAttribute(\"stroke-dasharray\", shape.properties.strokeDasharray.contents);\n    }\n    else if (shape.properties.strokeStyle.contents === \"dashed\") {\n        pathElem.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n    }\n    attrToNotAutoMap.push(\"strokeDasharray\", \"strokeStyle\");\n    if (\"strokeLinecap\" in shape.properties &&\n        shape.properties.strokeLinecap.contents !== \"\") {\n        pathElem.setAttribute(\"stroke-linecap\", shape.properties.strokeLinecap.contents);\n    }\n    else {\n        pathElem.setAttribute(\"stroke-linecap\", \"butt\"); // same default as SVG\n    }\n    attrToNotAutoMap.push(\"strokeLinecap\");\n    // TODO: dedup in AttrHelper\n    if (startArrowhead) {\n        pathElem.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        pathElem.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(pathElem);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Line;\n//# sourceMappingURL=Line.js.map","import _ from \"lodash\";\nimport { getArrowhead, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrTitle, DASH_ARRAY } from \"./AttrHelper\";\nimport { arrowHead } from \"./Line\";\nconst toPathString = (pathData, canvasSize) => pathData\n    .map((pathCmd) => {\n    const { cmd, contents } = pathCmd;\n    if (contents.length === 0 && cmd !== \"Z\") {\n        console.error(\"WARNING: empty path\");\n        return \"\";\n    }\n    const pathStr = _.flatten(\n    // the `number[]` type annotation is necessary to ensure that a compile\n    // error occurs here if more `SubPath` subtypes are added in the future\n    contents.map((c) => {\n        switch (c.tag) {\n            case \"CoordV\": {\n                return toScreen(c.contents, canvasSize);\n            }\n            case \"ValueV\": {\n                return c.contents;\n            }\n        }\n    })).join(\" \");\n    return `${cmd} ${pathStr}`;\n})\n    .join(\" \");\nconst Shadow = (id) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"filter\");\n    elem.setAttribute(\"id\", id);\n    elem.setAttribute(\"x\", \"0\");\n    elem.setAttribute(\"y\", \"0\");\n    elem.setAttribute(\"width\", \"200%\");\n    elem.setAttribute(\"height\", \"200%\");\n    elem.innerHTML = `\n    <feOffset result=\"offOut\" in=\"SourceAlpha\" dx=\"5\" dy=\"5\" />\n       <feGaussianBlur result=\"blurOut\" in=\"offOut\" stdDeviation=\"4\" />\n       <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" />\n       <feComponentTransfer>\n         <feFuncA type=\"linear\" slope=\"0.5\" />\n       </feComponentTransfer>\n       <feMerge>\n         <feMergeNode />\n         <feMergeNode in=\"SourceGraphic\" />\n       </feMerge>\n    `;\n    return elem;\n};\nexport const Path = ({ shape, canvasSize }) => {\n    // TODO: distinguish between fill opacity and stroke opacity\n    const startArrowId = shape.properties.name.contents + \"-startArrowId\";\n    const endArrowId = shape.properties.name.contents + \"-endArrowId\";\n    const shadowId = shape.properties.name.contents + \"-shadow\";\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const strokeWidth = shape.properties.strokeWidth.contents;\n    const strokeColor = toSvgPaintProperty(shape.properties.strokeColor.contents);\n    const strokeOpacity = toSvgOpacityProperty(shape.properties.strokeColor.contents);\n    const fillColor = toSvgPaintProperty(shape.properties.fillColor.contents);\n    const fillOpacity = toSvgOpacityProperty(shape.properties.fillColor.contents);\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    const startArrowhead = getArrowhead(shape.properties.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.properties.endArrowhead.contents);\n    if (startArrowhead) {\n        const startArrowId = shape.properties.name.contents + \"-startArrowId\";\n        const startArrowheadSize = shape.properties\n            .startArrowheadSize.contents;\n        const flip = shape.properties.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, strokeColor, strokeOpacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowId = shape.properties.name.contents + \"-endArrowId\";\n        const endArrowheadSize = shape.properties\n            .endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, strokeColor, strokeOpacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"name\", \"strokeColor\", \"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\");\n    elem.appendChild(Shadow(shadowId));\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"stroke\", strokeColor);\n    path.setAttribute(\"fill\", fillColor);\n    attrToNotAutoMap.push(\"fillColor\", \"strokeColor\");\n    // Stroke opacity and width only relevant if paint is present\n    if (shape.properties.strokeColor.contents.tag !== \"NONE\") {\n        path.setAttribute(\"stroke-width\", strokeWidth.toString());\n        path.setAttribute(\"stroke-opacity\", strokeOpacity.toString());\n        attrToNotAutoMap.push(\"strokeColor\", \"strokeWidth\");\n    }\n    // Fill opacity only relevant if paint is present\n    if (shape.properties.fillColor.contents.tag !== \"NONE\") {\n        path.setAttribute(\"fill-opacity\", fillOpacity.toString());\n        attrToNotAutoMap.push(\"fillColor\");\n    }\n    // factor out an AttrHelper\n    if (\"strokeDasharray\" in shape.properties &&\n        shape.properties.strokeDasharray.contents !== \"\") {\n        path.setAttribute(\"stroke-dasharray\", shape.properties.strokeDasharray.contents);\n    }\n    else if (shape.properties.strokeStyle.contents === \"dashed\") {\n        path.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n    }\n    attrToNotAutoMap.push(\"strokeDasharray\", \"strokeStyle\");\n    // TODO: ded\n    path.setAttribute(\"d\", toPathString(shape.properties.d.contents, canvasSize));\n    attrToNotAutoMap.push(\"d\");\n    if (startArrowhead) {\n        path.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        path.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(path);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Path;\n//# sourceMappingURL=Path.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst Polygon = ({ shape, canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Polygon;\n//# sourceMappingURL=Polygon.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst Polyline = ({ shape, canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polyline\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Polyline;\n//# sourceMappingURL=Polyline.js.map","import { attrAutoFillSvg, attrCornerRadius, attrFill, attrRotation, attrStroke, attrTitle, attrWH, attrXY, } from \"./AttrHelper\";\nconst Rectangle = ({ shape, canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrXY(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrWH(shape, elem));\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrCornerRadius(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Rectangle;\n//# sourceMappingURL=Rectangle.js.map","import { toScreen } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrFill, attrFont, attrRotation, attrString, attrStroke, attrTitle, attrWH, } from \"./AttrHelper\";\nconst Text = ({ shape, canvasSize, labels }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"x\", \"y\");\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrString(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrFont(shape, elem));\n    // Get width/height of the text if available\n    const name = shape.properties.name;\n    const retrievedLabel = labels.get(name.contents);\n    // Directly render the text with [x, y] in screen coordinates without transforming them using `width` and `height`\n    const center = shape.properties.center;\n    const [x, y] = toScreen(center.contents, canvasSize);\n    if (retrievedLabel && retrievedLabel.tag === \"TextData\") {\n        // adjust the y-coordinate of the text center s.t. it's the center of the bbox\n        // see https://user-images.githubusercontent.com/11740102/149545843-84406be2-b3dc-4294-b01f-26ef8a2098ee.png for an illustration\n        const descent = retrievedLabel.descent.contents;\n        const height = retrievedLabel.height.contents;\n        const centerY = y + (height / 2 - descent);\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", centerY.toString());\n        attrToNotAutoMap.push(...attrWH(shape, elem));\n    }\n    else {\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", y.toString());\n    }\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default Text;\n//# sourceMappingURL=Text.js.map","import Circle from \"./Circle\";\nimport Ellipse from \"./Ellipse\";\nimport Equation from \"./Equation\";\nimport Image from \"./Image\";\nimport Line from \"./Line\";\nimport Path from \"./Path\";\nimport Polygon from \"./Polygon\";\nimport Polyline from \"./Polyline\";\nimport Rectangle from \"./Rectangle\";\nimport Text from \"./Text\";\nconst shapeMap = {\n    Circle,\n    Ellipse,\n    Rectangle,\n    Polygon,\n    Polyline,\n    Equation,\n    Path,\n    Line,\n    Image,\n    Text,\n};\nexport default shapeMap;\n//# sourceMappingURL=shapeMap.js.map","/* Renderer.ts\n *\n * A simple translation layer for turning Shapes into SVG tags.\n *\n */\nimport { shapedefs } from \"../shapes/Shapes\";\nimport { dragUpdate } from \"./dragUtils\";\nimport shapeMap from \"./shapeMap\";\n/**\n * Turns Shape GPI data into a corresponding SVG element\n */\nexport const RenderShape = async ({ shape, labels, canvasSize, pathResolver, }) => {\n    if (!(shape.shapeType in shapeMap)) {\n        console.error(`${shape.shapeType} shape doesn't exist in shapeMap`);\n        return document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    }\n    return await shapeMap[shape.shapeType]({\n        shape,\n        labels,\n        canvasSize,\n        pathResolver,\n    });\n};\n/**\n * Converts screen to relative SVG coords\n * Thanks to\n * https://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/\n * @param e\n * @param svg\n */\nconst getPosition = ({ clientX, clientY }, svg) => {\n    const CTM = svg.getScreenCTM();\n    if (CTM !== null) {\n        return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };\n    }\n    return { x: 0, y: 0 };\n};\n/**\n * Makes a shape draggable. Browser only.\n * @param onDrag callback when drag complete\n * @param parentSVG\n * @param canvasSizeCustom\n */\nexport const DraggableShape = async (shapeProps, onDrag, parentSVG, canvasSizeCustom) => {\n    const canvas = shapeProps.canvasSize;\n    const elem = await RenderShape(Object.assign(Object.assign({}, shapeProps), { canvasSize: canvasSizeCustom ? canvasSizeCustom : canvas }));\n    const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const { shapeType } = shapeProps.shape;\n    if (shapedefs[shapeType].isLinelike) {\n        g.setAttribute(\"pointer-events\", \"visibleStroke\");\n    }\n    else if (shapedefs[shapeType].isRectlike) {\n        g.setAttribute(\"pointer-events\", \"bounding-box\");\n    }\n    else {\n        g.setAttribute(\"pointer-events\", \"auto\");\n    }\n    g.appendChild(elem);\n    const onMouseDown = (e) => {\n        const { clientX, clientY } = e;\n        const { x: tempX, y: tempY } = getPosition({ clientX, clientY }, parentSVG);\n        const { width: bboxW, height: bboxH, x: bboxX, y: bboxY, } = e.target.getBBox({ stroke: true });\n        const minX = tempX - bboxX;\n        const maxX = canvas[0] - bboxW + (tempX - bboxX);\n        const minY = tempY - bboxY;\n        const maxY = canvas[1] - bboxH + (tempY - bboxY);\n        g.setAttribute(\"opacity\", \"0.5\");\n        let dx = 0, dy = 0;\n        const onMouseMove = (e) => {\n            const { x, y } = getPosition(e, parentSVG);\n            const constrainedX = clamp(x, minX, maxX);\n            const constrainedY = clamp(y, minY, maxY);\n            dx = constrainedX - tempX;\n            dy = tempY - constrainedY;\n            g.setAttribute(`transform`, `translate(${dx},${-dy})`);\n        };\n        const onMouseUp = () => {\n            g.setAttribute(\"opacity\", \"1\");\n            document.removeEventListener(\"mouseup\", onMouseUp);\n            document.removeEventListener(\"mousemove\", onMouseMove);\n            onDrag(shapeProps.shape.properties.name.contents, dx, dy);\n        };\n        document.addEventListener(\"mouseup\", onMouseUp);\n        document.addEventListener(\"mousemove\", onMouseMove);\n    };\n    g.addEventListener(\"mousedown\", onMouseDown);\n    return g;\n};\n/**\n *\n * @param state\n * @param updateState Callback for drag-updated state\n * @param pathResolver Resolves paths to static strings\n * @returns\n */\nexport const RenderInteractive = async (state, updateState, pathResolver) => {\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"width\", \"100%\");\n    svg.setAttribute(\"height\", \"100%\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"viewBox\", `0 0 ${state.canvas.width} ${state.canvas.height}`);\n    const onDrag = (id, dx, dy) => {\n        updateState(dragUpdate(state, id, dx, dy));\n    };\n    for (const shape of state.computeShapes(state.varyingValues)) {\n        svg.appendChild(await DraggableShape({\n            shape,\n            labels: state.labelCache,\n            canvasSize: state.canvas.size,\n            pathResolver,\n        }, onDrag, svg));\n    }\n    return svg;\n};\n/**\n * Renders a static SVG of the shapes and labels.\n * @param pathResolver Resolves paths to static strings\n */\nexport const RenderStatic = async (state, pathResolver) => {\n    const { varyingValues, computeShapes, labelCache: labels, canvas } = state;\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${canvas.width} ${canvas.height}`);\n    return Promise.all(computeShapes(varyingValues).map((shape) => RenderShape({\n        shape,\n        labels,\n        canvasSize: canvas.size,\n        pathResolver,\n    }))).then((renderedShapes) => {\n        for (const shape of renderedShapes) {\n            svg.appendChild(shape);\n        }\n        return svg;\n    });\n};\nconst clamp = (x, min, max) => Math.min(Math.max(x, min), max);\n//# sourceMappingURL=Renderer.js.map","import { genOptProblem } from \"@penrose/optimizer\";\nimport seedrandom from \"seedrandom\";\nimport { checkDomain, compileDomain, parseDomain } from \"./compiler/Domain\";\nimport { compileStyle } from \"./compiler/Style\";\nimport { checkSubstance, compileSubstance, parseSubstance, prettySubstance, } from \"./compiler/Substance\";\nimport { RenderInteractive, RenderShape, RenderStatic, } from \"./renderer/Renderer\";\nimport { showMutations } from \"./synthesis/Mutation\";\nimport { Synthesizer } from \"./synthesis/Synthesizer\";\nimport { collectLabels, insertPending } from \"./utils/CollectLabels\";\nimport { andThen, err, nanError, ok, showError } from \"./utils/Error\";\nimport { bBoxDims, normList, prettyPrintExpr, prettyPrintFn, prettyPrintPath, safe, toSvgPaintProperty, } from \"./utils/Util\";\n/**\n * Use the current resample seed to sample all shapes in the State.\n * @param state current state\n */\nexport const resample = (state) => {\n    const rng = seedrandom(state.variation);\n    const { constraintSets, optStages } = state;\n    const { inputMask, objMask, constrMask } = safe(constraintSets.get(optStages[0]), \"missing first stage\");\n    return insertPending(Object.assign(Object.assign({}, state), { varyingValues: state.inputs.map((meta) => meta.init.tag === \"Sampled\" ? meta.init.sampler(rng) : meta.init.pending), currentStageIndex: 0, params: genOptProblem(inputMask, objMask, constrMask) }));\n};\n/**\n * Take n steps in the optimizer given the current state.\n * @param state current state\n * @param numSteps number of steps to take (default: 10000)\n */\nexport const stepState = (state, numSteps = 10000) => {\n    const steppedState = Object.assign(Object.assign({}, state), state.gradient.step(state, numSteps));\n    if (stateConverged(steppedState) && !finalStage(steppedState)) {\n        const nextInitState = nextStage(steppedState);\n        return nextInitState;\n    }\n    else {\n        return steppedState;\n    }\n};\nexport const nextStage = (state) => {\n    if (finalStage(state)) {\n        return state;\n    }\n    else {\n        const { constraintSets, optStages, currentStageIndex } = state;\n        const nextStage = optStages[currentStageIndex + 1];\n        const { inputMask, objMask, constrMask } = safe(constraintSets.get(nextStage), \"missing next stage\");\n        return Object.assign(Object.assign({}, state), { currentStageIndex: currentStageIndex + 1, params: genOptProblem(inputMask, objMask, constrMask) });\n    }\n};\nexport const stepNextStage = (state, numSteps = 10000) => {\n    let currentState = state;\n    while (!(currentState.params.optStatus === \"Error\") &&\n        !stateConverged(currentState)) {\n        currentState = Object.assign(Object.assign({}, currentState), currentState.gradient.step(currentState, numSteps));\n    }\n    return nextStage(currentState);\n};\n/**\n * Take n steps in the optimizer given the current state.\n * @param state current state\n * @param numSteps number of steps to take (default: 10000)\n */\nexport const stepStateSafe = (state, numSteps = 10000) => {\n    const res = stepState(state, numSteps);\n    if (res.params.optStatus === \"Error\") {\n        return err(Object.assign({ errorType: \"RuntimeError\" }, nanError(\"\", res)));\n    }\n    return ok(res);\n};\n/**\n * Repeatedly take one step in the optimizer given the current state until convergence.\n * @param state current state\n */\nexport const stepUntilConvergence = (state, numSteps = 10000) => {\n    let currentState = state;\n    while (!(currentState.params.optStatus === \"Error\") &&\n        (!stateConverged(currentState) || !finalStage(currentState))) {\n        if (stateConverged(currentState)) {\n            currentState = nextStage(currentState);\n        }\n        currentState = stepState(currentState, numSteps);\n    }\n    if (currentState.params.optStatus === \"Error\") {\n        return err(Object.assign({ errorType: \"RuntimeError\" }, nanError(\"\", currentState)));\n    }\n    return ok(currentState);\n};\nconst stepUntilConvergenceOrThrow = (state) => {\n    const result = stepUntilConvergence(state);\n    if (result.isErr()) {\n        throw Error(showError(result.error));\n    }\n    else {\n        return result.value;\n    }\n};\n/**\n * Embed a static Penrose diagram in a DOM node.\n *\n * @param domainProg a Domain program string\n * @param subProg a Substance program string\n * @param styProg a Style program string\n * @param node a node in the DOM tree\n */\nexport const diagram = async (prog, node, pathResolver) => {\n    const res = await compileTrio(prog);\n    if (res.isOk()) {\n        const state = await prepareState(res.value);\n        const optimized = stepUntilConvergenceOrThrow(state);\n        const rendered = await RenderStatic(optimized, pathResolver);\n        node.appendChild(rendered);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Embed an interactive Penrose diagram in a DOM node.\n *\n * @param domainProg a Domain program string\n * @param subProg a Substance program string\n * @param styProg a Style program string\n * @param node a node in the DOM tree\n */\nexport const interactiveDiagram = async (prog, node, pathResolver) => {\n    const updateData = async (state) => {\n        const stepped = stepUntilConvergenceOrThrow(state);\n        const rendering = await RenderInteractive(stepped, updateData, pathResolver);\n        node.replaceChild(rendering, node.firstChild);\n    };\n    const res = await compileTrio(prog);\n    if (res.isOk()) {\n        const state = await prepareState(res.value);\n        const optimized = stepUntilConvergenceOrThrow(state);\n        const rendering = await RenderInteractive(optimized, updateData, pathResolver);\n        node.appendChild(rendering);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Given a trio of Domain, Substance, and Style programs, compile them into an initial `State`. Note that this function does _not_ evaluate the shapes. Generation of shapes is handled in `prepareState`.\n * @param domainProg a Domain program string\n * @param subProg a Substance program string\n * @param styProg a Style program string\n */\nexport const compileTrio = async (prog) => {\n    const domainRes = compileDomain(prog.domain);\n    const subRes = andThen((env) => compileSubstance(prog.substance, env), domainRes);\n    const styRes = subRes.isErr()\n        ? err(subRes.error)\n        : await compileStyle(prog.variation, prog.style, ...subRes.value);\n    return styRes;\n};\n/**\n * Collect labels and images (if applicable).\n * @param state an initial diagram state\n */\nexport const prepareState = async (state) => {\n    const labelCache = await collectLabels(state.shapes);\n    if (labelCache.isErr()) {\n        throw Error(showError(labelCache.error));\n    }\n    return insertPending(Object.assign(Object.assign({}, state), { labelCache: labelCache.value }));\n};\n/**\n * Returns true if state is converged\n * @param state current state\n */\nexport const stateConverged = (state) => state.params.optStatus === \"EPConverged\";\n/**\n * Returns true if the diagram state is on the last layout stage in the layout pipeline\n * @param state current state\n */\nexport const finalStage = (state) => state.currentStageIndex === state.optStages.length - 1;\n/**\n * Returns true if state is the initial frame\n * @param state current state\n */\nexport const stateInitial = (state) => state.params.optStatus === \"NewIter\";\n/**\n * Read and flatten the registry file for Penrose examples into a list of program trios.\n *\n * @param registry JSON file of the registry\n */\nexport const readRegistry = (registry) => {\n    const { substances, styles, domains, trios } = registry;\n    const res = [];\n    for (const { domain: dslID, style: styID, substance: subID, variation, } of trios) {\n        const domain = domains[dslID];\n        const substance = substances[subID];\n        const style = styles[styID];\n        const trio = {\n            substanceURI: substance.URI,\n            styleURI: style.URI,\n            domainURI: domain.URI,\n            substanceName: substance.name,\n            styleName: style.name,\n            domainName: domain.name,\n            variation,\n            name: `${subID}-${styID}`,\n        };\n        res.push(trio);\n    }\n    return res;\n};\n/**\n * Evaluate the overall energy of a `State`. If the `State` does not have an optimization problem initialized (i.e. it doesn't have a defined `objectiveAndGradient` field), this function will call `genOptProblem` to initialize it. Otherwise, it will evaluate the cached objective function.\n * @param s a state with or without an optimization problem initialized\n * @returns a scalar value of the current energy\n */\nexport const evalEnergy = (s) => {\n    // TODO: maybe don't also compute the gradient, just to throw it away\n    return s.gradient.call([...s.varyingValues, s.params.weight]).primary;\n};\n/**\n * Evaluate a list of constraints/objectives: this will be useful if a user want to apply a subset of constrs/objs on a `State`. This function assumes that the state already has the objectives and constraints compiled.\n * @param fns a list of constraints/objectives\n * @param s a state with its opt functions cached\n * @returns a list of the energies of the requested functions, evaluated at the `varyingValues` in the `State`\n */\nexport const evalFns = (s) => {\n    const { constrFns, objFns } = s;\n    // Evaluate the energy of each requested function (of the given type) on the varying values in the state\n    let { lastObjEnergies, lastConstrEnergies } = s.params;\n    if (lastObjEnergies === null || lastConstrEnergies === null) {\n        const { secondary } = s.gradient.call([\n            ...s.varyingValues,\n            s.params.weight,\n        ]);\n        lastObjEnergies = secondary.slice(0, s.params.objMask.length);\n        lastConstrEnergies = secondary.slice(s.params.objMask.length);\n    }\n    return {\n        constrEngs: lastConstrEnergies,\n        objEngs: lastObjEnergies,\n    };\n};\nexport { constrDict } from \"./contrib/Constraints\";\nexport { compDict } from \"./contrib/Functions\";\nexport { objDict } from \"./contrib/Objectives\";\nexport { secondaryGraph } from \"./engine/Autodiff\";\nexport { makeCanvas, simpleContext } from \"./shapes/Samplers\";\nexport { shapedefs } from \"./shapes/Shapes\";\nexport * as Value from \"./types/value\";\nexport { hexToRgba, rgbaToHex, zip2 } from \"./utils/Util\";\nexport { compileDomain, compileSubstance, checkDomain, checkSubstance, parseSubstance, parseDomain, Synthesizer, showMutations, RenderShape, RenderInteractive, RenderStatic, bBoxDims, prettySubstance, showError, prettyPrintFn, prettyPrintPath, prettyPrintExpr, normList, toSvgPaintProperty, };\n//# sourceMappingURL=index.js.map","export default async function fetchResolver(\n  path: string\n): Promise<string | undefined> {\n  const response = await fetch(path);\n  if (!response.ok) {\n    console.error(`could not fetch ${path}`);\n    return undefined;\n  }\n  return await response.text();\n}\n","import {\n  compileTrio,\n  PenroseError,\n  PenroseState,\n  prepareState,\n  RenderInteractive,\n  RenderStatic,\n  resample,\n  showError,\n  stateConverged,\n  stepState,\n  stepUntilConvergence,\n} from \"@penrose/core\";\nimport React from \"react\";\nimport fetchResolver from \"./fetchPathResolver\";\n\nexport interface SimpleProps {\n  domain: string;\n  substance: string;\n  style: string;\n  variation: string;\n  stepSize?: number;\n  interactive?: boolean; // considered true by default\n  animate?: boolean; // considered false by default\n  onFrame?: (frame: PenroseState) => void;\n}\n\nexport interface SimpleState {\n  error?: PenroseError;\n}\n\nclass Simple extends React.Component<SimpleProps, SimpleState> {\n  readonly canvasRef = React.createRef<HTMLDivElement>();\n  penroseState: PenroseState | undefined = undefined;\n  timerID: number | undefined = undefined; // for animation\n\n  constructor(props: SimpleProps) {\n    super(props);\n    this.state = {\n      error: undefined,\n    };\n  }\n\n  compile = async (): Promise<void> => {\n    this.penroseState = undefined;\n    const compilerResult = await compileTrio(this.props);\n    if (compilerResult.isOk()) {\n      this.penroseState = await prepareState(compilerResult.value);\n    } else {\n      this.setState({ error: compilerResult.error });\n    }\n  };\n\n  converge = async (): Promise<void> => {\n    if (this.penroseState) {\n      const stepped = stepUntilConvergence(this.penroseState);\n      if (stepped.isOk()) {\n        this.penroseState = stepped.value;\n      } else {\n        this.setState({ error: stepped.error });\n      }\n    }\n  };\n\n  tick = () => {\n    if (\n      this.props.animate &&\n      this.penroseState &&\n      !stateConverged(this.penroseState)\n    ) {\n      this.penroseState = stepState(\n        this.penroseState,\n        this.props.stepSize ?? 1\n      );\n      if (this.props.onFrame) {\n        this.props.onFrame(this.penroseState);\n      }\n      this.renderCanvas();\n    }\n  };\n\n  componentDidMount = async () => {\n    await this.compile();\n    if (!this.props.animate) {\n      await this.converge();\n    }\n    this.renderCanvas();\n    this.timerID = window.setInterval(() => this.tick(), 1000 / 60);\n  };\n\n  componentDidUpdate = async (prevProps: SimpleProps) => {\n    // re-compile if the programs change\n    if (\n      this.props.domain !== prevProps.domain ||\n      this.props.substance !== prevProps.substance ||\n      this.props.style !== prevProps.style\n    ) {\n      await this.compile();\n      if (!this.props.animate) {\n        await this.converge();\n      }\n      this.renderCanvas();\n    }\n\n    // update the component only if there's no error\n    // in the case of an error, they component should not attempt to re-render\n    if (this.penroseState && !this.state.error) {\n      if (\n        this.props.variation !== prevProps.variation ||\n        this.props.animate !== prevProps.animate\n      ) {\n        this.penroseState.variation = this.props.variation;\n        this.penroseState = resample(this.penroseState);\n        if (!this.props.animate) {\n          await this.converge();\n        }\n        this.renderCanvas();\n      } else if (this.props.interactive !== prevProps.interactive) {\n        this.renderCanvas();\n      }\n    }\n  };\n\n  componentWillUnmount = () => {\n    clearInterval(this.timerID);\n  };\n\n  renderCanvas = async () => {\n    if (this.canvasRef.current === null) {\n      return <div>rendering...</div>;\n    } else {\n      const node = this.canvasRef.current;\n      if (this.penroseState) {\n        const renderedState: SVGSVGElement = await (this.props.interactive ===\n        false\n          ? RenderStatic(this.penroseState, fetchResolver)\n          : RenderInteractive(\n              this.penroseState,\n              async (newState) => {\n                this.penroseState = newState;\n                if (!this.props.animate) {\n                  await this.converge();\n                }\n                this.renderCanvas();\n              },\n              fetchResolver\n            ));\n        if (node.firstChild !== null) {\n          node.replaceChild(renderedState, node.firstChild);\n        } else {\n          node.appendChild(renderedState);\n        }\n      } else {\n        console.log(\"state is undefined\");\n      }\n    }\n  };\n\n  render = () => {\n    const { error } = this.state;\n    return (\n      <div style={{ width: \"100%\", height: \"100%\" }}>\n        {!error && (\n          <div style={{ width: \"100%\", height: \"100%\" }} ref={this.canvasRef} />\n        )}\n        {error && (\n          <div style={{ padding: \"1em\", height: \"100%\" }}>\n            <div style={{ fontWeight: 700 }}>1 error:</div>\n            <div style={{ fontFamily: \"monospace\" }}>\n              {showError(error)\n                .toString()\n                .split(\"\\n\")\n                .map((line: string, key: number) => (\n                  <p key={`err-ln-${key}`} style={{ margin: 0 }}>\n                    {line}\n                  </p>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  };\n}\n\nexport { Simple };\n"],"names":["notFound.image"],"mappings":"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"}