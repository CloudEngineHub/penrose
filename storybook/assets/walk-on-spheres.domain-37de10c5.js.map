{"version":3,"file":"walk-on-spheres.domain-37de10c5.js","sources":["../../../examples/dist/walk-on-spheres/walk-on-spheres.style.js","../../../examples/dist/walk-on-spheres/walk-on-spheres.domain.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"layout = [ walkStage, nestStage, labelStage, legendStage ]\\n\\n-- diagram dimensions (in px; multiply by 96/72 to convert to pt)\\ncanvas {\\n   width = 200 -- ==150pt\\n   height = 200 -- ==150pt\\n}\\n\\n-- some colors re-used throughout\\nColors {\\n   color black = rgba(0,0,0,1)\\n   color white = rgba(1,1,1,1)\\n   color darkGray = #b3b3b3\\n   color lightGray = #e5e5e5\\n   color deepGreen = #93c697\\n}\\n\\n-- global shapes and constants\\nGlobal {\\n   scalar toPt = 96/72 -- constant for converting sizes from pt to px\\n\\n   -- default appearance for label text\\n   string labelFont = \\\"Linux Libertine\\\"\\n   string labelSize = \\\"13.333px\\\" -- equivalent to 10pt (multiply by 96/72)\\n   scalar labelHeight = toPt * 10\\n   color labelColor = Colors.black\\n   color subdomainLabelColor = Colors.deepGreen\\n   color labelStrokeColor = Colors.white\\n   scalar labelStrokeWidth = toPt * 1.5\\n\\n   -- appearance of dots/points\\n   scalar dotSize = toPt * 1.5\\n   scalar openDotWidth = toPt * 0.5\\n   scalar dotLabelDistance = 9\\n\\n   -- style of domains/subdomains\\n   color domainColor = Colors.lightGray\\n   color ballColor = rgba(154/255.,204/255.,160/255.,1)\\n   color sphereColor = rgba(27/255.,138/255.,31/255.,1)\\n   scalar subdomainOpacity = .35\\n   scalar sphereStrokeWidth = toPt * .5\\n   scalar domainStrokeWidth = toPt * 1\\n   scalar dirichletStrokeWidth = domainStrokeWidth\\n   scalar neumannStrokeWidth = .65*domainStrokeWidth\\n   string neumannDash = \\\"2.66,2.66\\\" -- \\\"2,2\\\"\\n   scalar labelPadding = 6\\n\\n   -- style of lines along a walk\\n   -- (set color to none() to disable)\\n   color walkColor = #0066004c\\n   scalar walkStrokeWidth = toPt * 1\\n\\n}\\n\\nforall Domain D {\\n   -- draw the domain as a polygon with some random variation, by\\n   -- perturbing the vertices of a hexagon by some bounded amount\\n   -- Note: if the domain shape is changed to something else (like\\n   -- an ellipse or a rectangle), things _should_ still work as\\n   -- expected, since later methods just make a call to `signedDistance`\\n   -- to determine ball radii.  However, signed distance may not yet\\n   -- be supported for all shapes (like arbitrary Bézier curves).\\n   scalar maxPerturbation = 15\\n   scalar w = .8*canvas.width/2\\n   scalar h = .8*canvas.height/2\\n   vec2 D.p0 = ( w, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p1 = ( 0, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p2 = (-w, -h) + maxPerturbation*diskRandom()\\n   vec2 D.p3 = (-w,  h) + maxPerturbation*diskRandom()\\n   vec2 D.p4 = ( 0,  h) + maxPerturbation*diskRandom()\\n   vec2 D.p5 = ( w,  h) + maxPerturbation*diskRandom()\\n   shape D.geometry = Polygon {\\n      points: [ D.p0, D.p1, D.p2, D.p3, D.p4, D.p5 ]\\n      fillColor: Colors.lightGray\\n      strokeColor: Colors.darkGray\\n      strokeWidth: Global.domainStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- label the domain if it was assigned a label in the Substance program\\nforall Domain D\\nwhere D has label {\\n\\n   scalar x = ? in labelStage\\n   scalar y = ? in labelStage\\n   shape D.labelText = Equation {\\n      string: D.label\\n      center: (x,y)\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fillColor: Colors.black\\n      ensureOnCanvas: false\\n   }\\n\\n   ensure lessThan( signedDistance( D.geometry, D.labelText.center ), -9. ) in labelStage\\n   layer D.labelText above D.geometry -- make sure the label doesn't get covered by the domain shape\\n}\\n\\nforall Domain D\\nwhere hasMixedBoundaryConditions( D ) {\\n   override D.geometry.strokeColor = none()\\n\\n   shape D.poly0 = Polyline {\\n      points: ( D.p5, D.p0 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeLinecap: \\\"round\\\"\\n      ensureOnCanvas: false\\n   }\\n   shape D.poly1 = Polyline {\\n      points: ( D.p0, D.p1, D.p2 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.neumannStrokeWidth\\n      ensureOnCanvas: false\\n      style: \\\"dashed\\\"\\n      strokeDasharray: Global.neumannDash\\n   }\\n   shape D.poly2 = Polyline {\\n      points: ( D.p2, D.p3 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeLinecap: \\\"round\\\"\\n      ensureOnCanvas: false\\n   }\\n   shape D.poly3 = Polyline {\\n      points: ( D.p3, D.p4, D.p5 )\\n      strokeColor: Colors.black\\n      strokeWidth: Global.neumannStrokeWidth\\n      ensureOnCanvas: false\\n      style: \\\"dashed\\\"\\n      strokeDasharray: Global.neumannDash\\n   }\\n\\n   shape D.dirichletBoundary = Group {\\n      shapes: ( D.poly0, D.poly2 )\\n      ensureOnCanvas: false\\n   }\\n   shape D.neumannBoundary = Group {\\n      shapes: ( D.poly1, D.poly3 )\\n      ensureOnCanvas: false\\n   }\\n\\n   layer D.dirichletBoundary above D.geometry\\n   layer D.neumannBoundary above D.dirichletBoundary\\n}\\n\\n-- draw each point as a small dot\\nforall Point p {\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   vec2 p.location = (x,y)\\n\\n   -- The `dot` shape represents the sample point associated\\n   -- with the ball.  Ordinarily this point will be at the\\n   -- center of the ball, but in general it could be at a\\n   -- different location (e.g., for an off-center walk).\\n   shape p.dot = Circle {\\n      center: p.location\\n      r: Global.dotSize\\n      fillColor: Colors.black\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- draw each Ball as the largest ball tangent to the domain boundary\\nforall Ball B; Domain D {\\n\\n   -- Make sure the ball is inside the problem domain by\\n   -- setting its radius to (minus) the signed distance to\\n   -- the domain boundary.  This value is negated since, by\\n   -- convention, points inside the domain have negative\\n   -- signed distance.\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   vec2 B.center = (x,y)\\n   scalar B.radius = -signedDistance( D.geometry, B.center ) - Global.sphereStrokeWidth/2 - Global.domainStrokeWidth/2.\\n\\n   -- The `ball` shape is a flat-shaded semi-transparent\\n   -- disk that determines the color of the ball.\\n   -- The ball radius equals the distance from the\\n   -- ball center to the closest point on the domain boundary\\n   -- (just as in the WoS algorithm!).  We also subtract half\\n   -- the stroke widths so that visually the ball makes perfect\\n   -- tangential contact with the domain boundary.\\n   -- Note that we don't need to\\n   -- explicitly enforce that the ball remains on the canvas,\\n   -- since the domain shape already has an onCanvas constraint,\\n   -- and the balls are always contained in the domain shape, by\\n   -- construction.\\n   shape B.ball = Circle {\\n      center: B.center\\n      r: B.radius\\n      fillColor: Global.ballColor\\n      strokeColor: Global.sphereColor\\n      strokeWidth: Global.sphereStrokeWidth\\n      opacity: Global.subdomainOpacity\\n      ensureOnCanvas: false\\n   }\\n\\n   shape B.shading = Image {\\n      href: \\\"ball-shading.svg\\\"\\n      center: B.ball.center\\n      width: 2*B.ball.r\\n      height: 2*B.ball.r\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure all components of the ball get drawn in the\\n   -- proper order, and are not covered up by the domain shape.\\n   layer B.ball above B.shading\\n   layer B.shading above D.geometry\\n\\n   -- This constant determines how much balls shrink from one\\n   -- step of the walk to the next.  We define it as a named\\n   -- constant so that specialized types of balls (say, those\\n   -- coming from a nested walk) can use a different factor.\\n   scalar B.shrinkFactor = .55\\n}\\n\\n-- If a ball is constructed around a point, center it around that point\\nforall Point p; Ball B\\nwhere B := ballAround( p ) {\\n   override B.center = p.location\\n   layer p.dot above B.ball\\n}\\n\\n-- For a step of an off-centered walk, we want to clearly\\n-- indicate that the sample point may not be at the ball center.\\nforall Ball B; Point p\\nwhere B := ballAround(p); isOffCenter(B) {\\n\\n   -- We can no longer just copy the ball center from the point center,\\n   -- but will instead let the layout engine determine its location.\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   override B.center = (x,y)\\n\\n   -- Still keep the center within the middle 25–75% of the ball, since\\n   -- the dot may be hard to see if it gets too close to the boundary\\n   -- (especially for very small balls).\\n   scalar r = B.radius * random(.25,.75)\\n   ensure norm(B.center - p.location) == r in walkStage\\n}\\n\\n-- If a point has a label, draw a label string near the dot.\\nforall Point p\\nwhere p has label {\\n   shape p.labelText = Equation {\\n      string: p.label\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.labelColor\\n      --strokeColor: Global.labelStrokeColor\\n      --strokeWidth: Global.labelStrokeWidth\\n      --strokeLinejoin: \\\"round\\\"\\n      --paintOrder: \\\"stroke\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   -- We want the label to be near the dot, but don't want it\\n   -- to overlap the dot (which makes it hard to read).\\n   scalar theta = ? in labelStage\\n   p.labelText.center = p.dot.center + Global.dotLabelDistance*( cos(theta), sin(theta) )\\n\\n   -- If we fail to avoid overlap, we should\\n   -- at least draw the label on top of the dot\\n   layer p.labelText above p.dot\\n}\\n\\n-- Make sure a point's label doesn't get covered by a ball\\n-- containing it, by layering it above the topmost ball shape.\\nforall Point p; Ball B\\nwhere B := ballAround( p ); p has label {\\n   layer p.labelText above B.ball\\n}\\n\\n-- If a point p is sampled from the boundary of a ball B,\\n-- make sure it sits on the corresponding sphere ∂B.\\nforall Ball B; Point p\\nwhere p := sampleBoundary( B ) {\\n   constraint p.ballConstraint = ensure equal( norm(p.location - B.center), B.radius ) in walkStage\\n\\n   -- Make sure the dot is not covered by the sphere.\\n   layer p.dot above B.ball\\n}\\n\\n-- If a point p is sampled from the interior of a ball B,\\n-- make sure it sits somewhere between 20% and 80% away\\n-- from the center, so that it's clearly visible and doesn't\\n-- run into the center point or the boundary.\\nforall Ball B; Point p\\nwhere p := sampleInterior( B ) {\\n   scalar r = B.radius * random(.2,.8)\\n   constraint p.ballConstraint = ensure norm( p.location - B.center ) == r in walkStage\\n\\n   -- Make sure the dot is not covered by the ball.\\n   layer p.dot above B.ball\\n}\\n\\n\\n-- Adjust the drawing for consecutive steps x0, x1 along a walk on spheres,\\n-- where B0, B1 are the associated spheres.\\nforall Ball B0; Ball B1; Point x0; Point x1\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {\\n   -- draw later steps of a walk as smaller balls (which is often, but\\n   -- not always, the behavior of the WoS algorithm)\\n   ensure equal( B1.radius, B1.shrinkFactor * B0.radius ) in walkStage\\n\\n   -- It's typically easier to see labels, etc., if later, smaller\\n   -- balls are drawn on top of earlier, bigger ones.\\n   layer B1.ball above B0.ball\\n}\\n\\n-- Draw a line between the consecutive points on a walk on spheres\\nforall Point x0; Point x1; Ball B0; Domain D\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ) {\\n\\n   shape x1.walkLine = Line {\\n      start: x0.location\\n      end: x1.location\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n   layer x1.walkLine above D.geometry\\n\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine above B0.ball\\n}\\n\\nforall Point x0; Point x1; Ball B0; Ball B1; Domain D\\nwhere x1 := sampleBoundary( B0 ); B0 := ballAround( x0 ); B1 := ballAround( x1 ) {\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine below B1.ball\\n}\\n\\n-- Draw sample points that are used to estimate the source term\\n-- as just dots contained in the ball of interest.  These sample\\n-- points are different from steps of a walk, since we never\\n-- need to consider a ball around these points (and hence do not\\n-- want to draw one).\\nforall Point p; Ball B\\nwhere p := sampleInterior( B ); isSourceSample( p ) {\\n   scalar x = ? in walkStage\\n   scalar y = ? in walkStage\\n   -- Draw source samples in a different style\\n   override p.location = (x,y)\\n   override p.dot.r = 2\\n   override p.dot.fillColor = Colors.white\\n   override p.dot.strokeColor = Colors.black\\n   override p.dot.strokeWidth = 1\\n}\\n\\n-- Nested walks --------------------------------------------\\n\\n-- Draw nested points in a different style\\nforall NestedPoint p {\\n   scalar x = ? in nestStage\\n   scalar y = ? in nestStage\\n   vec2 p.location = (x,y)\\n\\n   shape p.dot = Circle {\\n      center: p.location\\n      r: 2.5\\n      fillColor: Colors.white\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- Draw nested balls in a different style\\nforall Ball B; NestedPoint p\\nwhere B := nestedBallAround(p) {\\n\\n   override B.center = p.location\\n\\n   -- Change to a color palette that is more white & opaque.\\n   override B.ball.fillColor = none()\\n   override B.ball.strokeColor = none()\\n   override B.shading = Circle{\\n      center: B.center\\n      r: B.radius\\n      fillColor: rgba(1,1,1,.2)\\n      strokeColor: rgba(1,1,1,.5)\\n      strokeWidth: 1\\n      ensureOnCanvas: false\\n   }\\n\\n   override B.shrinkFactor = .7\\n}\\n\\nforall NestedPoint p; Point p0; Ball B; Ball B0; Domain D\\nwhere p := startWalkFrom(B0); B := nestedBallAround(p); B0 := ballAround(p0) {\\n   vec2 y = closestPoint( D.geometry, B0.center )\\n   scalar u = .75\\n   override p.location = (1-u)*B0.center + u*y\\n   override B.center = p.location\\n   override B.radius = norm( y - p.location )\\n}\\n\\nforall NestedPoint p; Ball B\\nwhere p := sampleBoundaryNested(B) {\\n   ensure norm(p.location - B.center) == B.radius in nestStage\\n}\\n\\nforall Ball B0; Ball B1; NestedPoint x0; NestedPoint x1\\nwhere x1 := sampleBoundaryNested( B0 ); B0 := nestedBallAround( x0 ); B1 := nestedBallAround( x1 ) {\\n   ensure equal( B1.radius, B1.shrinkFactor * B0.radius ) in nestStage\\n}\\n\\nforall Ball B; NestedPoint p; Ball B0; Point p0\\nwhere B := nestedBallAround(p); B0 := ballAround(p0) {\\n   layer B.ball above B0.ball\\n}\\n\\n-- Draw a line between the consecutive points on a nested walk\\nforall NestedPoint x0; NestedPoint x1; Ball B0; Domain D\\nwhere x1 := sampleBoundaryNested( B0 ); B0 := nestedBallAround( x0 ) {\\n\\n   shape x1.walkLine = Line {\\n      start: x0.location\\n      end: x1.location\\n      fill: \\\"none\\\"\\n      strokeColor: Colors.white\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n   layer x1.walkLine above D.geometry\\n\\n   -- Use layering to help clarify the direction of the walk.\\n   layer x1.walkLine above B0.ball\\n}\\n\\n-- draw nested walks above regular walks\\nforall NestedPoint p; Ball B {\\n   layer p.dot above B.ball\\n}\\n\\n-- Walk on Stars -------------------------------------------\\n\\n-- If the domain has mixed boundary conditions (and\\n-- hence we're using walk on stars), we want to keep\\n-- track of the normal at point p, which we'll set\\n-- to zero if p is not on the domain boundary.\\nforall Domain D; Point p\\nwhere hasMixedBoundaryConditions( D ) {\\n\\n   override p.location = triangleRandom( D.p0, D.p2, D.p3 )\\n\\n   vec2 p.normal = (0,0)\\n\\n   -- rays from p will be sampled from baseAngle + [-angleRange,angleRange]\\n   scalar p.baseAngle = 0\\n   scalar p.angleRange = MathPI()\\n\\n   layer p.dot above D.neumannBoundary\\n\\n   -- -- draw an arrow for the normal at p (transparent if the normal is zero)\\n   -- scalar eps = 1e-7 -- prevents NaNs for zero-length normals\\n   -- shape p.normalArrow = Line {\\n   --    start: p.location\\n   --    end: p.location + 20*p.normal + eps*(1,1)\\n   --    fill: \\\"none\\\"\\n   --    strokeWidth: 1\\n   --    strokeColor: rgba(1,1,1,.5*norm(p.normal))\\n   --    ensureOnCanvas: false\\n   --    endArrowhead: \\\"straight\\\"\\n   --    endArrowheadSize: .5\\n   -- }\\n   -- layer p.normalArrow below p.dot\\n}\\n\\nforall Star St; Point p; Domain D\\nwhere St := starAround(p) {\\n   vec2 yDirichlet = closestPoint( D.dirichletBoundary, p.location )\\n   scalar St.dDirichlet = norm( yDirichlet - p.location )\\n   scalar St.dNeumann = closestSilhouetteDistance( D.neumannBoundary, p.location )\\n   scalar rMin = 1\\n   scalar R = max( rMin, min( St.dDirichlet, St.dNeumann ))\\n\\n   -- color the boundary of the ball according to whether it's defined\\n   -- by the closest Dirichlet point or closest Neumann silhouette point\\n   scalar upsilon = 1e-7 -- to fudge the case where dDirichlet==dNeumann\\n   scalar t = (St.dDirichlet - R)/(St.dDirichlet - St.dNeumann + upsilon)\\n   -- vec3 c0 = (.4,.6,.4)\\n   -- vec3 c1 = (.4,.4,.7)\\n   vec3 f0 = (154,204,160)/255.\\n   vec3 f1 = (255,255,255)/255.\\n   vec3 s0 = (27,138,31)/255.\\n   vec3 s1 = (27,138,31)/255.\\n   vec3 s = (1-t)*s0 + t*s1\\n   vec3 f = (1-t)*f0 + t*f1\\n\\n   shape St.ball = Circle {\\n      center: p.location\\n      r: R\\n      fillColor: rgba( f[0], f[1], f[2], 1 )\\n      strokeColor: rgba( s[0], s[1], s[2], 1 )\\n      strokeWidth: Global.sphereStrokeWidth\\n      ensureOnCanvas: false\\n      opacity: .35\\n   }\\n\\n   shape St.shading = Image {\\n      href: \\\"ball-shading.svg\\\"\\n      center: St.ball.center\\n      width: 2*St.ball.r\\n      height: 2*St.ball.r\\n      ensureOnCanvas: false\\n   }\\n\\n   layer St.shading above D.geometry\\n   layer St.ball above St.shading\\n\\n   shape St.domainGeometry = Polygon {\\n      points: D.geometry.points\\n      fillColor: none()\\n      ensureOnCanvas: false\\n   }\\n   shape St.G = Group {\\n      shapes: [St.ball,St.shading]\\n      clipPath: clip(St.domainGeometry)\\n      ensureOnCanvas: false\\n   }\\n   layer St.G above D.geometry\\n   layer St.G below D.neumannBoundary\\n}\\n\\nforall Point p; Star St {\\n   layer p.dot above St.ball\\n}\\n\\nforall Point p0; Point p1; Star St; Domain D\\nwhere p1 := sampleBoundary(St); St := starAround(p0) {\\n\\n   -- sample a random ray from p0\\n   scalar theta = p0.baseAngle + p0.angleRange * random(-1,1)\\n   scalar eps = 1e-1 -- offset ray origin to avoid intersecting at x again\\n   vec2 v = ( cos(theta), sin(theta) )\\n   vec2 x = p0.location + eps*v\\n\\n   -- intersect the star boundary\\n   scalar tBoundary = rayIntersectDistance( D.neumannBoundary, x, v )\\n   scalar tBall = St.ball.r\\n   scalar t = min( tBoundary, tBall )\\n   override p1.location = x + t*v \\n\\n   -- set the normal at the intersection point, or set it to zero if\\n   -- the ray hits the ball boundary first\\n   vec2 n = rayIntersectNormal( D.neumannBoundary, x, v )\\n   scalar k = 100. -- steepness parameter for indicator function\\n   scalar s = 1. - exp(-k*sqr(t - tBall)) -- equals zero near tBall and 1 otherwise\\n   override p1.normal = s * n -- scales n to zero if t == tBall\\n   override p1.angleRange = (1-s/2)*MathPI() -- s=0 -> MathPI(); s=1 -> MathPI()/2\\n   scalar delta = 1e-7 -- to get valid angle if normal is zero\\n   override p1.baseAngle = atan2( p1.normal[0], p1.normal[1] + delta )\\n\\n   -- draw the point in white if it's on the Neumann boundary\\n   override p1.dot.fillColor = rgba(s,s,s,1)\\n   override p1.dot.strokeWidth = .5*s\\n   override p1.dot.strokeColor = rgba(0,0,0,1)\\n\\n   -- draw the walk line from p0 to p1\\n   shape p1.walkLine = Line {\\n      start: p0.location\\n      end: p1.location -- - Global.dotSize*v\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      --endArrowhead: \\\"straight\\\"\\n      --endArrowheadSize: .5\\n      ensureOnCanvas: false\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   layer p0.dot above p1.walkLine\\n   layer D.dirichletBoundary above p1.walkLine\\n}\\n\\nforall Point p0; Point p1; Star St; Domain D; Star St2\\nwhere p1 := sampleBoundary(St); St := starAround(p0) {\\n   layer p1.walkLine above St2.ball\\n}\\n\\n-- connect the walk to the closest point on the\\n-- Dirichlet boundary, and draw the boundary point\\n-- in a different style\\nforall Point q; Point p; Domain D\\nwhere q := closestBoundaryPoint( D, p ); hasMixedBoundaryConditions( D )\\n{\\n   override q.dot.center = closestPoint( D.dirichletBoundary, p.location )\\n   override q.dot.fillColor = Colors.white\\n   override q.dot.strokeColor = Colors.black\\n   override q.dot.strokeWidth = Global.openDotWidth\\n\\n   shape q.walkLine = Line {\\n      start: p.dot.center\\n      end: q.dot.center\\n      fill: \\\"none\\\"\\n      strokeColor: Global.walkColor\\n      strokeWidth: Global.walkStrokeWidth\\n      ensureOnCanvas: false\\n   }\\n\\n   layer q.walkLine above D.geometry\\n   layer q.dot above q.walkLine\\n}\\n\\n-- Rays ---------------------------------------\\n\\nforall Ray r; Domain D {\\n   vec2 r.x = (0,0) -- origin\\n   scalar r.L = 30 -- length\\n   scalar r.theta = 0 -- angle\\n   vec2 r.v = ( cos(r.theta), sin(r.theta) ) -- direction\\n\\n   vec2 s = 2.0 -- size\\n   vec2 a = r.x -- start\\n   vec2 b = r.x + r.L*r.v -- end\\n\\n   scalar w = .75\\n   vec2 u = unit(b-a)\\n   vec2 n = rot90(u)\\n   shape r.taperedStroke = Polygon {\\n      points: ( a, b + w*n - 3.5*u, b - w*n - 3.5*u )\\n      fillColor: #ff4411\\n      ensureOnCanvas: false\\n   }\\n\\n   shape r.arrowHead = Line {\\n      start: b - 6.5*u\\n      end: b\\n      strokeColor: #ff4411\\n      strokeWidth: Global.walkStrokeWidth\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5\\n      ensureOnCanvas: false\\n   }\\n\\n   shape r.icon = Group {\\n      shapes: [ r.taperedStroke, r.arrowHead ]\\n      ensureOnCanvas: false\\n      opacity: .75\\n   }\\n\\n   layer r.icon above D.geometry\\n}\\n\\n\\nforall Ray r; Point p\\nwhere p := headOf( r )\\n{\\n   override p.location = r.arrowHead.end\\n   override p.dot.fillColor = Colors.white\\n   override p.dot.strokeColor = Colors.black\\n   override p.dot.strokeWidth = Global.openDotWidth\\n   layer p.dot above r.icon\\n}\\n\\n\\n-- Labeling ------------------------------------------------\\n\\nforall Subdomain S; Domain D\\nwhere S has label {\\n   shape S.labelText = Equation {\\n      string: S.label\\n      fontSize: Global.labelSize\\n      fontFamily: Global.labelFont\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Global.subdomainLabelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   -- encourage near( S.labelText, S.ball ) in labelStage\\n   encourage norm( S.labelText.center - S.ball.center ) == S.ball.r/2 in labelStage\\n   encourage lessThan( signedDistance( D.geometry, S.labelText.center ), -2. ) in labelStage\\n}\\n\\n-- Make sure the domain's label isn't covered up by a ball.\\nforall Ball B; Domain D\\nwhere D has label {\\n   scalar padding = 10.\\n   ensure disjoint( D.labelText, B.ball, padding ) in labelStage\\n}\\n\\n-- Put all labels above all balls\\nforall Point p; Ball B\\nwhere p has label {\\n   layer p.labelText above B.ball\\n}\\n\\n-- Put all labels above all dots and\\n-- encourage labels not to overlap\\nforall Point p; Point q\\nwhere p has label; q has label {\\n   layer p.labelText above q.dot\\n   layer q.labelText above p.dot\\n\\n   vec2 px = p.location\\n   vec2 qx = q.location\\n   vec2 pc = p.labelText.center\\n   vec2 qc = q.labelText.center\\n   encourage 10000./norm(pc - qc) == 0. in labelStage\\n}\\n\\nforall Point p; Point q\\nwhere p has label {\\n   layer p.labelText above q.dot\\n}\\n\\nforall Point p; Point q\\nwhere p has label; isSourceSample(q) {\\n   vec2 pc = p.labelText.center\\n   vec2 qx = q.location\\n   encourage 1000./norm(pc - qx) == 0. in labelStage\\n}\\n\\nforall Point p; Domain D\\nwhere p has label; hasMixedBoundaryConditions(D) {\\n   layer p.labelText above D.dirichletBoundary\\n}\\n\\n-- Make sure domain label doesn't overlap stars\\nforall Subdomain S; Domain D\\nwhere D has label {\\n   constraint S.avoidDomainLabel = ensure disjoint( D.labelText, S.ball ) in labelStage\\n}\\n\\n-- Make sure subdomain labels don't overlap points or their labels\\nforall Subdomain S; Point p\\nwhere S has label {\\n   ensure disjoint( S.labelText, p.dot, Global.labelPadding ) in labelStage\\n}\\nforall Subdomain S; Point p\\nwhere S has label; p has label {\\n   ensure disjoint( S.labelText, p.labelText, Global.labelPadding ) in labelStage\\n}\\n\\n\\n-- Legend ---------------------------------------\\n\\nforall Domain D\\nwhere hasLegend(D) {\\n   shape D.legendBox = Rectangle {\\n      center: ( ? in legendStage, ? in legendStage )\\n      width: ? in legendStage\\n      height: ? in legendStage\\n      fillColor: #fff\\n      strokeColor: #000\\n      strokeWidth: 1\\n   }\\n   encourage D.legendBox.width == 0 in legendStage\\n   encourage D.legendBox.height == 0 in legendStage\\n}\\n\\nforall Domain D\\nwhere hasLegend(D); hasMixedBoundaryConditions(D) {\\n\\n   scalar itemSpacing = 1.5 * Global.labelHeight\\n   scalar segmentWidth = 1 * itemSpacing\\n   scalar textSpacing = 2.5*Global.labelHeight\\n   scalar padding = 8\\n\\n   vec2 x0 = ( ? in legendStage, ? in legendStage )\\n   encourage norm(x0-(canvas.width,-canvas.height)) == 0 in legendStage\\n\\n   shape dirichletLine = Line {\\n      start: x0\\n      end: x0 + (segmentWidth,0)\\n      fill: \\\"none\\\"\\n      strokeWidth: Global.dirichletStrokeWidth\\n      strokeColor: #000\\n      style: \\\"dashed\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   shape neumannLine = Line {\\n      start: x0 + (0,-itemSpacing)\\n      end: x0 + (segmentWidth,-itemSpacing)\\n      fill: \\\"none\\\"\\n      strokeWidth: Global.neumannStrokeWidth\\n      strokeColor: #000\\n      style: \\\"dashed\\\"\\n      strokeDasharray: \\\"2,2\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   shape dirichletLegend = Text {\\n      center: dirichletLine.end + (textSpacing,0)\\n      string: \\\"Dirichlet\\\"\\n      fontFamily: Global.labelFont\\n      fontSize: Global.labelSize\\n      fillColor: Global.labelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   shape neumannLegend = Text {\\n      center: neumannLine.end + (textSpacing,0)\\n      string: \\\"Neumann\\\"\\n      fontFamily: Global.labelFont\\n      fontSize: Global.labelSize\\n      fillColor: Global.labelColor\\n      ensureOnCanvas: false\\n   }\\n\\n   ensure contains( D.legendBox, dirichletLegend, padding ) in legendStage\\n   ensure contains( D.legendBox, dirichletLine, padding ) in legendStage\\n   ensure contains( D.legendBox, neumannLegend, padding ) in legendStage\\n   ensure contains( D.legendBox, neumannLine, padding ) in legendStage\\n\\n   layer D.legendBox below dirichletLegend\\n   layer D.legendBox below dirichletLine \\n   layer D.legendBox below neumannLegend\\n   layer D.legendBox below neumannLine\\n}\\n\\n\\n-- WalkOnStars.style\\n\\n-- WalkOnStars {\\n--    -- Make the image wider to accommodate a legend\\n--    override canvas.width = 333.33\\n-- }\\n-- \\n-- -- Offset the domain so that it's not covered up\\n-- -- too much by the legend\\n-- forall Domain D\\n-- where hasLegend(D)\\n-- {\\n--    override D.offset = (-50,0)\\n-- }\\n-- \\n-- -- Place the starting point\\n-- forall Point `x0` {\\n--    override `x0`.location = (-85,30)\\n-- }\\n\\n-- walk-on-spheres-no-subdomains.style -----------\\n\\n-- -- hide subdomains\\n-- forall Ball B; Point p\\n-- where B := ballAround(p) {\\n--    override B.ball.visibility = \\\"hidden\\\"\\n-- }\\n-- forall Star St; Point p\\n-- where St := starAround(p) {\\n--    override St.ball.visibility = \\\"hidden\\\"\\n-- }\\n-- \\n-- -- hide points sampled from subdomains\\n-- forall Point p; Ball B\\n-- where p := sampleBoundary( B ) {\\n--    override p.dot.visibility = \\\"hidden\\\"\\n-- }\\n-- forall Point p; Star St\\n-- where p := sampleBoundary( St ) {\\n--    override p.dot.visibility = \\\"hidden\\\"\\n-- }\\n-- \\n-- -- make trajectories more transparent\\n-- noSubdomains {\\n--    override Global.walkColor = #1b1f8a30\\n-- }\\n-- \\n-- -- don't worry about domain label avoiding subdomains, since\\n-- -- there will be many hidden subdomains; instead, make sure\\n-- -- the label avoids the walk lines\\n-- forall Subdomain S; Domain D\\n-- where D has label {\\n--    delete S.avoidDomainLabel\\n-- }\\n-- forall Point p; Subdomain S; Domain D\\n-- where p := sampleBoundary( S ) {\\n--    ensure disjoint( D.labelText, p.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n-- forall NestedPoint p; Subdomain S; Domain D\\n-- where p := sampleBoundaryNested( S ) {\\n--    ensure disjoint( D.labelText, p.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n-- forall Point q; Point p; Domain D\\n-- where q := closestBoundaryPoint( D, p ) {\\n--    ensure disjoint( D.labelText, q.walkLine, Global.labelPadding ) in labelStage\\n-- }\\n\\n-- StarShapedRadii.style ------------------------\\n\\n-- -- Widgets to draw the smallest ball touching the Dirichlet boundary,\\n-- -- and the smallest ball toughing the Neumann silhouette.\\n-- forall Star St; Point p; Domain D\\n-- where St := starAround(p) {\\n-- \\n--    vec2 c = p.location\\n--    vec2 yDirichlet = closestPoint( D.dirichletBoundary, c )\\n--    vec2 yNeumann = closestSilhouettePoint( D.neumannBoundary, c )\\n-- \\n--    shape St.dirichletBall = Circle {\\n--       center: c\\n--       r: St.dDirichlet\\n--       fillColor: none()\\n--       strokeColor: #ff6666\\n--       strokeWidth: 1.5 * Global.sphereStrokeWidth\\n--       ensureOnCanvas: false\\n--    }\\n-- \\n--    scalar thetaD = 0\\n--    vec2 x0D = c\\n--    vec2 x1D = c + St.dDirichlet * (cos(thetaD),sin(thetaD))\\n--    vec2 mD = (x0D + x1D)/2\\n--    vec2 nD = rot90(unit(x1D - x0D))\\n--    shape St.dirichletLine = Line {\\n--       start: x0D\\n--       end: x1D\\n--       strokeColor: St.dirichletBall.strokeColor\\n--       strokeWidth: St.dirichletBall.strokeWidth\\n--       fill: \\\"none\\\"\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.dirichletLabel = Equation {\\n--       center: mD + nD * Global.labelHeight * .75\\n--       string: \\\"d_{\\\\text{Dirichlet}}\\\"\\n--       texContourColor: \\\"white\\\"\\n--       fillColor: St.dirichletBall.strokeColor\\n--       ensureOnCanvas: false\\n--       fontFamily: Global.labelFont\\n--       fontSize: Global.labelSize\\n--       -- rotation: toDegrees(-thetaD)\\n--    }\\n--    shape St.dirichletPoint = Circle {\\n--       center: yDirichlet\\n--       r: Global.dotSize\\n--       fillColor : Colors.white\\n--       strokeColor : St.dirichletBall.strokeColor\\n--       strokeWidth : Global.openDotWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.closestDirichlet = Group {\\n--       shapes: [ St.dirichletBall, St.dirichletLine, St.dirichletPoint ]\\n--       ensureOnCanvas: false\\n--    }\\n--    layer p.dot above St.closestDirichlet\\n--    layer St.closestDirichlet above St.ball\\n--    layer St.closestDirichlet above D.neumannBoundary\\n--    layer St.dirichletPoint above St.dirichletBall\\n-- \\n--    shape St.neumannBall = Circle {\\n--       center: c\\n--       r: St.dNeumann\\n--       fillColor: none()\\n--       strokeColor: #6666ff\\n--       strokeWidth: 1.5 * Global.sphereStrokeWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    scalar thetaN = MathPI()\\n--    vec2 x0N = c\\n--    vec2 x1N = c + St.dNeumann * (cos(thetaN),sin(thetaN))\\n--    vec2 mN = (x0N + x1N)/2\\n--    vec2 nN = rot90(unit(x1N - x0N))\\n--    shape St.neumannLine = Line {\\n--       start: x0N\\n--       end: x1N\\n--       strokeColor: St.neumannBall.strokeColor\\n--       strokeWidth: St.neumannBall.strokeWidth\\n--       fill: \\\"none\\\"\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.neumannLabel = Equation {\\n--       center: mN - nN * Global.labelHeight * .75\\n--       string: \\\"d_{\\\\text{silhouette}}\\\"\\n--       texContourColor: \\\"white\\\"\\n--       fillColor: St.neumannBall.strokeColor\\n--       ensureOnCanvas: false\\n--       fontFamily: Global.labelFont\\n--       fontSize: Global.labelSize\\n--       -- rotation: toDegrees(-thetaN)\\n--    }\\n--    shape St.neumannPoint = Circle {\\n--       center: yNeumann\\n--       r: Global.dotSize\\n--       fillColor : Colors.white\\n--       strokeColor : St.neumannBall.strokeColor\\n--       strokeWidth : Global.openDotWidth\\n--       ensureOnCanvas: false\\n--    }\\n--    shape St.closestSilhouette = Group {\\n--       shapes: [ St.neumannBall, St.neumannLine, St.neumannPoint ]\\n--       ensureOnCanvas: false\\n--    }\\n--    layer p.dot above St.closestSilhouette\\n--    layer St.neumannPoint above St.neumannBall\\n--    layer St.closestSilhouette above St.ball\\n--    layer St.closestSilhouette above D.neumannBoundary\\n-- \\n--    layer St.neumannLabel above St.closestSilhouette\\n--    layer St.neumannLabel above St.closestDirichlet\\n--    layer St.dirichletLabel above St.closestSilhouette\\n--    layer St.dirichletLabel above St.closestDirichlet\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where p has label; St := starAround(p) {\\n--    ensure disjoint( p.labelText, St.neumannLabel ) in labelStage\\n--    ensure disjoint( p.labelText, St.dirichletLabel ) in labelStage\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where D has label; St := starAround(p) {\\n--    ensure disjoint( D.labelText, St.neumannBall ) in labelStage\\n--    ensure disjoint( D.labelText, St.dirichletBall ) in labelStage\\n-- }\\n-- \\n-- forall Star St; Point p; Domain D\\n-- where St has label; St := starAround(p) {\\n--    ensure disjoint( St.labelText, St.neumannLabel ) in labelStage\\n--    ensure disjoint( St.labelText, St.dirichletLabel ) in labelStage\\n-- }\\n\\n-- StarShapedRegion.style ------------------------\\n\\n-- -- draw uniformly-spaced rays to the boundary of the star-shaped region\\n-- forall Ray r; Point p; Star St; Domain D\\n-- where r := toBoundary(p,St); St := starAround(p) {\\n-- \\n--    override r.x = St.ball.center\\n--    override r.theta = 2*MathPI() * (match_id - 1)/match_total\\n--    \\n--    scalar dBall  = rayIntersectDistance( St.ball, r.x, r.v )\\n--    scalar dDomain  = rayIntersectDistance( D.neumannBoundary, r.x, r.v )\\n--    scalar R = min( dBall, dDomain )\\n--    override r.L = R\\n-- \\n--    override r.icon.ensureOnCanvas = false\\n-- \\n--    layer r.icon above St.ball\\n--    layer p.dot above r.icon\\n-- }\\n\\n-- alternate-domain.style ------------------------\\n\\n-- forall Domain D {\\n--    vec2 D.q1 = ((.92,.84) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q2 = ((.84,.88) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q3 = ((.55,.60) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q4 = ((.68,.96) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q5 = ((.59,1.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q6 = ((.33,.90) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q7 = ((.41,.58) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q8  = ((.16,.77) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q9  = ((0.0,.49) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q10 = ((.03,.15) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q11 = ((.43,0.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q12 = ((.32,.32) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q13 = ((.48,.36) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q14 = ((.46,.06) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q15 = ((.76,0.0) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q16 = ((1.0,.27) - (0.5,0.5)) * D.scale + D.offset\\n--    vec2 D.q17 = ((.77,.43) - (0.5,0.5)) * D.scale + D.offset\\n-- \\n--    -- domain boundary\\n--    override D.geometry.points = ( D.q1, D.q2, D.q3, D.q4, D.q5, D.q6, D.q7, D.q8, D.q9, D.q10, D.q11, D.q12, D.q13, D.q14, D.q15, D.q16, D.q17 )\\n-- \\n--    -- Dirichlet boundary\\n--    override D.poly0.points = ( D.q8, D.q9, D.q10, D.q11 )\\n-- \\n--    -- Neumann boundary\\n--    override D.poly1.points = ( D.q1, D.q2, D.q3, D.q4, D.q5, D.q6, D.q7, D.q8 )\\n-- \\n--    -- Dirichlet boundary\\n--    override D.poly2.points = ( D.q16, D.q17, D.q1 )\\n-- \\n--    -- Neumann boundary\\n--    override D.poly3.points = ( D.q11, D.q12, D.q13, D.q14, D.q15, D.q16 )\\n-- }\\n-- \\n-- forall Point `x` {\\n--    override `x`.location = (0,0)\\n-- }\\n\\n-- WalkOnSpheresTrajectories.style -----------\\n\\n-- forall Point `x0` {\\n--    override `x0`.location = (0,0)\\n-- }\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.style.js.map","export default \"type Domain -- a region in ℝⁿ\\npredicate hasMixedBoundaryConditions( Domain D )\\npredicate hasLegend( Domain D )\\n\\ntype Point\\npredicate isSourceSample( Point p )\\nconstructor closestBoundaryPoint( Domain D, Point p ) -> Point q\\n\\ntype Subdomain\\ntype Ball <: Subdomain\\ntype Star <: Subdomain\\nconstructor sampleBoundary( Subdomain S ) -> Point p\\nconstructor sampleInterior( Subdomain S ) -> Point p\\n\\nconstructor ballAround( Point p ) -> Ball\\nconstructor starAround( Point p ) -> Star\\npredicate isOffCenter( Ball B ) -- is not centered around p\\n\\ntype NestedPoint\\nconstructor startWalkFrom( Subdomain S ) -> NestedPoint p\\nconstructor nestedBallAround( NestedPoint p ) -> Ball\\nconstructor sampleBoundaryNested( Subdomain S ) -> NestedPoint p\\n\\ntype Ray\\nconstructor toBoundary( Point p, Subdomain S ) -> Ray\\nconstructor headOf( Ray r ) -> Point\\n\\n\";\n//# sourceMappingURL=walk-on-spheres.domain.js.map"],"names":["resolver","makeResolver","style0","domain"],"mappings":"2CACY,MAACA,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}