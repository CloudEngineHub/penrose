{"version":3,"file":"two-triangles.trio-0bd4a48e.js","sources":["../../../examples/dist/triangle-mesh-3d/two-triangles.substance.js","../../../examples/dist/triangle-mesh-3d/triangle-mesh-3d.style.js","../../../examples/dist/triangle-mesh-3d/triangle-mesh-3d.domain.js","../../../examples/dist/triangle-mesh-3d/two-triangles.trio.js"],"sourcesContent":["export default \"Triangle s, t\\n\\nLabel s $\\\\mathbf{f}$\\nLabel t $\\\\widetilde{\\\\mathbf{f}}$\\n\";\n//# sourceMappingURL=two-triangles.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"triangle-mesh-3d\");\nexport default \"canvas {\\n   width = 200\\n   height = 200\\n}\\n\\nglobal {\\n\\n   -- Ground plane coordinates in 3D\\n   scalar planeSize = 50 -- plane size\\n   scalar planeHeight = -40 -- plane height\\n\\n   -- Use a simple pinhole camera model, where the\\n   -- only camera parameter is the distance along Z\\n   scalar cZ = -160 -- camera z coordinate\\n\\n   -- Corner coordinates of the global ground plane\\n   vec3 q00 = ( -planeSize, planeHeight, -planeSize )\\n   vec3 q10 = (  planeSize, planeHeight, -planeSize )\\n   vec3 q01 = ( -planeSize, planeHeight,  planeSize )\\n   vec3 q11 = (  planeSize, planeHeight,  planeSize )\\n\\n   -- Apply a random rotation to the ground plane\\n   -- (Note that we could also apply this rotation to the triangle\\n   -- vertices, but since they're sampled randomly, it wouldn't\\n   -- really change the appearance of the kinds of diagrams we sample).\\n   scalar θ = ?\\n   vec3 Q00 = ( q00[0]*cos(θ) + q00[2]*sin(θ), q00[1], q00[2]*cos(θ) - q00[0]*sin(θ) )\\n   vec3 Q10 = ( q10[0]*cos(θ) + q10[2]*sin(θ), q10[1], q10[2]*cos(θ) - q10[0]*sin(θ) )\\n   vec3 Q01 = ( q01[0]*cos(θ) + q01[2]*sin(θ), q01[1], q01[2]*cos(θ) - q01[0]*sin(θ) )\\n   vec3 Q11 = ( q11[0]*cos(θ) + q11[2]*sin(θ), q11[1], q11[2]*cos(θ) - q11[0]*sin(θ) )\\n\\n   -- Perform perspective projection on 3D coordinates to get 2D coordinates p\\n   vec2 p00 = canvas.width * (Q00[0],Q00[1])/(Q00[2] - global.cZ)\\n   vec2 p10 = canvas.width * (Q10[0],Q10[1])/(Q10[2] - global.cZ)\\n   vec2 p01 = canvas.width * (Q01[0],Q01[1])/(Q01[2] - global.cZ)\\n   vec2 p11 = canvas.width * (Q11[0],Q11[1])/(Q11[2] - global.cZ)\\n\\n   -- Draw polygon using projected 2D coordinates p\\n   shape groundPlane = Polygon {\\n      points: (p00,p10,p11,p01)\\n      width: canvas.width\\n      height: canvas.height\\n      fillColor: rgba(0,0,0,0.1)\\n      strokeColor: rgba(.7,.7,.7,1)\\n      strokeWidth: .5\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Triangle t\\n{\\n   -- We'll sample the triangle vertices from a bounding box of size c\\n   scalar c = .9*min( global.planeSize, abs(global.planeHeight) )\\n\\n   -- triangle vertex coordinates in 3D\\n   vec3 qi = (?,?,?)\\n   vec3 qj = (?,?,?)\\n   vec3 qk = (?,?,?)\\n\\n   ensure -c < qi[0]\\n   ensure qi[0] < c\\n   ensure -c < qi[1]\\n   ensure qi[1] < c\\n   ensure -c < qi[2]\\n   ensure qi[2] < c\\n\\n   ensure -c < qj[0]\\n   ensure qj[0] < c\\n   ensure -c < qj[1]\\n   ensure qj[1] < c\\n   ensure -c < qj[2]\\n   ensure qj[2] < c\\n\\n   ensure -c < qk[0]\\n   ensure qk[0] < c\\n   ensure -c < qk[1]\\n   ensure qk[1] < c\\n   ensure -c < qk[2]\\n   ensure qk[2] < c\\n\\n   -- Perform perspective projection on 3D coordinates to get 2D coordinates p\\n   vec2 t.pi = canvas.width * (qi[0],qi[1])/(qi[2]-global.cZ)\\n   vec2 t.pj = canvas.width * (qj[0],qj[1])/(qj[2]-global.cZ)\\n   vec2 t.pk = canvas.width * (qk[0],qk[1])/(qk[2]-global.cZ)\\n\\n   -- Draw polygon using projected 2D coordinates p\\n   shape t.icon = Polygon {\\n      points: (t.pi,t.pj,t.pk)\\n      width: canvas.width\\n      height: canvas.height\\n      fillColor: #34379aaa\\n      strokeColor: #1b1f8a\\n      strokeWidth: .5\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure the triangle is positively oriented in the\\n   -- image plane, and has some- \\\"fat\\\" angles so that it\\n   -- doesn't degenerate\\n   vec2 eij = t.pj - t.pi\\n   vec2 ejk = t.pk - t.pj\\n   vec2 eki = t.pi - t.pk\\n   ensure cross2D( eij, -ejk ) < 0\\n   ensure angleFrom( -ejk, eij ) > toRadians( 45 )\\n   ensure angleFrom( -eki, ejk ) > toRadians( 45 )\\n   ensure angleFrom( -eij, eki ) > toRadians( 45 )\\n\\n   -- Draw triangle vertices and labels as dots and equations,\\n   -- using again the projected 2D coordinates p\\n   scalar dotSize = 1.0\\n   color dotColor = rgba(0,0,0,1)\\n   string dotFontSize = \\\"10px\\\"\\n   scalar offset = 6 -- offset of labels from vertices\\n   shape t.vertexI = Circle {\\n      center: t.pi\\n      r: dotSize\\n      fillColor: dotColor\\n   }\\n   shape t.vertexJ = Circle {\\n      center: t.pj\\n      r: dotSize\\n      fillColor: dotColor\\n   }\\n   shape t.vertexK = Circle {\\n      center: t.pk\\n      r: dotSize\\n      fillColor: dotColor\\n   }\\n   shape t.labelI = Equation {\\n       string: t.label + \\\"_i\\\"\\n       center: t.pi - offset*unit(eij-eki)\\n       fontSize: dotFontSize\\n   }\\n   shape t.labelJ = Equation {\\n       string: t.label + \\\"_j\\\"\\n       center: t.pj - offset*unit(ejk-eij)\\n       fontSize: dotFontSize\\n   }\\n   shape t.labelK = Equation {\\n       string: t.label + \\\"_k\\\"\\n       center: t.pk - offset*unit(eki-ejk)\\n       fontSize: dotFontSize\\n   }\\n\\n   -- Finally, draw a shadow of the triangle on the global ground plane\\n   -- by just replacing the y-coordinate with the height of the ground plane\\n   scalar h = global.planeHeight\\n   vec2 ri = (qi[0],h)\\n   vec2 rj = (qj[0],h)\\n   vec2 rk = (qk[0],h)\\n\\n   -- Perform perspective projection on 3D coordinates r to get 2D coordinates s\\n   vec2 si = canvas.width * ri/(qi[2]-global.cZ)\\n   vec2 sj = canvas.width * rj/(qj[2]-global.cZ)\\n   vec2 sk = canvas.width * rk/(qk[2]-global.cZ)\\n\\n   -- Draw shadow polygon using projected 2D coordinates s\\n   shape t.shadow = Polygon {\\n      points: (si,sj,sk)\\n      width: canvas.width\\n      height: canvas.height\\n      fillColor: rgba(0,0,0,0.1)\\n      strokeColor: none()\\n      ensureOnCanvas: false\\n   }\\n\\n   -- Make sure the triangle shadow lands on the ground plane\\n   --ensure contains( global.groundPlane, t.shadow )\\n}\\n\\n-- For any pair of triangles, make sure that triangles\\n-- don't overlap, and moreover the vertices of one triangle are\\n-- far from being contained in the other triangle (which helps\\n-- to avoid overlapping labels).\\nforall Triangle s; Triangle t\\n{\\n   scalar padding = 10.0\\n\\n   -- make sure triangles don't overlap\\n   ensure disjoint( t.icon, s.icon )\\n\\n   -- make sure vertices of t are far from s\\n   ensure disjoint( t.vertexI, s.icon, padding )\\n   ensure disjoint( t.vertexJ, s.icon, padding )\\n   ensure disjoint( t.vertexK, s.icon, padding )\\n\\n   -- make sure vertices of s are far from t\\n   ensure disjoint( s.vertexI, t.icon, padding )\\n   ensure disjoint( s.vertexJ, t.icon, padding )\\n   ensure disjoint( s.vertexK, t.icon, padding )\\n}\\n\\n\";\n//# sourceMappingURL=triangle-mesh-3d.style.js.map","export default \"type Triangle\\n\";\n//# sourceMappingURL=triangle-mesh-3d.domain.js.map","import substance from \"./two-triangles.substance.js\";\nimport style0, { resolver as resolver0 } from \"./triangle-mesh-3d.style.js\";\nimport domain from \"./triangle-mesh-3d.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"LightheartedCormorant8083\"\n};\n//# sourceMappingURL=two-triangles.trio.js.map"],"names":["substance","resolver","makeResolver","style0","domain","twoTriangles_trio","resolver0"],"mappings":"wEAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,kBAAkB,EACvDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA,ECGAC,EAAA,CACX,UAAAL,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAF,EACA,UAAW,2BACf"}