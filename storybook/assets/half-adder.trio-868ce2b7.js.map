{"version":3,"file":"half-adder.trio-868ce2b7.js","sources":["../../../examples/dist/logic-circuit-domain/half-adder.substance.js","../../../examples/dist/logic-circuit-domain/distinctive-shape.style.js","../../../examples/dist/logic-circuit-domain/logic-gates.domain.js","../../../examples/dist/logic-circuit-domain/half-adder.trio.js"],"sourcesContent":["export default \"AutoLabel All\\n\\nInputNode IN1, IN2\\nOutputNode SUM, CAR\\n\\nNode XORIN1, XORIN2, XOROUT\\nXORGate XOR := MakeXORGate(XORIN1, XORIN2, XOROUT)\\n\\nNode ANDIN1, ANDIN2, ANDOUT \\nANDGate AND := MakeANDGate(ANDIN1, ANDIN2, ANDOUT)\\n\\nNode S1IN, S1OUT1, S1OUT2\\nSplitComponent S1 := MakeSplitComponent(S1IN, S1OUT1, S1OUT2)\\n\\nNode S2IN, S2OUT1, S2OUT2\\nSplitComponent S2 := MakeSplitComponent(S2IN, S2OUT1, S2OUT2)\\n\\nConnection C1 := MakeConnection(IN1, S1IN)\\nConnection C2 := MakeConnection(IN2, S2IN)\\nConnection C3 := MakeConnection(S1OUT1, XORIN1)\\nConnection C4 := MakeConnection(S2OUT1, XORIN2)\\nConnection C5 := MakeConnection(S1OUT2, ANDIN1)\\nConnection C6 := MakeConnection(S2OUT2, ANDIN2)\\nConnection C7 := MakeConnection(XOROUT, SUM)\\nConnection C8 := MakeConnection(ANDOUT, CAR)\";\n//# sourceMappingURL=half-adder.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"logic-circuit-domain\");\nexport default \"canvas {\\n    width = 800\\n    height = 700\\n}\\n\\nbackground {\\n    shape icon = Rectangle {\\n        center: (0, 0)\\n        width: canvas.width\\n        height: canvas.height\\n        fillColor: rgba(1.0, 1.0, 1.0, 1.0)\\n    }\\n}\\n\\n-- Nodes\\nforall Node x {\\n    vec2 x.center = (?, ?)\\n}\\n\\nforall InputNode x {\\n    shape x.icon = Circle {\\n        center: x.center\\n        strokeWidth : 1.0\\n        r : 6.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n\\n    shape x.symbol = Equation {\\n       string : x.label\\n       rotation : 0.0\\n       center : (x.icon.center[0] - 30.0, x.icon.center[1])\\n    }\\n\\n    x.icon above background.icon\\n    x.symbol above background.icon\\n}\\n\\nforall OutputNode x {\\n    shape x.icon = Circle {\\n        center: x.center\\n        strokeWidth : 1.0\\n        r : 6.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape x.symbol = Equation {\\n       string : x.label\\n       rotation : 0.0\\n       center : (x.icon.center[0] + 35.0, x.icon.center[1])\\n    }\\n\\n    x.icon above background.icon\\n    x.symbol above background.icon\\n}\\n\\nforall InputNode A; InputNode B {\\n    ensure equal(A.center[0], B.center[0])\\n}\\n\\nforall OutputNode A; OutputNode B {\\n    ensure equal(A.center[0], B.center[0])\\n}\\n\\n-- Gates\\n\\nforall XORGate G\\nwhere G := MakeXORGate(IN1, IN2, OUT)\\nwith Node IN1; Node IN2; Node OUT {\\n    vec2 G.center = (?, ?)\\n    scalar G.width = 100.0\\n    scalar G.height = 60.0\\n\\n    shape G.part1 = Rectangle {\\n        center : G.center\\n        width : 40.0\\n        height : 50.0\\n        strokeWidth: 1.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part2 = Circle {\\n        center : (G.part1.center[0] + 20.0, G.part1.center[1])\\n        r : 25.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part3 = Circle {\\n        center : (G.part1.center[0] + 20.0, G.part1.center[1])\\n        r : 24.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(1.0, 1.0, 1.0, 1.0)\\n    }\\n\\n    scalar G.GG = 50.0\\n    shape G.part4 = Circle {\\n        center : (G.part1.center[0] - G.GG + 3.0, G.part1.center[1])\\n        r : sqrt(25.0 * 25.0 + (G.GG - 20.0) * (G.GG  - 20.0))\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part5 = Rectangle {\\n        center : (G.part1.center[0] - G.GG - 30.0+ 3.0, G.part1.center[1])\\n        width : 2 * (G.GG - 20.0) + 60.0\\n        height : 3 * (G.GG - 20.0)\\n        strokeWidth: 0.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n    }\\n    G.part5 above G.part4\\n\\n    shape G.part6 = Circle {\\n        center : (G.part1.center[0] - G.GG  - 6.0, G.part1.center[1])\\n        r : sqrt(25.0 * 25.0 + (G.GG - 20.0) * (G.GG  - 20.0))\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part7 = Rectangle {\\n        center : (G.part1.center[0] - G.GG - 30.0 - 6.0, G.part1.center[1])\\n        width : 2 * (G.GG - 20.0) + 60.0\\n        height : 3 * (G.GG - 20.0)\\n        strokeWidth: 0.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n    }\\n    G.part4 above G.part3\\n    G.part6 above G.part5\\n    G.part7 above G.part6\\n\\n    G.part1 above G.part2\\n    G.part3 above G.part1\\n\\n    G.part1 above background.icon\\n    G.part2 above background.icon\\n    G.part3 above background.icon\\n    G.part4 above background.icon\\n    G.part5 above background.icon\\n    G.part6 above background.icon\\n    G.part7 above background.icon\\n\\n    ensure equal(vdist(IN1.center, (G.part1.center[0] - 20.0, G.part1.center[1] + 17.0)), 0.0)\\n    ensure equal(vdist(IN2.center, (G.part1.center[0] - 20.0, G.part1.center[1] - 17.0)), 0.0)\\n    ensure equal(vdist(OUT.center, (G.part1.center[0] + 45.0, G.part1.center[1])), 0.0)\\n}\\n\\nforall ANDGate G\\nwhere G := MakeANDGate(IN1, IN2, OUT)\\nwith Node IN1; Node IN2; Node OUT {\\n    vec2 G.center = (?, ?)\\n    scalar G.width = 100.0\\n    scalar G.height = 60.0\\n\\n    shape G.part1 = Rectangle {\\n        center : G.center\\n        width : 40.0\\n        height : 50.0\\n        strokeWidth: 1.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part2 = Circle {\\n        center : (G.part1.center[0] + 20.0, G.part1.center[1])\\n        r : 25.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape G.part3 = Circle {\\n        center : (G.part1.center[0] + 20.0, G.part1.center[1])\\n        r : 24.0\\n        fillColor : rgba(1.0, 1.0, 1.0, 1.0)\\n        strokeWidth : 1.0\\n        strokeColor : rgba(1.0, 1.0, 1.0, 1.0)\\n    }\\n    G.part1 above G.part2\\n    G.part3 above G.part1\\n\\n    G.part1 above background.icon\\n    G.part2 above background.icon\\n    G.part3 above background.icon\\n\\n    ensure equal(vdist(IN1.center, (G.part1.center[0] - 20.0, G.part1.center[1] + 17.0)), 0.0)\\n    ensure equal(vdist(IN2.center, (G.part1.center[0] - 20.0, G.part1.center[1] - 17.0)), 0.0)\\n    ensure equal(vdist(OUT.center, (G.part1.center[0] + 45.0, G.part1.center[1])), 0.0)\\n}\\n\\nforall SplitComponent x\\nwhere x := MakeSplitComponent(IN, OUT1, OUT2)\\nwith Node IN; Node OUT1; Node OUT2 {\\n    vec2 x.center = IN.center\\n    shape x.icon = Circle {\\n        center: x.center\\n        strokeWidth : 0.0\\n        r : 6.0\\n        fillColor : rgba(0.0, 0.0, 0.0, 1.0)\\n    }\\n    shape x.line = Line {\\n        start : OUT1.center\\n        end : OUT2.center\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n        strokeWidth: 1.0\\n    }\\n    x.icon above x.line\\n\\n    x.icon above background.icon\\n    x.line above background.icon\\n\\n    ensure equal(IN.center[0], OUT1.center[0])\\n    ensure equal(IN.center[0], OUT2.center[0])\\n    ensure lessThan(0.0, -(OUT1.center[1] - IN.center[1]) * (-IN.center[1] + OUT2.center[1]))\\n}\\n\\nforall Gate G; Gate H {\\n    ensure lessThan(0.6 * (G.height + H.height), abs(G.part1.center[1] - H.part1.center[1]))\\n    ensure lessThan(0.6 * (G.width + H.width), abs(G.part1.center[0] - H.part1.center[0]))\\n}\\n\\nforall Connection x; InputNode y {\\n    x.line1 below y.icon\\n    x.line2 below y.icon\\n    x.line3 below y.icon\\n}\\n\\nforall SplitComponent x; XORGate y {\\n    x.line above y.part7\\n}\\n\\nforall Connection x; XORGate y {\\n    x.line1 above y.part7\\n    x.line2 above y.part7\\n    x.line3 above y.part7\\n}\\n\\n-- Connections\\n\\nforall Connection C\\nwhere C := MakeConnection(A, B)\\nwith Node A; Node B {\\n    scalar C.pivot = ?\\n    shape C.line1 = Line {\\n        start : A.center\\n        end : (C.pivot, A.center[1])\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n        strokeWidth: 1.0\\n    }\\n    shape C.line2 = Line {\\n        start : (C.pivot, A.center[1])\\n        end : (C.pivot, B.center[1])\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n        strokeWidth: 1.0\\n    }\\n    shape C.line3 = Line {\\n        start : (C.pivot, B.center[1])\\n        end : B.center\\n        strokeColor : rgba(0.0, 0.0, 0.0, 1.0)\\n        strokeWidth: 1.0\\n    }\\n\\n    C.line1 above background.icon\\n    C.line2 above background.icon\\n    C.line3 above background.icon\\n\\n    encourage equal(A.center[1], B.center[1])\\n    ensure lessThan(A.center[0], B.center[0])\\n    ensure lessThan(A.center[0], C.pivot)\\n    ensure lessThan(C.pivot, B.center[0])\\n}\\n\\nforall SplitComponent x; SplitComponent y {\\n    ensure lessThan(10.0, abs(x.center[0] - y.center[0]))\\n}\";\n//# sourceMappingURL=distinctive-shape.style.js.map","export default \"-- Nodes\\n\\ntype Node\\n\\ntype InputNode <: Node\\ntype OutputNode <: Node\\n\\n-- Gates\\n\\ntype Component\\n\\ntype SplitComponent <: Component\\ntype Gate <: Component\\n\\ntype OneInputGate <: Gate\\ntype TwoInputGate <: Gate\\n\\nconstructor MakeSplitComponent(Node IN, Node OUT1, Node OUT2) -> SplitComponent\\n\\ntype Buffer <: OneInputGate\\ntype NOTGate <: OneInputGate\\n\\nconstructor MakeBuffer(Node IN, Node OUT) -> Buffer\\nconstructor MakeNOTGate(Node IN, Node OUT) -> NOTGate\\n\\ntype ORGate <: TwoInputGate\\ntype NORGate <: TwoInputGate\\ntype ANDGate <: TwoInputGate\\ntype NANDGate <: TwoInputGate\\ntype XORGate <: TwoInputGate\\ntype XNORGate <: TwoInputGate\\n\\nconstructor MakeORGate(Node IN1, Node IN2, Node OUT) -> ORGate\\nconstructor MakeNORGate(Node IN1, Node IN2, Node OUT) -> NORGate\\nconstructor MakeANDGate(Node IN1, Node IN2, Node OUT) -> ANDGate\\nconstructor MakeNANDGate(Node IN1, Node IN2, Node OUT) -> NANDGate\\nconstructor MakeXORGate(Node IN1, Node IN2, Node OUT) -> XORGate\\nconstructor MakeXNORGate(Node IN1, Node IN2, Node OUT) -> XNORGate\\n\\n-- Connections\\n\\ntype Connection\\n\\nconstructor MakeConnection(Node A, Node B) -> Connection\";\n//# sourceMappingURL=logic-gates.domain.js.map","import substance from \"./half-adder.substance.js\";\nimport style0, { resolver as resolver0 } from \"./distinctive-shape.style.js\";\nimport domain from \"./logic-gates.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"CauliflowerDeer97138\"\n};\n//# sourceMappingURL=half-adder.trio.js.map"],"names":["substance","resolver","makeResolver","style0","domain","halfAdder_trio","resolver0"],"mappings":"wEAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8CCCFC,EAAWC,EAAa,sBAAsB,EAC3DC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0DCGAC,EAAA,CACX,UAAAL,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAF,EACA,UAAW,sBACf"}