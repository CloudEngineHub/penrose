{"version":3,"file":"AbsorbingBoundary.trio-09e357d0.js","sources":["../../../examples/dist/stochastic-process/epsilon-shell/AbsorbingBoundary.substance.js","../../../examples/dist/stochastic-process/epsilon-shell/EpsilonShell.style.js","../../../examples/dist/stochastic-process/epsilon-shell/EpsilonShell.domain.js","../../../examples/dist/stochastic-process/epsilon-shell/AbsorbingBoundary.trio.js"],"sourcesContent":["export default \"Point x0, x1\\nRandomWalk A\\n\\nstartsAt( A, x1 )\\nendsAt( A, x0 )\\n\\nBoundary D := AbsorbingBoundary( x0, x1 )\\n\\nLabel D $\\\\partial \\\\Omega$\\nLabel x0 $x_k$\\nLabel x1 $\\\\overline{x}_k$\\n\";\n//# sourceMappingURL=AbsorbingBoundary.substance.js.map","import { makeResolver } from \"../../resolver.js\";\nexport const resolver = makeResolver(\"stochastic-process/epsilon-shell\");\nexport default \"canvas {\\n    width = 100\\n    height = 100\\n}\\n\\nglobal {\\n   color labelColor = #000\\n   string labelSize = \\\"9px\\\"\\n}\\n\\nforall Point p {\\n    vec2 p.x = (?,?) -- location\\n\\n    shape p.icon = Circle {\\n        center: p.x\\n        r: 1\\n        fillColor: #000\\n    }\\n}\\n\\nforall Point p\\nwhere p has label {\\n   shape p.labelText = Equation {\\n      string: p.label\\n      center: p.x + 5*circleRandom()\\n      fillColor: global.labelColor\\n      fontSize: global.labelSize\\n   }\\n}\\n\\nforall RandomWalk X {\\n    vec2 X.start = (?,?) -- start point\\n    mat2x2 A = .5*((1,0),(0,1)) -- covariance matrix\\n    vec2 omega = .2*circleRandom() -- drift\\n    X.curve = diffusionProcess(150, X.start, A, omega)\\n\\n    shape X.icon = Path {\\n        d: interpolatingSpline(\\\"open\\\", X.curve)\\n        strokeWidth: .5\\n        strokeColor: #1b1f8a66\\n        ensureOnCanvas: false\\n    }\\n}\\n\\nforall RandomWalk X; Point p\\nwhere startsAt( X, p ) {\\n    override X.start = p.x\\n}\\n\\nforall RandomWalk X; Point p\\nwhere endsAt( X, p ) {\\n    override p.x = lastPoint(X.curve)\\n}\\n\\nforall Boundary B {\\n\\n   vec2 B.x = (?,?)\\n   scalar theta = random(0,1) * MathPI()\\n   vec2 B.e1 = ( cos(theta), sin(theta) )\\n   vec2 B.e2 = (-sin(theta), cos(theta) )\\n   scalar w = 2*canvas.width\\n   scalar h = 2*canvas.width\\n\\n   vec2 B.p0 = B.x - w*B.e1\\n   vec2 B.p1 = B.x + w*B.e1\\n   vec2 B.p2 = B.x + w*B.e1 - h*B.e2\\n   vec3 B.p3 = B.x - w*B.e1 - h*B.e2\\n\\n   B.icon = Polygon{\\n      points: [ B.p0, B.p1, B.p2, B.p3 ]\\n      ensureOnCanvas: false\\n      fillColor: #0002\\n      ensureOnCanvas: false\\n   }\\n   B.boundary = Line {\\n      start: B.p0\\n      end: B.p1\\n      fillColor: none()\\n      strokeColor: #000\\n      strokeWidth: .5\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Boundary B; Point a, b, c\\nwhere B := ReflectingBoundary( a, b, c ) {\\n\\n   override B.x = b.x\\n\\n   override B.e1 = unit(c.x - a.x)\\n   vec2 ab = b.x - a.x\\n   override B.e2 = unit(ab - dot(ab, B.e1)*B.e1)\\n\\n   override B.boundary.strokeStyle = \\\"dashed\\\"\\n   override B.boundary.strokeDasharray = \\\"2 2\\\"\\n}\\n\\nforall Boundary B; Point a, b, c\\nwhere a has label; B := ReflectingBoundary( a, b, c ) {\\n   override a.labelText.center = a.x - 6*B.e2\\n}\\nforall Boundary B; Point a, b, c\\nwhere b has label; B := ReflectingBoundary( a, b, c ) {\\n   override a.labelText.center = b.x + 6*B.e2\\n}\\nforall Boundary B; Point a, b, c\\nwhere c has label; B := ReflectingBoundary( a, b, c ) {\\n   override c.labelText.center = c.x - 6*B.e2\\n}\\n\\nforall Boundary B; Point a, b\\nwhere B := AbsorbingBoundary( a, b ) {\\n\\n   override B.x = b.x\\n\\n   vec2 u1 = unit( b.x - a.x )\\n   vec2 u2 = ( -u1[1], u1[0] )\\n\\n   override B.e1 = u2\\n   override B.e2 = u1\\n\\n   scalar eps = norm( b.x - a.x )*1.1\\n   B.epsilonShell = Polygon {\\n      points: [ B.p0 - eps*B.e2, B.p1 - eps*B.e2, B.p1, B.p0 ]\\n      fillColor: #0003\\n      ensureOnCanvas: false\\n   }\\n\\n   scalar markerOffset = 20\\n   scalar markerPadding = 2\\n   scalar markerCapWidth = 5\\n   vec2 m0 = B.x - markerPadding*B.e2 - markerOffset*B.e1\\n   vec2 m1 = B.x - (eps-markerPadding)*B.e2 - markerOffset*B.e1\\n   shape epsilonMarker = Line {\\n      start: m0\\n      end: m1\\n      strokeWidth: .5\\n      strokeColor: #888\\n   }\\n   shape epsilonMarkerStart = Line {\\n      start: m0 - markerCapWidth*B.e1/2\\n      end: m0 + markerCapWidth*B.e1/2\\n      strokeWidth: epsilonMarker.strokeWidth\\n      strokeColor: epsilonMarker.strokeColor\\n   }\\n   shape epsilonMarkerEnd = Line {\\n      start: m1 - markerCapWidth*B.e1/2\\n      end: m1 + markerCapWidth*B.e1/2\\n      strokeWidth: epsilonMarker.strokeWidth\\n      strokeColor: epsilonMarker.strokeColor\\n   }\\n   shape markerGroup = Group {\\n      shapes: [ epsilonMarker, epsilonMarkerStart, epsilonMarkerEnd ]\\n   }\\n\\n   shape epsilonLabel = Equation {\\n      center: (m0+m1)/2 + 3*B.e1\\n      string: \\\"\\\\varepsilon\\\"\\n      fillColor: epsilonMarker.strokeColor\\n      fontSize: global.labelSize\\n   }\\n}\\n\\nforall Boundary B; Point a, b\\nwhere a has label; B := AbsorbingBoundary( a, b ) {\\n   override a.labelText.center = a.x - 6*B.e2\\n}\\nforall Boundary B; Point a, b\\nwhere b has label; B := AbsorbingBoundary( a, b ) {\\n   override b.labelText.center = b.x + 6*B.e2\\n}\\n\\nforall Boundary B\\nwhere B has label {\\n   shape B.labelText = Equation {\\n      string: B.label\\n      center: B.x + 8*B.e2 + 20*B.e1\\n      fillColor: global.labelColor\\n      fontSize: global.labelSize\\n   }\\n}\\n\\n\";\n//# sourceMappingURL=EpsilonShell.style.js.map","export default \"type Point\\ntype RandomWalk\\ntype Boundary\\n\\npredicate startsAt( RandomWalk X, Point p )\\npredicate endsAt( RandomWalk X, Point p )\\nconstructor ReflectingBoundary( Point a, Point b, Point c ) -> Boundary\\nconstructor AbsorbingBoundary( Point a, Point b ) -> Boundary\\n\";\n//# sourceMappingURL=EpsilonShell.domain.js.map","import substance from \"./AbsorbingBoundary.substance.js\";\nimport style0, { resolver as resolver0 } from \"./EpsilonShell.style.js\";\nimport domain from \"./EpsilonShell.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"BookstoneShrew61995\",\n    excludeWarnings: []\n};\n//# sourceMappingURL=AbsorbingBoundary.trio.js.map"],"names":["substance","resolver","makeResolver","style0","domain","AbsorbingBoundary_trio","resolver0"],"mappings":"wEAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,kCAAkC,EACvEC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECGAC,EAAA,CACX,UAAAL,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAF,EACA,UAAW,sBACX,gBAAiB,CAAE,CACvB"}