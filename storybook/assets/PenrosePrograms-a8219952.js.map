{"version":3,"file":"PenrosePrograms-a8219952.js","sources":["../../../examples/dist/linear-algebra-domain/linear-algebra-paper-simple.style.js","../../src/stories/PenrosePrograms.tsx"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"linear-algebra-domain\");\nexport default \"canvas {\\n  width = 400\\n  height = 500\\n}\\n\\nconst {\\n  scalar perpLen = 20.0\\n  -- For unit mark\\n  scalar markerPadding = 15.0\\n  scalar barSize = 5.0\\n  scalar vectorSpaceSize = 350.0\\n  scalar repelWeight = 0.7\\n  scalar arrowheadSize = 0.7\\n  scalar lineThickness = 2.\\n  string fontFamily = \\\"Palatino\\\"\\n  string fontSize = \\\"22.5px\\\"\\n}\\n\\nC {\\n  color black = rgba(0.,0.,0.,1.)\\n  color white = rgba(1., 1., 1., 1.)\\n  color lightBlue = rgba(1e-1, 0.1, 0.9, 1.0)\\n  -- Note: we don't currently support color accessors r,g,b\\n  -- darkBlue = rgba(lightBlue.r / 2., lightBlue.g / 2., lightBlue.b / 2., 0.5)\\n  color darkGray = rgba(0.4, 0.4, 0.4, 1.)\\n  color gray = rgba(0.6, 0.6, 0.6, 1.)\\n  color green = rgba(0., 0.8, 0., 1.)\\n  color none = none()\\n}\\n\\nforall VectorSpace U {\\n  scalar axisSize = const.vectorSpaceSize / 2.0 -- This should get promoted to float\\n  vec2 U.origin = (0., 0.)\\n  vec2 o = U.origin\\n  color U.axisColor = C.gray\\n\\n  shape U.background = Rectangle {\\n    center : U.origin\\n    width : const.vectorSpaceSize\\n    height : const.vectorSpaceSize\\n    fillColor : rgba(.95,.95,.95,1.)\\n    strokeColor : C.none\\n  }\\n\\n  shape U.xAxis = Line {\\n    start : (o[0] - 1.1*axisSize, o[1]) -- TODO This gets mis-parsed as a matrix access\\n    end : (o[0] + 1.1*axisSize, o[1])\\n    strokeWidth : const.lineThickness\\n    style : \\\"solid\\\"\\n    strokeColor : U.axisColor\\n\\n  }\\n\\n  shape U.yAxis = Line {\\n    start : (o[0], o[1] - 1.1*axisSize)\\n    end : (o[0], o[1] + 1.1*axisSize)\\n    strokeWidth : const.lineThickness\\n    style : \\\"solid\\\"\\n    strokeColor : U.axisColor\\n  }\\n\\n  shape U.text = Text {\\n    fontSize : const.fontSize\\n    fontFamily : const.fontFamily\\n    fontStyle : \\\"italic\\\"\\n    string : U.label\\n    center : (U.origin[0] + .8*axisSize, U.origin[1] + .8*axisSize)\\n    fillColor : U.axisColor\\n  }\\n\\n  layer U.xAxis above U.yAxis\\n  layer U.background below U.yAxis\\n  layer U.text above U.background\\n  layer U.text below U.yAxis\\n}\\n\\nforall Vector u; VectorSpace U\\nwhere In(u,U) {\\n\\n  shape u.arrow = Line {\\n    start : U.origin\\n    end : (?, ?)\\n    strokeWidth : 3.0\\n    strokeColor : C.lightBlue\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n  }\\n\\n  shape u.text = Text {\\n    center: u.arrow.end * 1.15\\n    fontSize: const.fontSize\\n    fontFamily: const.fontFamily\\n    fontWeight: \\\"bold\\\"\\n    string: u.label\\n    fillColor: u.arrow.strokeColor\\n  }\\n\\n  shape u.stroke = Text {\\n    center: u.text.center\\n    fontSize: u.text.fontSize\\n    fontFamily: u.text.fontFamily\\n    fontWeight: \\\"bold\\\"\\n    string: u.label\\n    fillColor: C.white\\n    strokeColor: C.white\\n    strokeWidth: 8.\\n  }\\n\\n  vec2 u.vector = u.arrow.end - u.arrow.start -- Vector sugar for subtraction\\n\\n  ensure contains(U.background, u.arrow)\\n  ensure contains(U.background, u.text)\\n  ensure minSize(u.arrow)\\n\\n  layer u.text above u.stroke\\n  layer u.stroke above u.arrow\\n  layer u.arrow above U.xAxis\\n  layer u.text above U.xAxis\\n  layer u.text above U.yAxis\\n  layer u.text above U.xAxis\\n}\\n\\n-- draw all labels above all arrows, to improve legibility\\nforall Vector u; Vector v {\\n  layer u.stroke above v.arrow\\n  layer v.stroke above u.arrow\\n}\\n\\nforall Vector u; Vector v\\nwith VectorSpace U\\nwhere Orthogonal(u, v); In(u, U); In(v, U) {\\n  startR = u.arrow.start\\n  endR = u.arrow.end\\n  startL = v.arrow.start\\n  endL = v.arrow.end\\n  dirR = normalize(endR - startR)  \\n  dirL = normalize(endL - startL)\\n  ptL = startR + const.perpLen * dirL\\n  ptR = startR + const.perpLen * dirR\\n  ptLR = ptL + const.perpLen * dirR\\n  pts = [startR, ptL, ptLR, ptR]\\n\\n  -- Draw perpendicular mark -- NOTE: local shapes should still be drawn\\n  perpMark = Path {\\n    d : pathFromPoints(\\\"closed\\\", pts)\\n    strokeWidth : 2.0\\n    strokeColor : C.black\\n    fillColor : C.white\\n  }\\n\\n  ensure equal(dot(u.vector, v.vector), 0.0) \\n\\n  layer v.arrow above perpMark\\n  layer u.arrow above perpMark\\n  layer perpMark above U.xAxis\\n\\n  shape labelText = Text {\\n    string: \\\"orthogonal\\\"\\n    center: (0.,-.6*U.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\nforall Vector v\\nwith VectorSpace U; Vector w\\nwhere In(v, U); Unit(v); Orthogonal(v, w) {\\n  -- Usually, the unit vector shouldn't need to know about orthogonal vectors\\n  -- but we need to position the unit mark so it doesn't overlap with the \\\"inside\\\" of the two vectors\\n\\n  strokeWidth = 2.0\\n  padding = 15.0 \\n\\n  -- The start and end of the body of the unit marker line\\n  -- NOTE: We need to have lists of vectors\\n  dir = normalize(w.arrow.end - w.arrow.start)\\n  normal = -dir\\n  markStart = v.arrow.start + padding * normal\\n  markEnd = v.arrow.end + padding * normal\\n  v.markerLine = [markStart, markEnd]\\n\\n  v.unitMarkerLine = Path {\\n    d : pathFromPoints(\\\"open\\\", v.markerLine)\\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  -- Could use normal instead, just doing this to demonstrate how to use matrices\\n  mat2x2 rot90CW = ((0., 1.), (-1., 0.))\\n  vec2 markNormal = mul(rot90CW, normalize(v.arrow.end - v.arrow.start)) \\n  scalar c = const.barSize\\n  vec2 halfvec = c * markNormal\\n\\n  v.unitMarkerEnd1 = Path {\\n    d : pathFromPoints(\\\"open\\\", [markStart - halfvec, markStart + halfvec]) \\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  v.unitMarkerEnd2 = Path {\\n    d : pathFromPoints(\\\"open\\\", [markEnd - halfvec, markEnd + halfvec])\\n    strokeColor : C.black\\n    fillColor : C.none\\n  }\\n\\n  vec2 midpointLoc = (v.markerLine[0] + v.markerLine[1]) / 2.\\n  vec2 labelPos = midpointLoc + const.markerPadding * normal\\n\\n  v.unitMarkerText = Equation {\\n    fontSize : const.fontSize\\n    string : \\\"1\\\"\\n    center : labelPos\\n    fillColor : C.black\\n  }\\n\\n  layer v.unitMarkerLine above U.xAxis\\n  layer v.unitMarkerLine above U.yAxis\\n}\\n\\n-- If two vectors are linearly dependent, make\\n-- sure they are parallel by minimizing the\\n-- signed are of the parallelogram with sides u,v\\nforall Vector u; Vector v\\nwhere Dependent(u,v) {\\n  vec2 x = u.arrow.end\\n  vec2 y = v.arrow.end\\n  scalar A = cross2D(x,y)\\n  ensure equal( A, 0. )\\n\\n  shape labelText = Text {\\n    string: \\\"linearly dependent\\\"\\n    center: (0.,-.6*V.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\n-- If two vectors are linearly independent, make\\n-- sure they're not parallel\\nforall Vector u; Vector v; VectorSpace V\\nwhere Independent(u, v); In(v,V) {\\n  vec2 x = u.arrow.end\\n  vec2 y = v.arrow.end\\n  ensure inRange( angleBetween(x,y), .25*MathPI(), .75*MathPI() )\\n\\n  shape labelText = Text {\\n    string: \\\"linearly independent\\\"\\n    center: (0.,-.6*V.background.width)\\n    fontFamily: const.fontFamily\\n    fontSize: \\\"18px\\\"\\n    fontWeight: \\\"bold\\\"\\n    fillColor: C.black\\n  }\\n}\\n\\nforall Vector `u` {\\n  override `u`.arrow.strokeColor = C.green\\n}\\n\\nforall Vector `x2` {\\n  override `x2`.arrow.strokeColor = C.green\\n}\\n\\n\\n\\n\";\n//# sourceMappingURL=linear-algebra-paper-simple.style.js.map","import exteriorAlgebraDomain from \"@penrose/examples/dist/exterior-algebra/exterior-algebra.domain\";\nimport exteriorAlgebraStyle from \"@penrose/examples/dist/exterior-algebra/exterior-algebra.style\";\nimport vectorWedgeSubstance from \"@penrose/examples/dist/exterior-algebra/vector-wedge.substance\";\nimport linearAlgebraStyle from \"@penrose/examples/dist/linear-algebra-domain/linear-algebra-paper-simple.style\";\nimport linearAlgebraDomain from \"@penrose/examples/dist/linear-algebra-domain/linear-algebra.domain\";\nimport twoVectorsPerpSubstance from \"@penrose/examples/dist/linear-algebra-domain/twoVectorsPerp-unsugared.substance\";\nimport continuousMapStyle from \"@penrose/examples/dist/set-theory-domain/continuousmap.style\";\nimport continuousMapSubstance from \"@penrose/examples/dist/set-theory-domain/continuousmap.substance\";\nimport functionsDomain from \"@penrose/examples/dist/set-theory-domain/functions.domain\";\n\nexport const error = {\n  domain: `typeppp Set`,\n  substancce: `Set A + B`,\n  style: `\n  Set a {\n\n  }\n  `,\n};\nexport const oneSet = {\n  domain: `\ntype Set\n`,\n  substance: `\nSet A\nAutoLabel All\n`,\n  style: `\ncanvas {\n  width = 500\n  height = 500\n}\nforall Set X {\n  X.shape = Circle { strokeWidth : 0 }\n  X.text  = Equation { string: X.label }\n  ensure contains(X.shape, X.text)\n  ensure maxSize(X.shape, canvas.width / 2)\n}\n`,\n  variation: \"\",\n};\n\nexport const continuousMap = {\n  substance: continuousMapSubstance,\n  style: continuousMapStyle,\n  domain: functionsDomain,\n  variation: \"\",\n};\n\nexport const vectorWedge = {\n  variation: \"ArtemisCrane740\",\n  domain: exteriorAlgebraDomain,\n  substance: vectorWedgeSubstance,\n  style: exteriorAlgebraStyle,\n};\n\nexport const vectorsPerp = {\n  variation: \"MyrtleApe55311\",\n  domain: linearAlgebraDomain,\n  substance: twoVectorsPerpSubstance,\n  style: linearAlgebraStyle,\n};\n"],"names":["linearAlgebraStyle","error","domain","substancce","style","oneSet","substance","variation","continuousMap","continuousMapSubstance","continuousMapStyle","functionsDomain","vectorWedge","exteriorAlgebraDomain","vectorWedgeSubstance","exteriorAlgebraStyle","vectorsPerp","linearAlgebraDomain","twoVectorsPerpSubstance"],"mappings":"oNAEA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECQFC,EAAQ,CACnBC,OAAS,cACTC,WAAa,YACbC,MAAQ;AAAA;AAAA;AAAA;AAAA,GAKV,EACaC,EAAS,CACpBH,OAAS;AAAA;AAAA,EAGTI,UAAY;AAAA;AAAA;AAAA,EAIZF,MAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYRG,UAAW,EACb,EAEaC,EAAgB,CAC3BF,UAAWG,EACXL,MAAOM,EACPR,OAAQS,EACRJ,UAAW,EACb,EAEaK,EAAc,CACzBL,UAAW,kBACXL,OAAQW,EACRP,UAAWQ,EACXV,MAAOW,CACT,EAEaC,EAAc,CACzBT,UAAW,iBACXL,OAAQe,EACRX,UAAWY,EACXd,MAAOJ,CACT"}