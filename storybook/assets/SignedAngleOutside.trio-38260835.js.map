{"version":3,"file":"SignedAngleOutside.trio-38260835.js","sources":["../../../examples/dist/walk-on-spheres/SignedAngle.substance.js","../../../examples/dist/walk-on-spheres/geometry-2d.style.js","../../../examples/dist/walk-on-spheres/subtended-angles.style.js","../../../examples/dist/walk-on-spheres/SignedAngle.style.js","../../../examples/dist/walk-on-spheres/SignedAngleOutside.style.js","../../../examples/dist/walk-on-spheres/geometry-2d.domain.js","../../../examples/dist/walk-on-spheres/SignedAngleOutside.trio.js"],"sourcesContent":["export default \"-- outer part of \\\"A\\\"\\nPoint a1, a2, a3, a4, a5, a6, a7, a8\\nLet a12 := Segment( a1, a2 )\\nLet a23 := Segment( a2, a3 )\\nLet a34 := Segment( a3, a4 )\\nLet a45 := Segment( a4, a5 )\\nLet a56 := Segment( a5, a6 )\\nLet a67 := Segment( a6, a7 )\\nLet a78 := Segment( a7, a8 )\\nLet a81 := Segment( a8, a1 )\\n\\n-- inner hole of \\\"A\\\"\\nPoint b1, b2, b3\\nLet b12 := Segment( b1, b2 )\\nLet b23 := Segment( b2, b3 )\\nLet b31 := Segment( b3, b1 )\\n\\n-- all of these segments are oriented\\nIsOriented( a12 )\\nIsOriented( a23 )\\nIsOriented( a34 )\\nIsOriented( a45 )\\nIsOriented( a56 )\\nIsOriented( a67 )\\nIsOriented( a78 )\\nIsOriented( a81 )\\nIsOriented( b12 )\\nIsOriented( b23 )\\nIsOriented( b31 )\\n\\n-- point at which we want to measure the winding number\\nPoint x\\nLabel x $x$\\n\\n-- oriented angle of each segment relative to x\\nAngle alpha12 := InteriorAngle(x,a1,a2)\\nAngle alpha23 := InteriorAngle(x,a2,a3)\\nAngle alpha34 := InteriorAngle(x,a3,a4)\\nAngle alpha45 := InteriorAngle(x,a4,a5)\\nAngle alpha56 := InteriorAngle(x,a5,a6)\\nAngle alpha67 := InteriorAngle(x,a6,a7)\\nAngle alpha78 := InteriorAngle(x,a7,a8)\\nAngle alpha81 := InteriorAngle(x,a8,a1)\\nAngle beta12 := InteriorAngle(x,b1,b2)\\nAngle beta23 := InteriorAngle(x,b2,b3)\\nAngle beta31 := InteriorAngle(x,b3,b1)\\nIsOriented( alpha12 )\\nIsOriented( alpha23 )\\nIsOriented( alpha34 )\\nIsOriented( alpha45 )\\nIsOriented( alpha56 )\\nIsOriented( alpha67 )\\nIsOriented( alpha78 )\\nIsOriented( alpha81 )\\nIsOriented( beta12 )\\nIsOriented( beta23 )\\nIsOriented( beta31 )\\n\\n\";\n//# sourceMappingURL=SignedAngle.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"-- \\n\\nlayout = [ shapeStage, labelStage ]\\n\\n-- diagram dimensions (in px; multiply by 96/72 to convert to pt)\\ncanvas {\\n   width = 306.66 -- ==230\\n   height = 200.00 -- ==150\\n}\\n\\n--------------------------------------------------\\n-- Global constants ------------------------------\\n--------------------------------------------------\\n\\ncolors {\\n   color black = rgba(0,0,0,1)\\n   color white = rgba(1,1,1,1)\\n   color lightGray = rgba(.8,.8,.8,1)\\n   color clearGray = rgba(0,0,0,.2)\\n   color darkBlue = #1b1f8a\\n}\\n\\nglobal {\\n   scalar toPt = 96/72 -- constant for converting sizes from pt to px\\n\\n   -- dot style\\n   color dotColor = colors.black\\n   scalar dotRadius = toPt * 1.75\\n   scalar dotStroke = toPt * .75\\n\\n   -- line and arrow style\\n   scalar lineWidth = toPt * 1\\n   scalar arrowLength = 25.0\\n\\n   -- label style\\n   string labelStyle = \\\"italic\\\"\\n   string labelFamily = \\\"Linux Libertine\\\"\\n   color labelColor = #000\\n   string labelSize = \\\"13.3333px\\\" -- equivalent to 10pt (multiply by 96/72)\\n   scalar labelHeight = 10\\n   scalar labelDistance = 8.0\\n\\n   -- layout parameters\\n   scalar padding = 2.0 -- amount of padding to prevent overlap\\n}\\n\\n--------------------------------------------------\\n-- Points ----------------------------------------\\n--------------------------------------------------\\n\\nforall Point p {\\n\\n   -- location\\n   scalar p.x0 = ? in shapeStage\\n   scalar p.x1 = ? in shapeStage\\n   p.x = (p.x0,p.x1)\\n\\n   shape p.icon = Circle {\\n      fillColor: global.dotColor\\n      r: global.dotRadius\\n      center: p.x\\n   }\\n}\\n\\nforall Point p\\nwhere p has label {\\n\\n   scalar theta = ? in labelStage\\n   scalar r = global.labelDistance\\n\\n   p.labelText = Equation {\\n      center: p.x + r*(cos(theta),sin(theta))\\n      string: p.label\\n      fontSize: global.labelSize\\n      --fontStyle: global.labelStyle\\n      --fontFamily: global.labelFamily\\n      fillColor: global.labelColor\\n   }\\n   layer p.labelText above p.icon\\n}\\n\\n--------------------------------------------------\\n-- Vectors ---------------------------------------\\n--------------------------------------------------\\n\\nforall Vector v {\\n\\n   -- vector origin\\n   scalar v.x0 = ? in shapeStage\\n   scalar v.x1 = ? in shapeStage\\n   v.x = (v.x0,v.x1)\\n\\n   -- vector direction\\n   scalar v.v0 = ? in shapeStage\\n   scalar v.v1 = ? in shapeStage\\n   v.v = (v.v0,v.v1)\\n\\n   shape v.icon = Line {\\n      start: v.x\\n      end: v.x + global.arrowLength*unit(v.v)\\n      strokeColor: colors.darkBlue\\n      strokeWidth: global.lineWidth\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5\\n      fill: \\\"none\\\"\\n   }\\n}\\n\\nforall Vector v\\nwhere v has label {\\n\\n   scalar phi = ? in labelStage\\n   scalar theta = (MathPI()/2.)*cos(phi)\\n   vec2 w = unit(v.v)\\n   vec2 u = rotateBy( w, theta )\\n   scalar r = global.labelDistance\\n\\n   v.labelText = Equation {\\n      string: v.label\\n      center: v.x + global.arrowLength*w + r*u\\n      fontSize: global.labelSize\\n      fillColor: v.icon.strokeColor\\n      --fontStyle: global.labelStyle\\n      --fontFamily: global.labelFamily\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Vector v; Point p\\nwhere RootedAt(p,v) {\\n   override v.x = p.x\\n   layer p.icon above v.icon\\n}\\n\\n-- draw segment normal as a vector at its midpoint\\nforall Vector v; Segment s\\nwhere v := Normal(s) {\\n   override v.x = (s.a + s.b)/2\\n   override v.v = global.arrowLength * rot90(unit(s.b - s.a))\\n}\\n\\n--------------------------------------------------\\n-- Segments --------------------------------------\\n--------------------------------------------------\\n\\nforall Segment s {\\n\\n   -- first endpoint\\n   scalar a0 = ? in shapeStage\\n   scalar a1 = ? in shapeStage\\n   vec2 s.a = (a0,a1)\\n\\n   -- second endpoint\\n   scalar b0 = ? in shapeStage\\n   scalar b1 = ? in shapeStage\\n   vec2 s.b = (b0,b1)\\n\\n   shape s.icon = Line {\\n      start: s.a\\n      end: s.b\\n      strokeColor: colors.black\\n      strokeWidth: global.lineWidth\\n      fill: \\\"none\\\"\\n   }\\n}\\n\\nforall Segment s; Point p; Point q\\nwhere s := Segment(p,q) {\\n   -- replace the endpoints with the\\n   -- locations of the given points\\n   override s.a = p.x\\n   override s.b = q.x\\n}\\n\\nforall Segment s\\nwhere s has label {\\n   s.labelText = Equation {\\n      string: s.label\\n      fontSize: global.labelSize\\n      --fontStyle: global.labelStyle\\n      --fontFamily: global.labelFamily\\n      fillColor: global.labelColor\\n      ensureOnCanvas: false\\n   }\\n   layer s.labelText above s.icon\\n\\n   vec2 m = (s.a + s.b)/2.\\n   scalar d = norm( m - s.labelText.center )\\n   encourage d == global.labelDistance in labelStage\\n\\n   ensure disjoint( s.labelText, s.icon, global.padding ) in labelStage\\n}\\n\\n-- Oriented segments are given an orientation marker in\\n-- the middle, going from the first to second point used\\n-- to define the segment.\\nforall Segment s\\nwhere IsOriented( s ) {\\n\\n   scalar h = global.dotRadius * 2.5\\n\\n   vec2 m = (s.a + s.b)/2\\n   vec2 t = unit(s.b - s.a) -- tangent\\n   vec2 n = rot90(t) -- normal\\n   shape s.orientationMarker = Polyline {\\n      points: ( m + h*(n-t/2), m + h*t/2, m + h*(-n-t/2) )\\n      strokeColor: s.icon.strokeColor\\n      strokeWidth: s.icon.strokeWidth\\n   }\\n}\\n\\nforall Segment s\\nwhere IsDashed( s ) {\\n   override s.icon.style = \\\"dashed\\\"\\n   override s.icon.strokeDasharray = \\\"4,4\\\"\\n}\\n\\n--------------------------------------------------\\n-- Angle markers --------------------------------\\n--------------------------------------------------\\n\\nforall Angle a {\\n   scalar a.theta0 = unitRandom() * 2*MathPI()\\n   scalar a.theta1 = unitRandom() * 2*MathPI()\\n   scalar a.radius = 20\\n   vec2 a.center = (0,0)\\n\\n   shape a.icon = Path {\\n      d: circularArc( \\\"open\\\", a.center, a.radius, a.theta0, a.theta1 )\\n      strokeColor: #000\\n      strokeWidth: 1\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Angle a\\nwhere IsOriented( a ) {\\n   override a.icon.endArrowhead = \\\"straight\\\"\\n   override a.icon.endArrowheadSize = 0.5\\n}\\n\\nforall Angle a; Point x,y,z\\nwhere a := InteriorAngle(x,y,z) {\\n   vec2 u = y.x - x.x\\n   vec2 v = z.x - x.x\\n   override a.theta0 = angleOf(u)\\n   scalar s = sign(cross2D(u,v))\\n   scalar arrowheadArc = 4\\n   scalar dTheta = s * ( angleBetween(u,v) - arrowheadArc/a.radius )\\n   override a.theta1 = a.theta0 + dTheta\\n   override a.center = x.x\\n}\\n\\nforall Angle a; Triangle t {\\n   layer a.icon above t.icon\\n}\\n\\n--------------------------------------------------\\n-- Length markers --------------------------------\\n--------------------------------------------------\\n\\n-- draw length markers as segments with perpendicular markers at the ends\\nforall Length l {\\n\\n   -- marker parameters\\n   scalar l.markerSize = 2*global.dotRadius\\n   scalar l.shortening = 2*global.dotRadius\\n\\n   -- first endpoint of labeled segment\\n   scalar a0 = ? in shapeStage\\n   scalar a1 = ? in shapeStage\\n   vec2 l.a = (a0,a1)\\n\\n   -- second endpoint of labeled segment\\n   scalar b0 = ? in shapeStage\\n   scalar b1 = ? in shapeStage\\n   vec2 l.b = (b0,b1)\\n\\n   vec2 l.t = unit( l.a - l.b ) -- tangent\\n   vec2 l.n = rot90( l.t ) -- normal\\n\\n   -- offset length marker by +/- offset size\\n   scalar offsetSize = 8.0\\n   scalar l.h = ? in shapeStage\\n   ensure l.h*l.h == sqr(offsetSize) in shapeStage\\n   -- scalar l.h = 8\\n\\n   -- endpoints of length marker\\n   scalar l.x = l.a - l.shortening*l.t + l.h*l.n\\n   scalar l.y = l.b + l.shortening*l.t + l.h*l.n\\n\\n   l.icon = Line {\\n      start: l.x\\n      end: l.y\\n      strokeWidth: .75\\n      strokeColor: colors.lightGray\\n      fill: \\\"none\\\"\\n   }\\n   l.end0 = Line {\\n      start: l.x - l.markerSize*l.n\\n      end: l.x + l.markerSize*l.n\\n      strokeWidth: l.icon.strokeWidth\\n      strokeColor: l.icon.strokeColor\\n      fill: \\\"none\\\"\\n   }\\n   l.end1 = Line {\\n      start: l.y - l.markerSize*l.n\\n      end: l.y + l.markerSize*l.n\\n      strokeWidth: l.icon.strokeWidth\\n      strokeColor: l.icon.strokeColor\\n      fill: \\\"none\\\"\\n   }\\n}\\n\\nforall Length l; Point a; Point b\\nwhere l := LengthBetween(a,b) {\\n   override l.a = a.x\\n   override l.b = b.x\\n}\\n\\nforall Length l; Segment s\\nwhere l := LengthOf(s) {\\n   override l.a = s.a\\n   override l.b = s.b\\n   override l.icon.ensureOnCanvas = false\\n}\\n\\nforall Length l\\nwhere l has label {\\n\\n   -- offset label in same direction as length marker\\n   vec2 m = (l.x + l.y)/2.\\n   vec2 c = m + l.h*l.n/1.5\\n\\n   l.labelText = Equation {\\n      center: c\\n      string: l.label\\n      fontSize: global.labelSize\\n      -- fontStyle: global.labelStyle\\n      -- fontFamily: global.labelFamily\\n      fillColor: l.icon.strokeColor\\n      ensureOnCanvas: false\\n   }\\n   layer l.labelText above l.icon\\n}\\n\\n--------------------------------------------------\\n-- Triangles -------------------------------------\\n--------------------------------------------------\\n\\nforall Triangle t\\n{\\n   -- vertices\\n   vec2 t.a = (? in shapeStage, ? in shapeStage)\\n   vec2 t.b = (? in shapeStage, ? in shapeStage)\\n   vec2 t.c = (? in shapeStage, ? in shapeStage)\\n\\n   shape t.icon = Polygon {\\n      points: [ t.a, t.b, t.c ]\\n      fillColor: colors.clearGray\\n   }\\n}\\n\\nforall Triangle t; Point p1; Point p2; Point p3\\nwhere t := Triangle(p1, p2, p3)\\n{\\n   override t.a = p1.x\\n   override t.b = p2.x\\n   override t.c = p3.x\\n}\\n\\nforall Point p; Triangle t; Point q0; Point q1; Point q2\\nwhere InTri( p, t ); t := Triangle(q0, q1, q2) {\\n   override p.x = triangleRandom(q0.x, q1.x, q2.x)\\n}\\n\\n\\n--------------------------------------------------\\n-- Polylines -------------------------------------\\n--------------------------------------------------\\n\\nforall Polyline M {\\n\\n   vec2 M.p0 = (? in shapeStage, ? in shapeStage)\\n   scalar theta0 = random(0,1)*2.*MathPI()\\n   scalar theta1 = theta0 + random(.5,1)*MathPI()/2\\n   scalar theta2 = theta1 + random(.5,1)*MathPI()/2\\n   scalar theta3 = theta2 - random(.5,1)*MathPI()/2\\n   scalar L = canvas.width/5\\n   vec2 M.p1 = M.p0 + L*(cos(theta0),sin(theta0))\\n   vec2 M.p2 = M.p1 + L*(cos(theta1),sin(theta1))\\n   vec2 M.p3 = M.p2 + L*(cos(theta2),sin(theta2))\\n   vec2 M.p4 = M.p3 + L*(cos(theta3),sin(theta3))\\n\\n   shape M.icon = Polyline {\\n      points: [ M.p0, M.p1, M.p2, M.p3, M.p4 ]\\n   }\\n}\\n\\n--------------------------------------------------\\n-- Circles ---------------------------------------\\n--------------------------------------------------\\n\\nforall Circle c {\\n   -- center\\n   scalar x0 = ? in shapeStage\\n   scalar x1 = ? in shapeStage\\n   vec2 c.x = ( x0, x1 )\\n\\n   -- radius\\n   scalar c.r = ? in shapeStage\\n\\n   shape c.icon = Circle {\\n      center: c.x\\n      r: c.r\\n      fillColor: none()\\n      strokeColor: colors.black\\n      strokeWidth: global.lineWidth\\n   }\\n}\\n\\nforall Point p; Circle c\\nwhere OnCircle( p, c ) {\\n   override p.x = c.icon.r*circleRandom() + c.icon.center\\n}\\n\\n--------------------------------------------------\\n-- Disks -----------------------------------------\\n--------------------------------------------------\\n\\nforall Disk d {\\n   -- center\\n   scalar x0 = ? in shapeStage\\n   scalar x1 = ? in shapeStage\\n   vec2 c.x = ( x0, x1 )\\n\\n   -- radius\\n   scalar c.r = ? in shapeStage\\n\\n   shape d.icon = Circle {\\n      center: c.x\\n      r: c.r\\n   }\\n}\\n\\nforall Point p; Disk d\\nwhere InDisk( p, d ) {\\n   override p.x = d.icon.r*diskRandom() + d.icon.center\\n}\\n\\n--------------------------------------------------\\n-- Chords ----------------------------------------\\n--------------------------------------------------\\n\\nforall Chord c {\\n   shape c.icon = Line {\\n      strokeWidth: .25*global.lineWidth\\n      strokeColor: colors.black\\n      fill: \\\"none\\\"\\n   }\\n}\\n\\nforall Chord c; Disk d\\nwhere OfDisk(c,d) {\\n   scalar t0 = 2.*random(0,MathPI())\\n   scalar t1 = 2.*random(0,MathPI())\\n   c.icon.start = d.icon.r*(cos(t0),sin(t0)) + d.icon.center\\n   c.icon.end = d.icon.r*(cos(t1),sin(t1)) + d.icon.center\\n}\\n\\n--------------------------------------------------\\n-- Rays ------------------------------------------\\n--------------------------------------------------\\n\\nforall Ray r {\\n   r.icon = Line {\\n      strokeColor: colors.lightGray\\n      style: \\\"dashed\\\"\\n      strokeDasharray: \\\"4,4\\\"\\n      ensureOnCanvas: false\\n      fill: \\\"none\\\"\\n   }\\n}\\n\\nforall Ray r; Point p; Vector v\\nwhere r := RayFrom(p,v) {\\n\\n   override v.x = p.x\\n   override v.icon.ensureOnCanvas = false\\n\\n   -- draw the ray as a line whose length\\n   -- is equal to the diameter of the canvas,\\n   -- so that it always goes \\\"off screen\\\" (but\\n   -- isn't so crazy long that it causes problems\\n   -- for display, editing, etc.)\\n   vec2 d = (canvas.width,canvas.height)\\n   scalar L = norm(d)\\n   vec2 r.x = p.x\\n   vec2 r.v = unit(v.v)\\n   r.icon.start = r.x\\n   r.icon.end = r.x + L*r.v\\n\\n   layer r.icon below v.icon\\n}\\n\\n--------------------------------------------------\\n-- Ray intersections -----------------------------\\n--------------------------------------------------\\n\\nforall Point q; Ray r; Point p; Vector v; Segment s; Point a; Point b\\nwhere q := RaySegmentIntersection(r,s); r := RayFrom(p,v); s := Segment(a,b) {\\n\\n   -- put the intersection point at some random point in the segment\\n   scalar u = random(.2,.8)\\n   override q.x = (1-u)*a.x + u*b.x\\n\\n   -- make the ray point toward the intersection point\\n   override v.v = unit(q.x - p.x)\\n\\n   -- make the ray origin reasonably far from the intersection point\\n   ensure norm(p.x-q.x) > 1.5*global.arrowLength in shapeStage\\n\\n   -- make sure the angle of intersection is not too shallow\\n   vec2 w = unit(b.x-a.x)\\n   ensure sqr(dot(v.v,w)) < .25 in shapeStage\\n\\n   -- draw the intersection point as a white dot\\n   override q.icon.fillColor = colors.white\\n   override q.icon.strokeColor = colors.black\\n   override q.icon.strokeWidth = global.dotStroke\\n}\\n\\nforall Point q; Ray r; Set s\\nwhere q := RayIntersection(r,s) {\\n\\n   override q.x = rayIntersect( s.icon, r.x, r.v )\\n\\n   -- since the intersection point could be off the\\n   -- canvas, we shouldn't try to enforce a constraint\\n   -- keeping it on the canvas\\n   override q.icon.ensureOnCanvas = false\\n\\n   -- draw the intersection point as a white dot\\n   override q.icon.fillColor = colors.white\\n   override q.icon.strokeColor = colors.black\\n   override q.icon.strokeWidth = global.dotStroke\\n}\\n\\n\\n--------------------------------------------------\\n-- Closest points --------------------------------\\n--------------------------------------------------\\n\\nforall Point q; Set s; Point p\\nwhere q := ClosestPoint( s, p ) {\\n   override q.x = closestPoint( s.icon, p.x )\\n   override q.icon.fillColor = colors.white\\n   override q.icon.strokeColor = colors.black\\n   override q.icon.strokeWidth = global.dotStroke\\n   override q.icon.ensureOnCanvas = false\\n}\\n\\nforall Segment t; Set s; Point p\\nwhere t := ClosestSegment( s, p ) {\\n   override t.a = p.x\\n   override t.b = closestPoint( s.icon, p.x )\\n   override t.icon.strokeColor = colors.lightGray\\n   override t.icon.ensureOnCanvas = false\\n   override t.icon.strokeStyle = \\\"dashed\\\"\\n   override t.icon.strokeDasharray = \\\"4,3\\\"\\n}\\n\\n--------------------------------------------------\\n-- Overlap constraints ---------------------------\\n--------------------------------------------------\\n\\nforall Set X\\nwhere X has label {\\n   constraint X.labelDisjoint = ensure disjoint( X.icon, X.labelText, global.padding ) in labelStage\\n}\\n\\nforall Length l\\nwhere l has label {\\n   delete l.labelDisjoint\\n}\\n\\nforall Set X; Point p\\nwhere X has label {\\n   ensure disjoint( X.labelText, p.icon, global.padding ) in labelStage\\n}\\nforall Set X; Segment s\\nwhere X has label {\\n   ensure disjoint( X.labelText, s.icon, global.padding ) in labelStage\\n}\\nforall Set X; Length l\\nwhere X has label {\\n   ensure disjoint( X.labelText, l.icon, global.padding ) in labelStage\\n}\\n\\nforall Set X; Set Y\\nwhere X has label; Y has label {\\n   ensure disjoint( X.labelText, Y.labelText, global.padding ) in labelStage\\n}\\n\\n--------------------------------------------------\\n-- Layering --------------------------------------\\n--------------------------------------------------\\n\\nforall Point p; Set X {\\n   layer p.icon above X.icon\\n}\\n\\nforall Point p; Set X\\nwhere p has label {\\n   layer p.labelText above X.icon\\n}\\n\\n-- AtomicClosestPoint.style ----------------------\\n\\n-- forall Segment `ab` {\\n--    ensure norm( `ab`.a - `ab`.b ) == canvas.width in shapeStage\\n-- }\\n-- forall Segment `s` {\\n--    ensure norm( `s`.a - `s`.b ) == canvas.width * .5 in shapeStage\\n-- }\\n-- forall Length `l` {\\n--    ensure norm( `l`.a - `l`.b ) > canvas.width * .2 in shapeStage\\n--    ensure norm( `l`.a - `l`.b ) < canvas.width * .8 in shapeStage\\n-- }\\n\\n-- ClosestPoint.style ----------------------------\\n\\n-- forall Point xi; Point xj; Point yi; Point yj; Polyline M\\n-- where yi := ClosestPoint(M,xi); yj := ClosestPoint(M,xj) {\\n--    encourage 100/norm(xi.x-xj.x) == 0\\n-- }\\n\\n-- FirstRay.style ----------------------------\\n\\n-- forall Point p {\\n--    override p.x0 = -canvas.width/2 + 10\\n-- }\\n-- \\n-- forall Point p; Polyline M {\\n-- \\n--    scalar y0 = min( M.p0[1], min( M.p1[1], min( M.p2[1], min( M.p3[1], M.p4[1] ))))\\n--    scalar y1 = max( M.p0[1], max( M.p1[1], max( M.p2[1], max( M.p3[1], M.p4[1] ))))\\n-- \\n--    scalar t = random(0,1)\\n--    override p.x1 = (1-t)*y0 + t*y1\\n-- }\\n-- \\n-- forall Vector v {\\n--    override v.v0 = 1000\\n-- }\\n\\n-- AtomicClosestSilhouette.style\\n\\n-- resizeCanvas\\n-- {\\n--    override canvas.width = 150\\n-- }\\n-- \\n-- forall Point `a` {\\n--    scalar w = canvas.width\\n--    scalar h = canvas.height\\n--    override `a`.x = (-w/2 + 10,0)\\n-- }\\n-- forall Point `b` {\\n--    scalar w = canvas.width\\n--    scalar h = canvas.height\\n--    override `b`.x = (0,h/6)\\n-- }\\n-- forall Point `c` {\\n--    scalar w = canvas.width\\n--    scalar h = canvas.height\\n--    override `c`.x = (w/2 - 10,-h/6)\\n-- }\\n-- forall Segment `ab` {\\n--    override `ab`.icon.strokeWidth = 1.5*global.lineWidth\\n-- }\\n-- forall Segment `bc` {\\n--    override `bc`.icon.strokeWidth = 1.5*global.lineWidth\\n-- }\\n-- \\n-- -- Conditionally label diagram as \\\"silhouette\\\" or\\n-- -- \\\"not silhouette\\\" depending on whether `b` is a silhouette\\n-- -- point relative to `x`.\\n-- forall Triangle t1; Triangle t2 {\\n-- \\n--    -- compute the signed area of each triangle\\n--    scalar A1 = cross2D( t1.b - t1.a, t1.c - t1.a )\\n--    scalar A2 = cross2D( t2.b - t2.a, t2.c - t2.a )\\n-- \\n--    -- compute the sign of the product, which will\\n--    -- be positive if the triangles have the same\\n--    -- orientation and negative otherwise\\n--    scalar s = A1*A2\\n-- \\n--    -- emulate the statement\\n--    --    alpha = s < 0 ? 0 : 1\\n--    -- using a steep sigmoid function to\\n--    -- approximate a step function\\n--    scalar alpha = 1/(1 + exp(-1000*s))\\n-- \\n--    shape isSilhouette = Text {\\n--       string: \\\"silhouette\\\"\\n--       center: (0,-canvas.height/2 + 2*global.labelHeight) - 1.5*global.labelHeight*(0,alpha)\\n--       fontFamily: global.labelFamily\\n--       fontSize: global.labelSize\\n--       fillColor: rgba( alpha, alpha, alpha, 1-alpha )\\n--       opacity: 1 - alpha\\n--       ensureOnCanvas: false\\n--    }\\n-- \\n--    shape notSilhouette = Text {\\n--       string: \\\"not silhouette\\\"\\n--       center: (0,-canvas.height/2 + 2*global.labelHeight) - 1.5*global.labelHeight*(0,1-alpha)\\n--       fontFamily: global.labelFamily\\n--       fontSize: global.labelSize\\n--       fillColor: rgba( 1-alpha, 1-alpha, 1-alpha, alpha )\\n--       opacity: alpha\\n--       ensureOnCanvas: false\\n--    }\\n-- }\\n\\n-- AtomicClosestSilhouetteExample1.style\\n-- forall Point `x` {\\n--    override `x`.x = (0,canvas.height/2 - 2*global.labelHeight)\\n-- }\\n\\n-- -- AtomicClosestSilhouetteExample2.style\\n-- forall Point `x` {\\n--    override `x`.x = (-canvas.width/4,-canvas.height/2 + 4*global.labelHeight)\\n-- }\\n\\n-- -- AtomicClosestSilhouetteExample3.style\\n-- forall Point `x` {\\n--    override `x`.x = (canvas.width/2 - global.labelHeight, global.labelHeight*2)\\n-- }\\n\\n-- subtended-angles.style\\n\\n-- -- Shade signed angles blue if they're positive, and red\\n-- -- if they're negative\\n-- forall Angle t; Point a, b, c\\n-- where t := InteriorAngle(a,b,c); IsOriented(t)\\n-- {\\n--    -- computes a value v equal to zero if the triangle\\n--    -- is negatively-oriented, and one if the triangle is\\n--    -- positively-oriented\\n--    scalar u = sign( cross2D( b.x - a.x, c.x - a.x ))\\n--    scalar v = (u + 1)/2\\n-- \\n--    shape subtended = Polygon {\\n--       points: ( b.x, a.x, c.x )\\n--       fillColor: rgba( 1-v, 0, v, .2 )\\n--       strokeColor: #0002\\n--       strokeWidth: .5\\n--       ensureOnCanvas: false\\n--    }\\n-- \\n--    override t.icon.strokeColor = rgba( 1-v, 0, v, .4 )\\n-- }\\n\\n-- AtomicSignedAngle.style\\n\\n-- AtomicSignedAngle {\\n--    scalar segmentSize = toRadians(50)\\n--    override canvas.width = 200\\n-- }\\n-- \\n-- forall Point `x` {\\n--    override `x`.x = (0,0)\\n-- }\\n-- \\n-- forall Point `a`, `b` {\\n--    scalar theta = unitRandom() * 2*MathPI()\\n--    scalar dTheta = AtomicSignedAngle.segmentSize\\n--    scalar r = .9 * canvas.height/2\\n--    override `a`.x = r*(cos(theta-dTheta/2),sin(theta-dTheta/2))\\n--    override `b`.x = r*(cos(theta+dTheta/2),sin(theta+dTheta/2))\\n-- }\\n-- \\n-- forall Point `c`, `d` {\\n--    scalar theta = unitRandom() * 2*MathPI()\\n--    scalar dTheta = 1.5*AtomicSignedAngle.segmentSize\\n--    scalar r = .9 * canvas.height/2\\n--    override `c`.x = r*(cos(theta+dTheta/2),sin(theta+dTheta/2))\\n--    override `d`.x = r*(cos(theta-dTheta/2),sin(theta-dTheta/2))\\n-- }\\n\\n-- SignedAngle.style\\n\\n-- SignedAngle {\\n--    override canvas.width = 200\\n-- }\\n-- \\n-- -- put the points on the boundary of the letter \\\"A\\\"\\n-- forall Point `a1`, `a2`, `a3`, `a4`, `a5`, `a6`, `a7`, `a8`, `b1`, `b2`, `b3` {\\n-- \\n--    scalar s = canvas.height - 10 -- scale\\n-- \\n--    -- outer boundary\\n--    override `a1`.x = s * (-.169, -.287)\\n--    override `a2`.x = s * ( .173, -.287)\\n--    override `a3`.x = s * ( .249, -.500)\\n--    override `a4`.x = s * ( .500, -.500)\\n--    override `a5`.x = s * ( .119,  .500)\\n--    override `a6`.x = s * (-.123,  .500)\\n--    override `a7`.x = s * (-.500, -.500)\\n--    override `a8`.x = s * (-.242, -.500)\\n-- \\n--    -- hole\\n--    override `b1`.x = s * ( 0.00,  .202)\\n--    override `b2`.x = s * ( .105, -.094)\\n--    override `b3`.x = s * (-.102, -.094)\\n-- }\\n-- \\n-- forall Angle a {\\n--    override a.radius = 20 + 60*(match_id - 1)/(match_total - 1)\\n-- }\\n\\n-- SignedAngleInside.style\\n\\n-- forall Point `x` {\\n--    override `x`.x = (50,-30)\\n-- }\\n\\n-- SignedAngleOutside.style\\n\\n-- forall Point `x` {\\n--    override `x`.x = (90,50)\\n-- }\\n\\n-- AtomicClosestRay.style\\n\\n-- forall Point `a`, `b`, `x` {\\n--    scalar w = canvas.width\\n--    scalar h = canvas.height\\n--    scalar p = 20\\n--    override `a`.x = ( -w/2 + p, -h/2 + p )\\n--    override `b`.x = ( w/2 - p, h/2 - p )\\n--    override `x`.x = ( -w/4 + p, h/2 - p )\\n-- }\\n\\n\";\n//# sourceMappingURL=geometry-2d.style.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"-- Shade signed angles blue if they're positive, and red\\n-- if they're negative\\nforall Angle t; Point a, b, c\\nwhere t := InteriorAngle(a,b,c); IsOriented(t)\\n{\\n   -- computes a value v equal to zero if the triangle\\n   -- is negatively-oriented, and one if the triangle is\\n   -- positively-oriented\\n   scalar u = sign( cross2D( b.x - a.x, c.x - a.x ))\\n   scalar v = (u + 1)/2\\n\\n   shape subtended = Polygon {\\n      points: ( b.x, a.x, c.x )\\n      fillColor: rgba( 1-v, 0, v, .2 )\\n      strokeColor: #0002\\n      strokeWidth: .5\\n      ensureOnCanvas: false\\n   }\\n\\n   override t.icon.strokeColor = rgba( 1-v, 0, v, .4 )\\n}\\n\";\n//# sourceMappingURL=subtended-angles.style.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"SignedAngle {\\n   override canvas.width = 200\\n}\\n\\n-- put the points on the boundary of the letter \\\"A\\\"\\nforall Point `a1`, `a2`, `a3`, `a4`, `a5`, `a6`, `a7`, `a8`, `b1`, `b2`, `b3` {\\n\\n   scalar s = canvas.height - 10 -- scale\\n\\n   -- outer boundary\\n   override `a1`.x = s * (-.169, -.287)\\n   override `a2`.x = s * ( .173, -.287)\\n   override `a3`.x = s * ( .249, -.500)\\n   override `a4`.x = s * ( .500, -.500)\\n   override `a5`.x = s * ( .119,  .500)\\n   override `a6`.x = s * (-.123,  .500)\\n   override `a7`.x = s * (-.500, -.500)\\n   override `a8`.x = s * (-.242, -.500)\\n\\n   -- hole\\n   override `b1`.x = s * ( 0.00,  .202)\\n   override `b2`.x = s * ( .105, -.094)\\n   override `b3`.x = s * (-.102, -.094)\\n}\\n\\nforall Angle a {\\n   override a.radius = 20 + 60*(match_id - 1)/(match_total - 1)\\n}\\n\\n\";\n//# sourceMappingURL=SignedAngle.style.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"walk-on-spheres\");\nexport default \"forall Point `x` {\\n   override `x`.x = (90,50)\\n}\\n\";\n//# sourceMappingURL=SignedAngleOutside.style.js.map","export default \"type Set\\ntype Point <: Set\\ntype Segment <: Set\\ntype Ray <: Set\\ntype Vector <: Set\\ntype Triangle <: Set\\ntype Circle <: Set\\ntype Disk <: Set\\ntype Chord <: Set\\ntype Length <: Set\\ntype Polyline <: Set\\ntype Angle <: Set\\n\\nconstructor Segment( Point p, Point q )\\nconstructor LineSegment( Point p, Point q ) -> Segment\\nconstructor ClosestPoint( Set s, Point p ) -> Point\\nconstructor ClosestSegment( Set s, Point p ) -> Segment\\nconstructor RayFrom( Point p, Vector v ) -> Ray\\nconstructor RayIntersection( Ray r, Set s ) -> Point\\nconstructor RaySegmentIntersection( Ray r, Segment s ) -> Point\\nconstructor Triangle( Point p1, Point p2, Point p3 )\\nconstructor LengthBetween( Point x, Point y ) -> Length\\nconstructor LengthOf( Segment s ) -> Length\\nconstructor Normal( Set s ) -> Vector\\nconstructor InteriorAngle( Point a, Point b, Point c ) -> Angle\\n\\npredicate RootedAt( Point p, Vector v )\\npredicate InTri( Point p, Triangle t )\\npredicate OnCircle( Point p, Circle c )\\npredicate InDisk( Point p, Disk d )\\npredicate OfDisk( Chord c, Disk d )\\npredicate IsDashed( Set s )\\npredicate IsOriented( Set s )\\n\\n\";\n//# sourceMappingURL=geometry-2d.domain.js.map","import substance from \"./SignedAngle.substance.js\";\nimport style0, { resolver as resolver0 } from \"./geometry-2d.style.js\";\nimport style1, { resolver as resolver1 } from \"./subtended-angles.style.js\";\nimport style2, { resolver as resolver2 } from \"./SignedAngle.style.js\";\nimport style3, { resolver as resolver3 } from \"./SignedAngleOutside.style.js\";\nimport domain from \"./geometry-2d.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n        { contents: style1, resolver: resolver1 },\n        { contents: style2, resolver: resolver2 },\n        { contents: style3, resolver: resolver3 },\n    ],\n    domain,\n    variation: \"BollywoodKangaroo140\",\n    excludeWarnings: []\n};\n//# sourceMappingURL=SignedAngleOutside.trio.js.map"],"names":["substance","resolver","makeResolver","style0","style1","style2","style3","domain","SignedAngleOutside_trio","resolver0","resolver1","resolver2","resolver3"],"mappings":"wEAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECDFF,EAAWC,EAAa,iBAAiB,EACtDE,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECDFH,EAAWC,EAAa,iBAAiB,EACtDG,EAAe,gzBCDFJ,EAAWC,EAAa,iBAAiB,EACtDI,EAAe,uDCFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECMAC,EAAA,CACX,UAAAR,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUM,CAAW,EACzC,CAAE,SAAUL,EAAQ,SAAUM,CAAW,EACzC,CAAE,SAAUL,EAAQ,SAAUM,CAAW,EACzC,CAAE,SAAUL,EAAQ,SAAUM,CAAW,CAC5C,EACD,OAAAL,EACA,UAAW,uBACX,gBAAiB,CAAE,CACvB"}