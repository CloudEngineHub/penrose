{"version":3,"file":"two-vectors-perp.trio-b3f57ebb.js","sources":["../../../examples/dist/linear-algebra-domain/linearalgebra-paper-dashes.style.js","../../../examples/dist/linear-algebra-domain/two-vectors-perp.trio.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"linear-algebra-domain\");\nexport default \"canvas {\\n  width = 800\\n  height = 700\\n}\\n\\nconst { -- 0\\n  scalar perpLen = 20.0\\n  -- For unit mark\\n  scalar markerPadding = 15.0\\n  scalar barSize = 5.0\\n  scalar vectorSpaceSize = 350.0\\n  scalar repelWeight = 0.7\\n  scalar arrowheadSize = 0.7\\n  scalar lineThickness = 1.\\n  int intForTesting = 1\\n  bool boolForTesting = true\\n}\\n\\nC { -- 1\\n    -- black = #000000\\n    color black = rgba(0.,0.,0.,1.)\\n    white = rgba(1., 1., 1., 1.)\\n    lightBlue = rgba(1e-1, 0.1, 0.9, 1.0)\\n    -- Note: we don't currently support color accessors r,g,b\\n    -- darkBlue = rgba(lightBlue.r / 2., lightBlue.g / 2., lightBlue.b / 2., 0.5)\\n    darkGray = rgba(0.4, 0.4, 0.4, 1.)\\n    gray = rgba(0.6, 0.6, 0.6, 1.)\\n    green = rgba(0., 0.8, 0., 1.)\\n    -- blue = #0000ff\\n    none = none()\\n}\\n\\n-- Just some weird definitions to test parser. Not used in rest of program\\ntesting { -- 2\\n  -- COMBAK: Test that plugins still run\\n  -- pluginVar = \\\"ddg\\\"[\\\"a\\\"][\\\"length\\\"]\\n        x = { 1, 2 }\\n        y = [-2., const.perpLen, const.markerPadding + 3]\\n        a = (-1.0, ?)\\n        a1 = (-1.0, 2.) + (1e5, 2.0)\\n        m = (a, (-1., 2.))\\n        v = (a + (2., 900.))  / (4.0 + 3.)\\n        -- z = Colors.black.g\\n        asum = a[1] + a[0]\\n        -- Currently not supported: indexing a vector or list by a variable\\n        -- c = 0\\n        -- b = 1\\n        -- msum = m[1][0] + m[c][b]\\n        nv = -v\\n        -- t1 = x[1][b]\\n\\n        -- test parser access of matrix\\n        -- test0 = f(0)[1]\\n        -- test1 = makeMatrix((1, 0.0, 5.0), (-1, -9., -4.))[2][0]\\n        -- test2 = (makeVector(-1, 3.0) + (3.4, 2.1))[0]\\n}\\n\\nforall VectorSpace U { -- 3\\n    scalar axisSize = const.vectorSpaceSize / 2.0 -- This should get promoted to float\\n    vec2 U.origin = (0., 0.)\\n    vec2 o = U.origin\\n    U.axisColor = C.gray\\n\\n    shape U.background = Rectangle {\\n        center : U.origin\\n        width : const.vectorSpaceSize\\n        height : const.vectorSpaceSize\\n        fillColor : C.none\\n        strokeColor : C.none\\n        -- strokeWidth : 2.0\\n    }\\n\\n    shape U.xAxis = Line {\\n        start : (o[0] - axisSize, o[1]) -- TODO This gets mis-parsed as a matrix access\\n        end : (o[0] + axisSize, o[1])\\n        strokeWidth : const.lineThickness\\n        style : \\\"solid\\\"\\n        strokeColor : U.axisColor\\n        startArrowhead: \\\"straight\\\"\\n        endArrowhead: \\\"straight\\\"\\n        startArrowheadSize : const.arrowheadSize * 2.\\n        endArrowheadSize : const.arrowheadSize * 2.\\n    }\\n\\n    U.yAxis = Line {\\n        start : (o[0], o[1] - axisSize)\\n        end : (o[0], o[1] + axisSize)\\n        strokeWidth : const.lineThickness\\n        style : \\\"solid\\\"\\n        strokeColor : U.axisColor\\n        startArrowhead: \\\"straight\\\"\\n        endArrowhead: \\\"straight\\\"\\n        startArrowheadSize : const.arrowheadSize * 2.\\n        endArrowheadSize : const.arrowheadSize * 2.\\n    }\\n\\n    U.text = Equation {\\n        string : U.label\\n        center : (U.origin[0] - axisSize, U.origin[1] + axisSize)\\n        fillColor : U.axisColor\\n    }\\n}\\n\\nforall Vector u; VectorSpace U -- 4\\nwhere In(u,U) {\\n  u.text = Equation {\\n    -- center : (?, ?) -- This should be done automatically\\n    string : u.label\\n    fillColor : u.arrow.strokeColor\\n  }\\n\\n  u.arrow = Line {\\n    start : U.origin\\n    end : (?, ?)\\n    strokeWidth : 3.0\\n    strokeColor : C.lightBlue\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n    strokeDasharray : \\\"4 1 2\\\"\\n  }\\n\\n   u.vector = u.arrow.end - u.arrow.start -- Vector sugar for subtraction\\n\\n   ensure contains(U.background, u.arrow)\\n   ensure contains(U.background, u.text)\\n   ensure atDist(u.arrow, u.text, 15.0)\\n   ensure lessThan(20, length(u.arrow))\\n\\n  layer u.text above U.xAxis\\n  layer u.text above U.yAxis\\n}\\n\\nforall Vector u; Vector v -- 5\\nwith VectorSpace U\\nwhere Orthogonal(u, v); In(u, U); In(v, U) {\\n      startR = u.arrow.start -- TODO: Do we want destructuring syntax like vec2[] [startR, endR] = [u.arrow.start, u.arrow.end]\\n      endR = u.arrow.end\\n      startL = v.arrow.start\\n      endL = v.arrow.end\\n      dirR = normalize(endR - startR)  -- Syntax sugar for vectors (better in Style because JS doesn't allow it!)\\n      dirL = normalize(endL - startL)\\n      ptL = startR + const.perpLen * dirL\\n      ptR = startR + const.perpLen * dirR\\n      ptLR = ptL + const.perpLen * dirR\\n      pts = [startR, ptL, ptLR, ptR]\\n\\n      -- toPath = functions.pathFromPoints -- COMBAK: Add ability to alias function names\\n\\n      -- Draw perpendicular mark -- NOTE: local shapes should still be drawn\\n      perpMark = Path {\\n           d : pathFromPoints(\\\"closed\\\", pts)\\n           -- strokeWidth : 2.0\\n           strokeColor : C.black\\n           fillColor : C.white\\n      }\\n\\n      -- Make sure vectors are orthogonal (use ensure?)\\n      -- eq = functions.equal\\n      encourage equal(dot(u.vector, v.vector), 0.0) -- NOTE: Have to import Penrose fns\\n\\n-- COMBAK: Test parsing the expressions that involve local vars \\n      layer v.arrow above perpMark\\n      layer u.arrow above perpMark\\n}\\n\\nforall Vector v -- 6\\nwith VectorSpace U; Vector w\\nwhere In(v, U); Unit(v); Orthogonal(v, w) {\\n      -- Usually, the unit vector shouldn't need to know about orthogonal vectors\\n      -- but we need to position the unit mark so it doesn't overlap with the \\\"inside\\\" of the two vectors\\n\\n      strokeWidth = 2.0\\n      padding = 15.0 -- COMBAK: What is this?\\n      -- toPath = functions.pathFromPoints -- COMBAK\\n\\n      -- The start and end of the body of the unit marker line\\n      -- NOTE: We need to have lists of vectors\\n      dir = normalize(w.arrow.end - w.arrow.start)\\n      normal = -dir\\n      markStart = v.arrow.start + padding * normal\\n      markEnd = v.arrow.end + padding * normal\\n      v.markerLine = [markStart, markEnd]\\n\\n      v.unitMarkerLine = Path {\\n          d : pathFromPoints(\\\"open\\\", v.markerLine)\\n          -- strokeWidth : strokeWidth\\n          strokeColor : C.black\\n          fillColor : C.none\\n      }\\n\\n      -- Could use normal instead, just doing this to demonstrate how to use matrices\\n      mat2x2 rot90CW = ((0., 1.), (-1., 0.))\\n      vec2 markNormal = mul(rot90CW, normalize(v.arrow.end - v.arrow.start)) -- TODO: Do we want syntactic sugar for matrix-vector multiplication? Or a better name?\\n      scalar c = const.barSize\\n      vec2 halfvec = c * markNormal\\n\\n      v.unitMarkerEnd1 = Path {\\n          d : pathFromPoints(\\\"open\\\", [markStart - halfvec, markStart + halfvec]) -- TODO: Can we infer this type if it's written anonymously?\\n          -- strokeWidth : strokeWidth\\n          strokeColor : C.black\\n          fillColor : C.none\\n      }\\n\\n      v.unitMarkerEnd2 = Path {\\n          d : pathFromPoints(\\\"open\\\", [markEnd - halfvec, markEnd + halfvec])\\n          -- strokeWidth : strokeWidth\\n          strokeColor : C.black\\n          fillColor : C.none\\n      }\\n\\n      vec2 midpointLoc = (v.markerLine[0] + v.markerLine[1]) / 2.\\n      vec2 labelPos = midpointLoc + const.markerPadding * normal\\n\\n      v.unitMarkerText = Equation {\\n          string : \\\"1\\\"\\n          center : labelPos\\n          fillColor : C.black\\n      }\\n\\n      layer v.unitMarkerLine above U.xAxis\\n      layer v.unitMarkerLine above U.yAxis\\n}\\n\\nforall Vector `x2` { -- 7\\n       override `x2`.arrow.strokeColor = C.green\\n}\";\n//# sourceMappingURL=linearalgebra-paper-dashes.style.js.map","import substance from \"./twoVectorsPerp-unsugared.substance.js\";\nimport style0, { resolver as resolver0 } from \"./linearalgebra-paper-dashes.style.js\";\nimport domain from \"./linear-algebra.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"\"\n};\n//# sourceMappingURL=two-vectors-perp.trio.js.map"],"names":["resolver","makeResolver","style0","twoVectorsPerp_trio","substance","resolver0","domain"],"mappings":"oJACO,MAAMA,EAAWC,EAAa,uBAAuB,EAC5DC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GCCAC,EAAA,CACX,UAAAC,EACA,MAAO,CACH,CAAE,SAAUF,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAC,EACA,UAAW,EACf"}