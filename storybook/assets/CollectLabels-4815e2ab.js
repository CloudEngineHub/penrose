var z=Object.defineProperty;var i=(a,o)=>z(a,"name",{value:o,configurable:!0});import{G as P,R as H,T as I,H as L,I as _,J as q,g as r,w as d,K as B,y as w,E as y}from"./svg-fa97e243.js";const K=i(()=>{const a=P();H(a);const o=new I({packages:L,macros:{textsc:["\\style{font-variant-caps: small-caps}{\\text{#1}}",1]},inlineMath:[["$","$"],["\\(","\\)"]],processEscapes:!0,formatError:(n,c)=>{throw Error(c.message)}}),s=new _.SVG({fontCache:"none"}),e=q.mathjax.document("",{InputJax:o,OutputJax:s});return i(n=>{try{const c=e.convert(n,{});return w(c.firstChild)}catch(c){return d(c.message)}},"convert")},"mathjaxInit"),J=i(a=>{const o=/^(\d+(?:\.\d+)?)\s*(px|in|cm|mm)$/,s=a.match(o);if(!s)return;const e=parseFloat(s[1]),t=s[2];return{number:e,unit:t}},"parseFontSize"),j=i((a,o)=>({px:1,in:96,cm:37.79527559055118,mm:3.7795275590551185})[o]*a,"toPxFontSize"),k=i(async(a,o)=>new Promise(s=>{const e=r(a.string,""),t=r(a.fontSize,"");(t===""||e==="")&&s(d(`Label 'string' and 'fontSize' must be non-empty and non-optimized for ${a.name.contents}`));const n=o(e);if(n.isErr()){s(d(`MathJax could not render $${e}$: ${n.error}`));return}const c=n.value,h=c.getAttribute("viewBox");if(h===null){s(d(`No ViewBox found for MathJax output $${e}$`));return}const l=h.split(" "),m=parseFloat(l[2])/1e3,f=parseFloat(l[3])/1e3,p=-parseFloat(c.style.verticalAlign),v=parseFloat(c.getAttribute("height")),b=J(t);if(b){const{number:D,unit:A}=b,$=i(V=>V*j(D,A),"em_to_px"),F=$(m),x=$(f),S=p/v*x,M=x-S;s(w({body:c,width:F,height:x,descent:S,ascent:M}))}else{s(d('Invalid font size format. Only "px", "in", "cm", and "mm" units are supported.'));return}}),"tex2svg"),g=i(a=>({tag:"FloatV",contents:a}),"floatV"),T=i((a,o,s,e)=>({tag:"TextData",width:g(a),height:g(o),descent:g(s),ascent:g(e)}),"textData"),G=i((a,o,s,e,t)=>({tag:"EquationData",width:g(a),height:g(o),ascent:g(s),descent:g(e),rendered:t}),"equationData"),R=i(a=>{const o=r(a.fontFamily),s=r(a.fontSize),e=r(a.fontStretch),t=r(a.fontStyle),n=r(a.fontVariant),c=r(a.fontWeight),h=r(a.lineHeight),l=`${e} ${t} ${n} ${c} ${s} ${o}`;return h!==""?l.concat(`/${h}`):l},"toFontRule"),C=i(async(a,o)=>{const s=new Map;for(const e of a)if(e.shapeType==="Equation"){const t=r(e.name),n=await k(e,o);if(n.isErr())return d({errorType:"SubstanceError",tag:"Fatal",message:n.error});const{body:c,width:h,height:l,ascent:m,descent:f}=n.value,p=G(h===1/0?0:h,l===1/0?0:l,m,f,c);s.set(t,p)}else if(e.shapeType==="Text"){const t=r(e.name);let n;const c=N(r(e.string),R(e));c.width&&c.height?n=T(c.width,c.height,c.actualDescent,c.actualAscent):n=T(0,0,0,0),s.set(t,n)}else if(e.shapeType==="Group"){const t=B(e.shapes),n=await C(t,o);if(n.isErr())return n;for(const[c,h]of n.value.entries())s.set(c,h)}return w(s)},"collectLabels");function N(a,o){const s=document.createElement("canvas"),e=s.getContext("2d");e.textBaseline="alphabetic",e.font=o;const t=e.measureText(a);return s.remove(),{width:Math.abs(t.actualBoundingBoxLeft)+Math.abs(t.actualBoundingBoxRight),height:Math.abs(t.actualBoundingBoxAscent)+Math.abs(t.actualBoundingBoxDescent),actualDescent:Math.abs(t.actualBoundingBoxDescent),actualAscent:Math.abs(t.actualBoundingBoxAscent)}}i(N,"measureText");const u=i((a,o,s,e)=>{if(typeof s.contents!="number"&&s.contents.tag==="Var"){const{index:t,meta:n}=y(o.get(s.contents),"missing input");n.init.tag==="Pending"&&(a[t]=e.contents)}},"setPendingProperty"),E=i((a,o,s,e)=>{for(const t of a)if(t.shapeType==="Group"){const n=B(t.shapes);E(n,o,s,e)}else if(t.shapeType==="Equation"){const n=y(s.get(t.name.contents),"missing label");if(n.tag!=="EquationData")throw Error(`for ${t.shapeType} ${t.name.contents} got unexpected ${n.tag}`);u(o,e,t.width,n.width),u(o,e,t.height,n.height),u(o,e,t.ascent,n.ascent),u(o,e,t.descent,n.descent)}else if(t.shapeType==="Text"){const n=y(s.get(t.name.contents),"missing label");if(n.tag!=="TextData")throw Error(`for ${t.shapeType} ${t.name.contents} got unexpected ${n.tag}`);u(o,e,t.width,n.width),u(o,e,t.height,n.height),u(o,e,t.ascent,n.ascent),u(o,e,t.descent,n.descent)}},"insertPendingHelper"),Q=i(a=>{const o=[...a.varyingValues],s=new Map(a.inputs.map(({handle:e,meta:t},n)=>[e,{index:n,meta:t}]));return E(a.shapes,o,a.labelCache,s),{...a,varyingValues:o}},"insertPending");export{N as a,C as c,Q as i,K as m,R as t};
//# sourceMappingURL=CollectLabels-4815e2ab.js.map
