{"version":3,"file":"ray-tracing.domain-f94f6c03.js","sources":["../../../examples/dist/ray-tracing/ray-tracing.style.js","../../../examples/dist/ray-tracing/ray-tracing.domain.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"ray-tracing\");\nexport default \"-- first sample/compute the path, then place labels\\nlayout = [ tracingStage, labelingStage ]\\n\\ncanvas {\\n   width = 240\\n   height = 200\\n}\\n\\nglobal {\\n   scalar pointSize = 2\\n\\n   scalar arrowScale = 15.0\\n   scalar arrowThickness = 1.0\\n   string arrowShape = \\\"straight\\\"\\n   string arrowSize = .5\\n\\n   string rayLineDashing = \\\"4,3\\\"\\n   color rayLineColor = #000\\n   scalar rayLineWidth = 0.65\\n\\n   scalar eps = 0.1 -- offset distance (to prevent ray from intersecting origin)\\n\\n   color sceneColor = #ddd\\n   color sceneStrokeColor = #aaa\\n}\\n\\ncolors {\\n   color white = #ffffff\\n}\\n\\n-- Define the scene geometry.  You can uncomment one of the blocks\\n-- below, or design your own!  Currently Penrose does not support direct\\n-- import of SVG data for geometry that will be used in computation/optimization,\\n-- but if you want to extract a shape from a particular SVG polygon you can\\n-- open the .svg file and copy/paste the \\\"points\\\" attribute into the `points:`\\n-- field of a polygon (paying attention to formatting).\\nforall Scene S {\\n\\n   --------- Rectangular scene ---------\\n   -- shape S.geometry = Rectangle {\\n   --    center: (0,0)\\n   --    width: canvas.width - 30\\n   --    height: canvas.height - 30\\n   --    fillColor: global.sceneColor\\n   --    strokeColor: global.sceneStrokeColor\\n   --    strokeWidth: 1\\n   --    ensureOnCanvas: false\\n   -- }\\n\\n   --------- Polygonal scene ------------\\n   shape S.geometry = Polygon {\\n      points: [(-97,75.3), (-110.5,28.8), (-89.2,-93.1), (104.7,-84.1), (104.7,75.3), (43.8,95.7), (2.9,18.6), (28.5,-18.4), (-4.9,-44.8), (-41.2,6.9), (4.4,42.3), (-36.1,90.9)]\\n      fillColor: global.sceneColor\\n      strokeColor: global.sceneStrokeColor\\n      strokeWidth: 1\\n      ensureOnCanvas: false\\n   }\\n\\n   --------- Randomized polygonal scene ------------\\n   -- scalar maxPerturbation = 15\\n   -- vec2 p0 = maxPerturbation*diskRandom()\\n   -- vec2 p1 = maxPerturbation*diskRandom()\\n   -- vec2 p2 = maxPerturbation*diskRandom()\\n   -- vec2 p3 = maxPerturbation*diskRandom()\\n   -- vec2 p4 = maxPerturbation*diskRandom()\\n   -- vec2 p5 = maxPerturbation*diskRandom()\\n   -- scalar w = .8*canvas.width/2\\n   -- scalar h = .8*canvas.height/2\\n   -- shape S.geometry = Polygon {\\n   --    points: ( (w,-h)+p0, (0,-h)+p1, (-w,-h)+p2, (-w,h)+p3, (0,h)+p4, (w,h)+p5)\\n   --    fillColor: global.sceneColor\\n   --    strokeColor: global.sceneStrokeColor\\n   --    strokeWidth: 1\\n   --    ensureOnCanvas: false\\n   -- }\\n\\n   --------- Elliptical scene with holes ---------\\n   -- shape S.g1 = Ellipse {\\n   --    center: (0,0)\\n   --    rx: canvas.width/2.\\n   --    ry: canvas.height/2.\\n   --    fillColor: global.sceneColor\\n   --    strokeColor: global.sceneStrokeColor\\n   --    strokeWidth: 1\\n   --    ensureOnCanvas: false\\n   -- }\\n   -- shape S.g2 = Circle {\\n   --    center: (canvas.width/4,0)\\n   --    r: canvas.width/8.\\n   --    fillColor: #fff\\n   --    strokeColor: global.sceneStrokeColor\\n   --    strokeWidth: 1\\n   --    ensureOnCanvas: false\\n   -- }\\n   -- shape S.g3 = Circle {\\n   --    center: (-canvas.width/4,0)\\n   --    r: canvas.width/8.\\n   --    fillColor: #fff\\n   --    strokeColor: global.sceneStrokeColor\\n   --    strokeWidth: 1\\n   --    ensureOnCanvas: false\\n   -- }\\n   -- shape S.geometry = Group {\\n   --    shapes: [S.g1,S.g2,S.g3]\\n   -- }\\n}\\n\\n-- Draw each point as a black dot, and make sure that\\n-- it's drawn on top of the scene geometry.  Each point\\n-- will also keep track of a normal, which will be zero\\n-- if the point is on the scene interior (rather than its boundary).\\nforall Point p; Scene S {\\n   vec2 p.x = (?,?) -- location\\n   vec2 p.n = (0,0) -- normal\\n\\n   shape p.icon = Circle {\\n      center: p.x\\n      r: global.pointSize\\n      fillColor: #000\\n      ensureOnCanvas: false\\n   }\\n\\n   layer p.icon above S.geometry\\n}\\n\\n-- If a point has a label, render this label as TeX\\nforall Point p\\nwhere p has math label {\\n   shape p.labelText = Equation {\\n      string: p.label\\n      ensureOnCanvas: false\\n      fontSize: \\\"14px\\\"\\n      fillColor: #000\\n      strokeColor: \\\"#ffffff\\\"\\n      strokeWidth: 2.5\\n      paintOrder: \\\"stroke\\\"\\n      strokeLinejoin: \\\"round\\\"\\n   }\\n\\n   -- in the labeling stage of layout, try to put the label near the point\\n   encourage norm( p.labelText.center - p.x ) == 10 in labelingStage\\n\\n   -- draw the label in front of the dot, which is in turn in front\\n   -- of other things like the scene geometry\\n   layer p.labelText above p.icon\\n}\\n\\n-- Draw each ray as a little arrow.  Each ray keeps track of its\\n-- origin and direction.  Later, if rays are used to compute intersections,\\n-- we will also draw a line along the ray of intersection.\\nforall Ray r {\\n   vec2 r.o = (?,?) -- origin\\n   vec2 r.d = circleRandom() -- direction\\n\\n   shape r.icon = Line {\\n      start: r.o\\n      end: r.o + global.arrowScale*r.d\\n      strokeColor: #000\\n      strokeWidth: global.arrowThickness\\n      endArrowhead: global.arrowShape\\n      endArrowheadSize: global.arrowSize\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- Draw each light as a copy of the file `lightbulb.svg`.\\n-- (Feel free to use your own custom icon here!)\\nforall Light L {\\n   vec2 L.x = (?,?) -- location\\n\\n   shape L.icon = Image {\\n      center: L.x\\n      width: 27\\n      height: 41\\n      href: \\\"lightbulb.svg\\\"\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- Make sure the light is drawn in front of the scene geometry\\nforall Light L; Scene S {\\n   layer L.icon above S.geometry\\n}\\n\\n-- Draw a little icon for each camera.  This time, we'll draw the icon\\n-- using Style directly, just to show how it's done.  But in practice\\n-- you may find it easier to just import an SVG (as done for lights).\\nforall Camera C {\\n\\n   vec2 C.x = (?,?) -- center location\\n\\n   shape body = Rectangle {\\n      center: C.x\\n      width: 1.5*16\\n      height: 1.5*11\\n      fillColor: #aaa\\n      strokeColor: #666\\n      strokeWidth: 1\\n      cornerRadius: 2\\n      ensureOnCanvas: false\\n   }\\n   shape viewfinder = Rectangle {\\n      center: C.x + (0,body.height/2)\\n      width: .4*body.width\\n      height: .3*body.height\\n      fillColor: body.strokeColor\\n      cornerRadius: 2\\n      ensureOnCanvas: false\\n   }\\n   shape outerLens = Circle {\\n      center: C.x\\n      r: .38*body.height\\n      fillColor: #ccc\\n      strokeColor: body.strokeColor\\n      strokeWidth: body.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape C.innerLens = Circle {\\n      center: C.x\\n      r: .25*body.height\\n      fillColor: #227788\\n      strokeColor: body.strokeColor\\n      strokeWidth: body.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape flash = Circle {\\n      center: C.x + (body.width,body.height)/2 - (3,3)\\n      r: .07*body.height\\n      fillColor: #fff\\n      strokeColor: body.strokeColor\\n      strokeWidth: .8*body.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape shutterRelease = Rectangle {\\n      center: C.x + (-body.width/3,body.height/2)\\n      width: .1*body.width\\n      height: .15*body.height\\n      fillColor: body.strokeColor\\n      ensureOnCanvas: false\\n   }\\n\\n   layer viewfinder below body\\n   layer shutterRelease below body\\n\\n   shape C.icon = Group {\\n      shapes: [viewfinder,body,outerLens,C.innerLens,flash,shutterRelease]\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- Make sure the camera is placed somewhere in the scene, with some padding\\nforall Scene S; Camera C {\\n   layer C.icon above S.geometry\\n   ensure signedDistance( S.geometry, C.x ) < -20\\n}\\n\\n-- Make sure the light is placed somewhere in the scene, with some padding\\nforall Scene S; Light L {\\n   layer L.icon above S.geometry\\n   constraint L.inScene = ensure signedDistance( S.geometry, L.x ) < -20\\n}\\n\\n-- If a ray r comes from a point p, put the ray's origin at that point\\nforall Ray r; Point p\\nwhere r := rayFrom(p) {\\n   override r.o = p.x\\n}\\n\\n-- If we're shooting a ray from a point on the boundary,\\n-- sample the ray direction from the hemisphere around the\\n-- surface normal.\\nforall Ray r0; Ray r1; Point p; Scene S\\nwhere p := intersect(r0,S); r1 := rayFrom(p) {\\n   scalar thetaMax = .9*MathPI()/2\\n   scalar theta = thetaMax*random(-1,1)\\n   override r1.d = rotateBy( p.n, theta )\\n}\\n\\n-- If a ray hits a specular point, set the ray direction to\\n-- the normal direction, and draw a mirror icon.\\n-- a mirror icon.\\nforall Ray r0; Ray r1; Point p; Scene S\\nwhere p := intersect(r0,S); r1 := rayFrom(p); isSpecular(p) {\\n   override r1.d = p.n\\n\\n   scalar w = 15\\n   scalar h = 2\\n   vec2 t = rot90(p.n)\\n   vec2 m00 = p.x - w*t - h*p.n\\n   vec2 m01 = p.x - w*t + h*p.n\\n   vec2 m10 = p.x + w*t - h*p.n\\n   vec2 m11 = p.x + w*t + h*p.n\\n\\n   shape mirror = Polygon {\\n      points: [m00,m01,m11,m10]\\n      fillColor: #ccccff\\n      strokeColor: #bbbbff\\n      strokeWidth: 1\\n      ensureOnCanvas: false\\n   }\\n}\\n\\n-- If a point p is defined by a ray-scene intersection, shoot\\n-- a ray and update p's position and normal.  Also draw a line\\n-- along the ray, and the normal at the hit point.\\nforall Point p; Ray r; Scene S\\nwhere p := intersect(r,S) {\\n   vec2 o = r.o + global.eps*r.d\\n   override p.x = rayIntersect(S.geometry, o, r.d)\\n   override p.n = rayIntersectNormal(S.geometry, o, r.d)\\n\\n   shape r.rayLine = Line {\\n      start: r.o\\n      end: p.x\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayLineColor\\n      strokeWidth: global.rayLineWidth\\n      ensureOnCanvas: false\\n   }\\n\\n   shape normalArrow = Line {\\n      start: p.x\\n      end: p.x + global.arrowScale*p.n\\n      strokeColor: #5a5\\n      strokeWidth: global.arrowThickness\\n      endArrowhead: global.arrowShape\\n      endArrowheadSize: global.arrowSize\\n      ensureOnCanvas: false\\n   }\\n\\n   layer r.rayLine above S.geometry\\n   layer normalArrow above S.geometry\\n   layer p.icon above normalArrow\\n}\\n\\n-- If a ray is supposed to hit a light, we cheat: rather\\n-- than try to sample the whole path so that it hits the\\n-- light at this moment, just move the light to some point\\n-- along the final ray!  (In principle the same effect could\\n-- also be achieved via optimization, e.g., if the light\\n-- needs to be placed in one particular location in the diagram.)\\nforall Ray r; Light L; Scene S\\nwhere hitsLight(r,L) {\\n\\n   -- find the first hit point y along ray r\\n   vec2 o = r.o + global.eps*r.d -- offset by epsilon to avoid hitting the origin\\n   vec2 y = rayIntersect(S.geometry, o, r.d)\\n\\n   -- place the light halfway between the hit point and the ray origin\\n   -- (just so it's not too close to the scene boundary on either end)\\n   vec2 z = (y+o)/2\\n   override L.x = z\\n\\n   -- Since the light is now inside the scene by construction,\\n   -- we no longer need the constraint that ensures it's inside\\n   -- the scene geometry.  (Keeping this constraint can cause\\n   -- some funny behavior from the optimizer, since it's trying\\n   -- to optimize a point that's now fixed to a definite location.)\\n   delete L.inScene\\n\\n   shape r.rayLine = Line {\\n      start: r.o\\n      end: z\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayLineColor\\n      strokeWidth: global.rayLineWidth\\n      ensureOnCanvas: false\\n   }\\n\\n   layer r.rayLine above S.geometry\\n}\\n\\n-- Draw direct connections between points, lights, and/or cameras\\n-- as a dashed line (e.g., for connections between eye and light\\n-- subpaths in bidirectional path tracing).  If this connection\\n-- passes through the scene geometry, draw a red \\\"X\\\" at the first\\n-- intersection point.\\nforall Ray r; Entity p; Entity q; Scene S\\nwhere r := rayBetween(p,q) {\\n   override r.o = p.x\\n   override r.d = unit(q.x-p.x)\\n   shape r.rayLine = Line {\\n      start: p.x\\n      end: q.x\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayLineColor\\n      strokeWidth: global.rayLineWidth\\n      ensureOnCanvas: false\\n      style: \\\"dashed\\\"\\n      strokeDasharray: global.rayLineDashing\\n   }\\n   layer r.rayLine above S.geometry\\n\\n   -- don't draw an outgoing ray direction for a direct connection\\n   override r.icon.end = r.icon.start\\n   override r.icon.endArrowhead = \\\"none\\\"\\n\\n   -- check if there are any intersections along this ray,\\n   -- and draw a red \\\"X\\\" at the first intersection if so\\n   vec2 v = unit(q.x-p.x)\\n   vec2 y = rayIntersect(S.geometry, p.x + global.eps*v, v)\\n   scalar dy = norm(y-p.x)\\n   scalar dq = norm(q.x-p.x)\\n   scalar alpha = min( max(100*(dq-dy),0), 1 ) -- TODO should just expose ifCond in Style\\n   shape notVisible = Text {\\n      string: \\\"×\\\"\\n      center: y\\n      fillColor: rgba(1,0,0,alpha)\\n      fontSize: \\\"18px\\\"\\n      strokeColor: rgba(1,1,1,alpha)\\n      strokeWidth: 2\\n      paintOrder: \\\"stroke\\\"\\n      ensureOnCanvas: false\\n   }\\n   layer notVisible above S.geometry\\n}\\n\\n-- Make sure a point's label is not obscured by the camera\\nforall Point p; Camera C\\nwhere p has math label {\\n   layer p.labelText above C.icon\\n}\\n\\n-- If a point is on a camera, replace its location with the\\n-- camera's location, and hide its icon below the camera's icon.\\n-- Also set its normal to zero, since it's now an interior point.\\nforall Point p; Camera C\\nwhere onCamera(p,C) {\\n   override p.x = C.x\\n   override p.n = (0,0)\\n   layer p.icon below C.icon\\n}\\n\\n-- If a point is on a light, replace its location with the\\n-- camera's location, and hide its icon below the camera's icon.\\n-- Also set its normal to zero, since it's now an interior point.\\nforall Point p; Light L\\nwhere onLight(p,L) {\\n   override p.x = L.x\\n   override p.n = (0,0)\\n   layer p.icon below L.icon\\n}\\n\\n-- Draw ray arrows behind any camera\\nforall Ray r; Camera C {\\n   layer r.icon below C.icon\\n   layer r.rayLine below C.icon\\n}\\n\\n-- Draw ray arrows behind any light\\nforall Ray r; Light L {\\n   layer r.icon below L.icon\\n   layer r.rayLine below L.icon\\n}\\n\\n-- If a point is on the scene boundary, a good place to put its\\n-- label is outside the scene, offset in the normal direction away\\n-- from the point.\\nforall Scene S; Point p; Ray r\\nwhere p := intersect(r,S); p has label {\\n   override p.labelText.center = p.x - 10*p.n\\n}\\n\\n\";\n//# sourceMappingURL=ray-tracing.style.js.map","export default \"type Entity\\ntype Scene\\ntype Light <: Entity\\ntype Camera <: Entity\\ntype Point <: Entity\\ntype Ray\\n\\nconstructor rayFrom(Point p) -> Ray\\nconstructor rayBetween(Entity p, Entity q) -> Ray\\nconstructor intersect(Ray r, Scene S) -> Point\\n\\npredicate onCamera(Point p, Camera C)\\npredicate onLight(Point p, Light L)\\npredicate hitsLight(Ray r, Light L)\\npredicate isSpecular(Point p)\\n\\n\";\n//# sourceMappingURL=ray-tracing.domain.js.map"],"names":["resolver","makeResolver","style0","domain"],"mappings":"2CACY,MAACA,EAAWC,EAAa,aAAa,EAClDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}