{"version":3,"file":"methane-combustion.trio-1f382216.js","sources":["../../../examples/dist/structural-formula/reactions/methane-combustion.substance.js","../../../examples/dist/structural-formula/pseudo-3d-reaction.style.js","../../../examples/dist/structural-formula/reactions/methane-combustion.trio.js"],"sourcesContent":["export default \"AutoLabel All\\n\\n-- combustion reaction, expressed via structural-formula DSL\\n\\nReaction combustion\\nLabel combustion \\\"Methane Combustion Reaction\\\"\\nIsNetForward( combustion )\\n\\n-- reactants: CH4 + 2O2 ====================================\\nCarbon C1\\nHydrogen H1, H2, H3, H4\\nOxygen O1, O2, O3, O4\\n\\nMolecule methane\\nLabel methane $\\\\text{methane}\\\\ (\\\\mathrm{CH}_4)$\\nContains( methane, C1 )\\nContains( methane, H1 )\\nContains( methane, H2 )\\nContains( methane, H3 )\\nContains( methane, H4 )\\nSingleBond( C1, H1 )\\nSingleBond( C1, H2 )\\nSingleBond( C1, H3 )\\nSingleBond( C1, H4 )\\n\\nMolecule oxygen1, oxygen2\\nLabel oxygen1 $\\\\text{oxygen}\\\\ (\\\\mathrm{O}_2)$\\nLabel oxygen2 $\\\\text{oxygen}\\\\ (\\\\mathrm{O}_2)$\\nContains( oxygen1, O1 )\\nContains( oxygen1, O2 )\\nDoubleBond( O1, O2 )\\nContains( oxygen2, O3 )\\nContains( oxygen2, O4 )\\nDoubleBond( O3, O4 )\\n\\nIsReactant( methane )\\nIsReactant( oxygen1 )\\nIsReactant( oxygen2 )\\n\\n-- products: CO2 + 2H20 ====================================\\nCarbon C2\\nHydrogen H5, H6, H7, H8\\nOxygen O5, O6, O7, O8\\n\\nMolecule carbonDioxide\\nLabel carbonDioxide $\\\\text{carbon dioxide}\\\\ (\\\\mathrm{CO}_2)$\\nContains( carbonDioxide, C2 )\\nContains( carbonDioxide, O5 )\\nContains( carbonDioxide, O6 )\\nDoubleBond( C2, O5 )\\nDoubleBond( C2, O6 )\\n\\nMolecule water1, water2\\nLabel water1 $\\\\text{water}\\\\ (\\\\mathrm{H}_2\\\\mathrm{O})$\\nLabel water2 $\\\\text{water}\\\\ (\\\\mathrm{H}_2\\\\mathrm{O})$\\nContains( water1, O7 )\\nContains( water1, H5 )\\nContains( water1, H6 )\\nSingleBond( O7, H5 )\\nSingleBond( O7, H6 )\\nContains( water2, O8 )\\nContains( water2, H7 )\\nContains( water2, H8 )\\nSingleBond( O8, H7 )\\nSingleBond( O8, H8 )\\n\\nIsProduct( carbonDioxide )\\nIsProduct( water1 )\\nIsProduct( water2 )\\n\\n\";\n//# sourceMappingURL=methane-combustion.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"structural-formula\");\nexport default \"-- TODO would be really helpful to be able to join multiple\\n-- .style files---currently we are maintaining parallel edits\\n-- across both pseudo-3d.style and pseudo-3d-reaction.style\\n\\ncanvas {\\n   scalar width  = 1248.\\n   scalar height = 702.\\n}\\n\\nColors {\\n   vec4 clear     = rgba( 0., 0., 0., 0. )\\n   vec4 black     = rgba( 0., 0., 0., 1. )\\n   vec4 gray      = rgba( .5, .5, .5, 1. )\\n   vec4 lightGray = rgba( .9, .9, .9, 1. )\\n   vec4 white     = rgba( 1., 1., 1., 1. )\\n   vec4 red       = rgba( 1., 0., 0., 1. )\\n   vec4 green     = rgba( 0., .7, 0., 1. )\\n   vec4 blue      = rgba( 0., 0., 1., 1. )\\n   vec4 darkRed   = rgba( .7, 0., 0., 1. )\\n   vec4 darkBlue  = rgba( 0., 0., .7, 1. )\\n   vec4 purple    = rgba( .66, .36, .95, 1. )\\n   vec4 turquoise  = rgba( .1, .7, .6, 1. )\\n}\\n\\nGlobal {\\n   scalar atomRadius = 25.\\n   scalar bondLength = 60.\\n\\n   scalar padding = 50.\\n\\n   -- specify the typeface(s) that should\\n   -- be used, in order of availability\\n   string fontFamily = \\\"Palatino, Palatino Linotype, Palatino LT STD, Book Antiqua, Georgia, serif\\\"\\n\\n   -- box around the whole canvas\\n   shape bbox = Rectangle {\\n      width : canvas.width\\n      height : canvas.height\\n      center : (0.,0.)\\n      fillColor : Colors.clear\\n      strokeColor : Colors.gray\\n      strokeWidth : 8\\n   }\\n\\n   scalar reactionBoxSize = .75 * canvas.width/2.\\n   scalar reactionBoxTop = reactionBoxSize/2.\\n   scalar reactionBoxBottom = -reactionBoxSize/2.\\n\\n   -- box around reactants\\n   scalar reactantCenter = -canvas.width/4.\\n   shape reactantBox = Rectangle {\\n      width : reactionBoxSize\\n      height : reactionBoxSize\\n      center : (reactantCenter,0.)\\n      fillColor : rgba( 0., 0., 0., .1 )\\n      strokeColor : Colors.clear\\n      strokeWidth : 12\\n      cornerRadius : 20\\n   }\\n   shape reactantText = Text {\\n      string : \\\"reactants\\\"\\n      center : (reactantCenter,-24.+reactionBoxBottom) -- TODO make issue about non-commutativity of + here\\n      fillColor : Colors.black\\n      fontSize : \\\"30px\\\"\\n      fontFamily: Global.fontFamily\\n      fontWeight: \\\"bold\\\"\\n   }\\n\\n   -- box around products\\n   scalar productCenter = canvas.width/4.\\n   scalar productTop = .75*canvas.width/4.\\n   shape productBox = Rectangle {\\n      width : reactionBoxSize\\n      height : reactionBoxSize\\n      center : (productCenter,0.)\\n      fillColor : rgba( 0., 0., 0., .1 )\\n      strokeColor : Colors.clear\\n      strokeWidth : 12\\n      cornerRadius : 20\\n   }\\n   shape productText = Text {\\n      string : \\\"products\\\"\\n      center : (productCenter,-24.+reactionBoxBottom)\\n      fillColor : Colors.black\\n      fontSize : \\\"30px\\\"\\n      fontFamily: Global.fontFamily\\n      fontWeight: \\\"bold\\\"\\n   }\\n}\\n\\nforall Node n {\\n\\n   scalar cx = ?\\n   scalar cy = ?\\n   vec2 n.center = (cx,cy)\\n\\n   scalar R = Global.atomRadius\\n\\n   shape n.icon = Circle {\\n      r : R\\n      center : n.center\\n      fillColor : Colors.white\\n      strokeColor : Colors.black\\n      strokeWidth : 3.\\n   }\\n\\n   shape n.shadow = Ellipse {\\n      rx : 2.*Global.atomRadius\\n      ry : Global.atomRadius\\n      center : (cx,cy) + (0.,-2.*R)\\n      fillColor : rgba( .95, .95, .95, 1. )\\n      strokeColor : Colors.clear\\n      strokeWidth : 3.\\n   }\\n\\n   shape n.text = Text {\\n      string : n.label\\n      center : n.center\\n      fillColor : Colors.black\\n      fontSize : \\\"17.5px\\\"\\n   }\\n\\n   ensure contains( Global.bbox, n.icon )\\n\\n   layer n.icon below n.text\\n}\\n\\n-- make sure shadows are drawn below all molecules\\nforall Node n1; Node n2 {\\n   layer n1.shadow below n2.icon\\n   layer n2.shadow below n1.icon\\n}\\n\\n-- draw functional groups as boxes\\nforall FunctionalGroup g {\\n   override g.icon.fillColor = Colors.clear\\n   override g.icon.strokeColor = Colors.clear\\n   override g.text.fillColor = Colors.black\\n   override g.shadow.fillColor = Colors.clear\\n\\n   g.box = Rectangle {\\n      center : g.center\\n      width : 3.*Global.atomRadius\\n      height : 1.5*Global.atomRadius\\n      fillColor : Colors.lightGray\\n      strokeColor : Colors.gray\\n      strokeWidth : 3.\\n      cornerRadius : 10.\\n   }\\n\\n   layer g.shadow below g.box\\n}\\n\\nforall Oxygen a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.red\\n   override a.text.fillColor = Colors.white\\n   override a.text.string = \\\"\\\"\\n}\\n\\nforall Carbon a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.black\\n   override a.text.fillColor = Colors.white\\n   override a.text.string = \\\"\\\"\\n}\\n\\nforall Nitrogen a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.blue\\n   override a.text.fillColor = Colors.white\\n   override a.text.string = \\\"\\\"\\n}\\n\\nforall Hydrogen a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.gray\\n   override a.text.fillColor = Colors.black\\n   override a.text.string = \\\"\\\"\\n\\n   -- make hydrogen atoms (and their shadows) smaller\\n   override a.icon.r = .75*Global.atomRadius\\n   override a.shadow.rx = .75*2.*Global.atomRadius\\n   override a.shadow.ry = .75*Global.atomRadius\\n}\\n\\nforall Chlorine a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.green\\n   override a.text.fillColor = Colors.white\\n   override a.text.string = \\\"\\\"\\n}\\n\\nforall Sodium a {\\n   override a.icon.fillColor = Colors.white\\n   override a.icon.strokeColor = Colors.purple\\n   override a.text.fillColor = Colors.white\\n   override a.text.string = \\\"\\\"\\n}\\n\\n\\nforall Node n1; Node n2\\nwhere SingleBond( n1, n2 ) {\\n\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   vec2 u = unit(x1-x2)\\n   scalar r = Global.atomRadius\\n\\n   shape line = Line {\\n      start : x1 - .5*r*u\\n        end : x2 + .5*r*u\\n      strokeWidth : 10.\\n      strokeColor : Colors.turquoise\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   shape innerLine = Line {\\n      start : x1 - .5*r*u\\n        end : x2 + .5*r*u\\n      strokeWidth : 4.\\n      strokeColor : Colors.white\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   encourage equal( norm(x1-x2), Global.bondLength )\\n\\n   layer line above n2.icon\\n   layer innerLine above line\\n   layer innerLine below n1.icon\\n}\\n\\nforall Node n1; Node n2\\nwhere DoubleBond( n1, n2 ) {\\n\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   vec2 u = unit(x1-x2)\\n   vec2 v = ( -u[1], u[0] )\\n   scalar r = Global.atomRadius\\n\\n   shape line1 = Line {\\n      start : x1 - .5*r*u - .25*r*v\\n        end : x2 + .5*r*u - .25*r*v\\n      strokeWidth : 10.\\n      strokeColor : Colors.turquoise\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   shape innerLine1 = Line {\\n      start : x1 - .5*r*u - .25*r*v\\n        end : x2 + .5*r*u - .25*r*v\\n      strokeWidth : 4.\\n      strokeColor : Colors.white\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   shape line2 = Line {\\n      start : x1 - .5*r*u + .25*r*v\\n        end : x2 + .5*r*u + .25*r*v\\n      strokeWidth : 10.\\n      strokeColor : Colors.turquoise\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   shape innerLine2 = Line {\\n      start : x1 - .5*r*u + .25*r*v\\n        end : x2 + .5*r*u + .25*r*v\\n      strokeWidth : 4.\\n      strokeColor : Colors.white\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   encourage equal( norm(x1-x2), Global.bondLength )\\n\\n   layer line1 above n2.icon\\n   layer innerLine1 above line1\\n   layer innerLine1 below n1.icon\\n\\n   layer line2 above n2.icon\\n   layer innerLine2 above line2\\n   layer innerLine2 below n1.icon\\n\\n   layer line2 above innerLine1\\n}\\n\\nforall Node n1; Node n2\\nwhere IonicBond( n1, n2 ) {\\n\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   vec2 u = unit(x1-x2)\\n   scalar r = Global.atomRadius\\n\\n   shape line = Line {\\n      start : x1 - .5*r*u\\n        end : x2 + .5*r*u\\n      strokeWidth : 2.5\\n      strokeColor : Colors.turquoise\\n      strokeLinecap: \\\"butt\\\"\\n      style: \\\"dashed\\\"\\n   }\\n\\n   encourage equal( norm(x1-x2), Global.bondLength )\\n\\n   layer line below n1.icon\\n   layer line below n2.icon\\n}\\n\\n\\n-- make bonds with hydrogen shorter\\nforall Node n; Hydrogen h\\nwhere SingleBond(n,h) {\\n   vec2 x1 = n.center\\n   vec2 x2 = h.center\\n   encourage equal( 2.*norm(x1-x2), .5*Global.bondLength )\\n}\\n\\n-- give common molecules a physical bond angle\\nforall Oxygen o; Hydrogen h1; Hydrogen h2 -- water (H2O)\\nwhere SingleBond(o,h1); SingleBond(o,h2) { -- TODO make an issue about symmetry of predicate matches\\n   vec2 a = o.center\\n   vec2 b = h1.center\\n   vec2 c = h2.center\\n   encourage equal( angleBetween(b-a,c-a), toRadians(104.5) )\\n}\\nforall Carbon c0; Oxygen o1; Oxygen o2 -- carbon dioxide (CO2)\\nwhere DoubleBond(c0,o1); DoubleBond(c0,o2) {\\n   vec2 a = c0.center\\n   vec2 b = o1.center\\n   vec2 c = o2.center\\n   encourage equal( angleBetween(b-a,c-a), toRadians(180.) )\\n}\\n\\n-- use a Coulomb-like force to prevent nodes from overlapping\\n-- (but only worry about nodes in the same reactant/product box)\\nforall Molecule m; Node n1; Node n2\\nwhere IsReactant(m); Contains(m,n1); Contains(m,n2) {\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   encourage equal( 200000./normsq(x1-x2), 0. )\\n}\\nforall Molecule m1; Molecule m2; Node n1; Node n2\\nwhere IsReactant(m1); IsReactant(m2); Contains(m1,n1); Contains(m2,n2) {\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   encourage equal( 200000./normsq(x1-x2), 0. )\\n}\\nforall Molecule m; Node n1; Node n2\\nwhere IsProduct(m); Contains(m,n1); Contains(m,n2) {\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   encourage equal( 200000./normsq(x1-x2), 0. )\\n}\\nforall Molecule m1; Molecule m2; Node n1; Node n2\\nwhere IsProduct(m1); IsProduct(m2); Contains(m1,n1); Contains(m2,n2) {\\n   vec2 x1 = n1.center\\n   vec2 x2 = n2.center\\n   encourage equal( 200000./normsq(x1-x2), 0. )\\n}\\n\\n\\n-- place a label near the Nodes in each Molecule\\nforall Molecule m {\\n\\n   -- m.box = Rectangle {\\n   --    center : (?,?)\\n   --    fillColor : Colors.clear\\n   -- }\\n\\n   m.labelCenter = (?,?)\\n\\n   m.text = Equation {\\n      string : m.label\\n      fillColor : Colors.black\\n      fontSize : \\\"22.5px\\\"\\n      center : m.labelCenter\\n      --center : m.box.center - (0.,3.*Global.atomRadius)\\n      -- TODO add stroke (have to expose SVG text stroke in Penrose renderer)\\n   }\\n\\n   -- used to prevent overlap with molecules\\n   -- (since \\\"ensure disjoint\\\" isn't currently supported for Equation-Circle pairs)\\n   scalar R = 20.\\n   m.textPhantom1 = Circle {\\n      center : m.labelCenter\\n      r : R\\n      fillColor : Colors.clear\\n      strokeColor : Colors.clear\\n      strokeWidth : 3.\\n   }\\n   m.textPhantom2 = Circle {\\n      center : m.labelCenter + (2.*R,0.)\\n      r : R\\n      fillColor : Colors.clear\\n      strokeColor : Colors.clear\\n      strokeWidth : 3.\\n   }\\n   m.textPhantom3 = Circle {\\n      center : m.labelCenter - (2.*R,0.)\\n      r : R\\n      fillColor : Colors.clear\\n      strokeColor : Colors.clear\\n      strokeWidth : 3.\\n   }\\n}\\nforall Molecule m; Node n\\nwhere Contains(m,n) {\\n   --override m.box.center = n.icon.center\\n   encourage near( m.text, n.icon )\\n   ensure disjoint( m.textPhantom1, n.icon )\\n   ensure disjoint( m.textPhantom2, n.icon )\\n   ensure disjoint( m.textPhantom3, n.icon )\\n   layer m.text above n.icon\\n}\\n\\nforall Reaction r {\\n\\n   scalar h = (Global.reactionBoxTop + canvas.height/2.)/2.\\n\\n   r.text = Text {\\n      string : r.label\\n      center : (0.,h)\\n      fontSize : \\\"50px\\\"\\n      fontFamily: Global.fontFamily\\n      fontVariant: \\\"small-caps\\\"\\n      fillColor : Colors.black\\n   }\\n}\\n\\n-- put all reactants on the left\\nforall Molecule m; Node n\\nwhere IsReactant(m); Contains(m,n) {\\n   ensure contains( Global.reactantBox, n.icon, Global.padding )\\n   ensure contains( Global.reactantBox, m.text, Global.padding )\\n   layer n.icon above Global.reactantBox\\n   layer n.shadow below Global.reactantBox\\n}\\n\\n-- put all products on the right\\nforall Molecule m; Node n\\nwhere IsProduct(m); Contains(m,n) {\\n   ensure contains( Global.productBox, n.icon, Global.padding )\\n   ensure contains( Global.productBox, m.text, Global.padding )\\n   layer n.icon above Global.productBox\\n   layer n.shadow below Global.productBox\\n}\\n\\nforall Reaction r\\nwhere IsNetForward(r) {\\n\\n   vec2 Rc = Global.reactantCenter\\n   vec2 Pc = Global.productCenter\\n   scalar s = Global.reactionBoxSize\\n   scalar p = 10.\\n\\n   shape reactionArrow = Line {\\n      start : (Rc+(0.5*s)+p,0.)\\n      end : (Pc-(0.5*s)-p,0.)\\n      strokeColor : Colors.black\\n      strokeWidth : 5.\\n      endArrowhead : \\\"straight\\\"\\n      endArrowheadSize : .5\\n   }\\n}\\n\\n\";\n//# sourceMappingURL=pseudo-3d-reaction.style.js.map","import substance from \"./methane-combustion.substance.js\";\nimport style0, { resolver as resolver0 } from \"../pseudo-3d-reaction.style.js\";\nimport domain from \"../structural-formula.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"\",\n    excludeWarnings: []\n};\n//# sourceMappingURL=methane-combustion.trio.js.map"],"names":["substance","resolver","makeResolver","style0","methaneCombustion_trio","resolver0","domain"],"mappings":"oIAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,oBAAoB,EACzDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCAC,EAAA,CACX,UAAAJ,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUE,CAAW,CAC5C,EACD,OAAAC,EACA,UAAW,GACX,gBAAiB,CAAE,CACvB"}