{"version":3,"file":"euclidean.style-71fbf884.js","sources":["../../../examples/dist/geometry-domain/euclidean.style.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"geometry-domain\");\nexport default \"canvas {\\n  width = 500\\n  height = 500\\n}\\n\\nColors {\\n    -- Keenan palette\\n    black = #000000\\n    darkpurple = #8c90c1\\n    lightpurple = #d0d3e6\\n    purple2 = rgba(0.106, 0.122, 0.54, 0.2)\\n    verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)\\n    purple3 = rgba(0.557, 0.627, 0.769, 1.0)\\n    midnightblue = rgba(0.14, 0.16, 0.52, 1.0)\\n    none = none()\\n}\\n\\nconst {\\n    arrowheadSize = 0.65\\n    strokeWidth = 1.75\\n    textPadding = 10.0\\n    textPadding2 = 25.0\\n    repelWeight = 0.7 -- TODO: Reverted from 0.0\\n    repelWeight2 = 0.5\\n    fontSize = \\\"20px\\\"\\n    containPadding = 50.0\\n    rayLength = 100.0\\n    pointRadius = 4.0\\n    pointStroke = 0.0\\n    thetaRadius = 30.0\\n    circleRadius = 150.0\\n    labelPadding = 30.0\\n    minSegmentLength = 80.0\\n    minLineLength = 200.0\\n}\\n\\nlayout = [shape, label]\\n\\n--Plane\\nforall Plane p {\\n  width = canvas.width * .8\\n  height = canvas.height * .8\\n  p.text = Equation {\\n    center : ((width / 2.0) - const.textPadding2, (height / 2.0) - const.textPadding2)\\n    string : p.label\\n    fontSize : const.fontSize\\n  }\\n\\n  -- inner: #f3f4f9, outer: #8e93c4\\n  p.icon = Rectangle {\\n    -- angle : 0.0\\n    -- fillColor : Colors.purple2\\n    fillColor : Colors.none -- TODO: arrange angle markers so plane can be opaque\\n    strokeColor : Colors.purple3\\n    strokeWidth : 2.0\\n    center : (0.0, 0.0)\\n    width : width\\n    height : height\\n  }\\n\\n  p.text above p.icon\\n}\\n\\n--Point\\nforall Point p {\\n  p.x = ? except label\\n  p.y = ? except label\\n  p.vec = (p.x, p.y)\\n  p.color = Colors.black\\n\\n  p.icon = Circle {\\n    center: p.vec\\n    r : const.pointRadius\\n    fillColor : Colors.black\\n    strokeWidth : 0.0\\n    strokeColor : Colors.black\\n  }\\n\\n  p.text = Equation {\\n    string : p.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n    center: (? in label, ? in label)\\n    ensureOnCanvas: false\\n  }\\n  ensure onCanvas(p.text, canvas.width, canvas.height) in label\\n  ensure signedDistance(p.text, p.vec) == const.textPadding + const.pointRadius in label\\n}\\n\\n-- default: if `Point` is not on a `Plane`, the point should be below the plane to stay hidden\\nforall Point p\\nwith Plane P {\\n  p.iconOnPlane = ensure disjoint(p.icon, P.icon)\\n  p.textOnPlane = ensure disjoint(p.text, P.icon) in label\\n}\\n\\nforall Point p\\nwith Plane P\\nwhere In(p, P) {\\n  -- TODO: the problem is that this ensures the padding is const? Or is > padding okay?\\n  -- There's a choice of whether to put padding on the point or the text for containment\\n  override p.iconOnPlane = ensure contains(P.icon, p.icon, const.containPadding)\\n  override p.textOnPlane = ensure contains(P.icon, p.text) in label\\n\\n  p.icon above P.icon\\n  p.text above P.icon\\n}\\n\\nforall Point p, q, r\\nwhere Collinear(p, q, r) {\\n  ensure collinearOrdered(p.icon.center, q.icon.center, r.icon.center) \\n  encourage notTooClose(p.icon, r.icon, const.repelWeight)\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l) {\\n  ensure signedDistance(l.icon, p.vec) == 0\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l); p has label {\\n  ensure disjoint(l.icon, p.text) in label\\n}\\n\\n--Linelike\\nforall Linelike l {\\n  l.color = Colors.black\\n\\n  l.icon = Line {\\n    start : (?, ?)\\n    end : (?, ?)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Ray r\\nwhere r := Ray(base, direction)\\nwith Point base; Point direction {\\n  r.start = base.vec\\n  r.end = direction.vec\\n  r.vec = direction.vec - base.vec\\n\\n  override r.icon = Line {\\n    start : base.icon.center\\n    end : ptOnLine(base.vec, direction.vec, norm(r.vec) + 40.)\\n    strokeColor : r.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n  -- labeling\\n  ensure disjoint(r.icon, base.text) in label\\n  ensure disjoint(r.icon, direction.text) in label\\n}\\n\\nforall Ray r {\\n    r.length = const.rayLength\\n}\\n\\nforall Ray r\\nwith Angle theta; Point x; Point y; Point z\\nwhere r := Bisector(theta); theta := InteriorAngle(y, x, z) {\\n  -- find the vector for the bisector ray\\n  xy = normalize(y.vec - x.vec)\\n  xz = normalize(z.vec - x.vec)\\n  r_vec = xy + xz\\n  -- change from generic `Linelike` shape to a specific shape for `Ray`\\n  override r.icon = Line {\\n    start: x.vec\\n    end:  (r.length * normalize(r_vec)) + x.vec\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n  }\\n  r.icon below x.icon\\n}\\n\\nforall Line l\\nwhere l := Line(p, q)\\nwith Point p; Point q {\\n  l.start = p.vec\\n  l.end = q.vec\\n  l.vec = q.vec - p.vec\\n  override l.icon = Line {\\n    start : ptOnLine(p.vec,q.vec, -40.)\\n    end : ptOnLine(p.vec, q.vec, norm(l.vec) + 40.)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    startArrowhead: \\\"straight\\\"\\n    startArrowheadSize: const.arrowheadSize\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n\\n  -- edge case\\n  ensure norm(l.vec) > const.minLineLength\\n\\n  -- labeling\\n  ensure disjoint(l.icon, p.text) in label\\n  ensure disjoint(l.icon, q.text) in label\\n}\\n\\nforall Linelike l1, l2 -- should this work with rays and lines?\\nwhere ParallelMarker1(l1, l2) {\\n  l1.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l1.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n  l2.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l2.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Linelike l1, l2\\nwhere Parallel(l1, l2) {\\n  -- the dot product of the unit vectors of parallel lines is 1\\n  -- HACK: scaling to 10000s for convergence\\n  ensure 10000 == dot(normalize(l1.vec), normalize(l2.vec)) * 10000\\n}\\n--Segment\\nforall Segment e\\nwhere e := Segment(p, q)\\nwith Point p; Point q {\\n  e.vec = [q.x - p.x, q.y - p.y]\\n  e.start = p.vec\\n  e.end = q.vec\\n\\n  override e.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : e.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above e.icon\\n  q.icon above e.icon\\n\\n  -- edge case\\n  ensure norm(e.vec) > const.minSegmentLength\\n\\n  -- labeling\\n  ensure disjoint(p.text, e.icon) in label\\n  ensure disjoint(q.text, e.icon) in label\\n}\\n\\nforall Segment e; Plane p {\\n  e.icon above p.icon\\n}\\n\\nforall Linelike s, t\\nwhere EqualLength(s, t) {\\n  ensure vdist(s.icon.start, s.icon.end) == vdist(t.icon.start, t.icon.end)\\n}\\n\\n--TODO eventually this should also provide an equal length marker since it is bisecting the segment\\nforall Segment s\\nwhere s := PerpendicularBisector(s2, p)\\nwith Segment s2; Point p {\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : midpoint(s2.icon.start, s2.icon.end)\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Segment s\\nwhere s := PerpendicularBisectorLabelPts(s2, p1, p2)\\nwith Segment s2; Point p1, p2 {\\n  override p2.vec = midpoint(s2.icon.start, s2.icon.end)\\n  override s.icon = Line {\\n    start : p1.icon.center\\n    end : p2.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Linelike s, t \\nwhere EqualLengthMarker(s, t) as e {\\n  e.equivGroup = match_id\\n  override s.tick = Path {\\n    d : ticksOnLine(s.icon.start, s.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  override t.tick = Path {\\n    d : ticksOnLine(t.icon.start, t.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  s.tick above s.icon\\n  t.tick above t.icon\\n}\\n\\n-- HACK: set transitive equal marks to have the same amount of ticks. This will not decrement subsequent matches of `EqualLength`, so only use this when there are _only_ transitive equal marks in a diagram\\nforall Linelike s, t, u\\nwhere EqualLengthMarker(s, t) as e1; EqualLengthMarker(t, u) as e2 {\\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\\n  -- NOTE: since we cannot handle transitive predicates and don't allow recursive expressions, we override the shape properties so the tick counts are the same\\n  override s.tick.d = ticksOnLine(s.icon.start, s.icon.end, 15., minEquivGroup, 10.) \\n  override u.tick.d = ticksOnLine(u.icon.start, u.icon.end, 15., minEquivGroup, 10.) \\n  override t.tick.d = ticksOnLine(t.icon.start, t.icon.end, 15., minEquivGroup, 10.) \\n}\\n\\n--Angle\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r)\\nwith Point p; Point q; Point r {\\n  theta.p = p.vec\\n  theta.q = q.vec\\n  theta.r = r.vec\\n  theta.color = #000\\n  theta.side1 = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  theta.side2 = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  \\n  theta.radius = const.thetaRadius\\n  -- encourage the angle to be bigger than 10\\n  angle = angleBetween(theta.q - theta.p, theta.q - theta.r) \\n  ensure angle > 10/180 * MathPI()\\n  theta.side1 below p.icon, q.icon\\n  theta.side2 below q.icon, r.icon\\n}\\n\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r); theta has label\\nwith Point p; Point q; Point r {\\n  padding = const.textPadding + const.pointRadius + theta.text.width\\n  labelDir = normalize((p.vec - q.vec) + (r.vec - q.vec))\\n  theta.text = Equation {\\n    string : theta.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n    center: q.vec + labelDir*padding\\n  }\\n}\\n\\nforall Angle a, b\\nwhere EqualAngleMarker(a, b) as e {\\n  e.equivGroup = match_id\\n  --find points from p->q, then q->r for each vector. draw vectors for each\\n  a.start = ptOnLine(a.q, a.p, a.radius)\\n  a.end = ptOnLine(a.q, a.r, a.radius)\\n  a.sweep = arcSweepFlag(a.q, a.start, a.end)\\n  a.spacing = 10\\n\\n  b.start = ptOnLine(b.q, b.p, b.radius)\\n  b.end = ptOnLine(b.q, b.r, b.radius)\\n  b.sweep = arcSweepFlag(b.q, b.start, b.end)\\n  b.spacing = 10\\n\\n  override a.mark = Path {\\n    d : repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), e.equivGroup, a.spacing, a.sweep)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n  override b.mark = Path {\\n    d : repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), e.equivGroup, b.spacing, b.sweep)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n}\\n\\nforall Angle a, b, c\\nwhere EqualAngleMarker(a, b) as e1; EqualAngleMarker(b, c) as e2 {\\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\\n  override a.mark.d = repeatedArcs(a.start, a.end, a.p, a.r, (a.radius, a.radius), minEquivGroup, a.spacing, a.sweep)\\n  override b.mark.d = repeatedArcs(b.start, b.end, b.p, b.r, (b.radius, b.radius), minEquivGroup, b.spacing, b.sweep)\\n  override c.mark.d = repeatedArcs(c.start, c.end, c.p, c.r, (c.radius, c.radius), minEquivGroup, c.spacing, c.sweep)\\n}\\n\\nforall Angle a, b\\nwhere EqualAngle(a, b) {\\n  -- make sure angle a is equal to angle b\\n  -- HACK: increase the magnitude of angles\\n  weight = 100\\n  angleA = angleBetween(a.p - a.q, a.r - a.q) * weight\\n  angleB = angleBetween(b.p - b.q, b.r - b.q) * weight\\n  ensure angleA == angleB \\n}\\n\\nforall Angle a\\nwhere RightUnmarked(a) {\\n  -- ensure perpendicular(a.p, a.q, a.r)\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure dot(u, v) == 0\\n}\\n\\nforall Angle a\\nwhere RightMarked(a) {\\n  --render half square path of size a.radius\\n  markSize = 10\\n  a.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(a.q, a.p, markSize), innerPointOffset(a.q, a.p, a.r, markSize), ptOnLine(a.q, a.r, markSize)])\\n    strokeWidth : 2.0\\n    strokeColor : #000\\n    fillColor : Colors.none\\n  }\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure dot(u, v) == 0\\n}\\n\\nforall Angle a\\nwhere Acute(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), 0, MathPI()/2)\\n}\\n\\nforall Angle a\\nwhere Obtuse(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), MathPI()/2, MathPI())\\n}\\n\\nforall Triangle t; Plane P \\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.PQ above P.icon\\n  t.QR above P.icon\\n  t.RP above P.icon\\n  t.icon above P.icon\\n}\\n\\nforall Triangle t\\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.color = Colors.black\\n  t.PQ = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.QR = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.RP = Line {\\n    start : r.icon.center\\n    end : p.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.icon = Path {\\n    d: pathFromPoints(\\\"closed\\\", [p.vec, q.vec, r.vec])\\n    fillColor: none()\\n    strokeColor: none()\\n  }\\n  ensure norm(p.vec - q.vec) > const.minSegmentLength\\n  ensure norm(q.vec - r.vec) > const.minSegmentLength\\n  ensure norm(r.vec - p.vec) > const.minSegmentLength\\n  ensure disjoint(t.icon, p.text) in label\\n  ensure disjoint(t.icon, q.text) in label\\n  ensure disjoint(t.icon, r.text) in label\\n\\n  t.PQ below p.icon\\n  t.PQ below q.icon\\n  t.QR below q.icon\\n  t.QR below r.icon\\n  t.RP below r.icon\\n  t.RP below p.icon\\n}\\n\\nforall Point p\\nwith Triangle T; Point t1, t2, t3\\nwhere T := Triangle(t1, t2, t3); Incenter(p, T) {\\n  override p.vec = incenter(t1.vec, t2.vec, t3.vec)\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.incenterIcon = Circle {\\n    center : p.vec\\n    r : inradius(t1.vec, t2.vec, t3.vec) - const.strokeWidth\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    strokeStyle: \\\"dashed\\\"\\n    fillColor : Colors.none\\n  }\\n  T.incenterIcon below t1.icon\\n  T.incenterIcon below t2.icon\\n  T.incenterIcon below t3.icon\\n}\\n\\nforall Point p\\nwhere Circumcenter(p, T)\\nwith Triangle T {\\n  clr = Colors.darkpurple\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  p.icon above T.PQ\\n  p.icon above T.QR\\n  p.icon above T.RP\\n  T.icon = Circle {\\n    center : p.vec\\n    r : ?\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : Colors.none\\n    strokeStyle: \\\"dashed\\\"\\n  }\\n  ensure norm(T.PQ.start - p.vec) == T.icon.r\\n  ensure norm(T.QR.start - p.vec) == T.icon.r\\n  ensure norm(T.RP.start - p.vec) == T.icon.r\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.QR.start)\\n  encourage repelPt(const.repelWeight, T.QR.start, T.RP.start)\\n}\\n\\nforall Point p\\nwhere Centroid(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  override p.vec = vmul(1/3, T.PQ.start + T.QR.start + T.RP.start)\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  override T.icon = Line {\\n    start : T.PQ.start\\n    end : midpoint(T.QR.start, T.QR.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.line2 = Line {\\n    start : T.QR.start\\n    end : midpoint(T.RP.start, T.RP.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.icon3 = Line {\\n    start : T.RP.start\\n    end : midpoint(T.PQ.start, T.PQ.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere Orthocenter(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.icon = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon2 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon3 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  -- TODO make it so that predicates can reference other predicates. 3/4 of these are copy-pasted from the Collinear predicate\\n  ensure collinear(T.PQ.start, T.icon.start, T.PQ.end)\\n  ensure collinear(T.QR.start, T.icon2.start, T.QR.end)  \\n  ensure collinear(T.RP.start, T.icon3.start, T.RP.end)\\n\\n  ensure perpendicular(T.PQ.start, T.icon.start, p.vec)\\n  ensure perpendicular(T.QR.start, T.icon2.start, p.vec)  \\n  ensure perpendicular(T.RP.start, T.icon3.start, p.vec)\\n\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.icon.start)\\n  encourage repelPt(const.repelWeight, T.PQ.end, T.icon.start)\\n\\n  encourage repelPt(const.repelWeight, T.QR.start, T.icon2.start)\\n  encourage repelPt(const.repelWeight, T.QR.end, T.icon2.start)\\n\\n  encourage repelPt(const.repelWeight, T.RP.start, T.icon3.start)\\n  encourage repelPt(const.repelWeight, T.RP.end, T.icon3.start)\\n\\n}\\n\\n--Rectangle\\n-- -- Should the rectangle be constructed from the points, or vice versa?\\nforall Rectangle R\\nwhere R := Rectangle(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  override R.color = Colors.none\\n  override R.icon = Path {\\n      d : pathFromPoints(\\\"closed\\\", [p.icon.center, q.icon.center, r.icon.center, s.icon.center])\\n      strokeWidth : const.strokeWidth\\n      fillColor : R.color\\n      strokeColor : Colors.black\\n    }\\n  ensure vdist(p.icon.center, q.icon.center) == vdist(r.icon.center, s.icon.center)\\n  ensure vdist(p.icon.center, s.icon.center) == vdist(q.icon.center, r.icon.center)\\n\\n  ensure perpendicular(p.icon.center, q.icon.center, r.icon.center)\\n  ensure perpendicular(q.icon.center, s.icon.center, r.icon.center)\\n\\n  -- R.icon above P.icon\\n}\\n\\nforall Quadrilateral Q\\nwhere Q := Quadrilateral(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  Q.p = p.icon.center\\n  Q.q = q.icon.center\\n  Q.r = r.icon.center\\n  Q.s = s.icon.center\\n\\n  override Q.color = Colors.black\\n  Q.side1 = Line {\\n    start : Q.p\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side2 = Line {\\n    start : Q.r\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side3 = Line {\\n    start : Q.s\\n    end : Q.r\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side4 = Line {\\n    start : Q.p\\n    end : Q.s\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }  \\n  Q.labelContainer = Path {\\n    d: pathFromPoints(\\\"closed\\\", [Q.p, Q.q, Q.r, Q.s])\\n    fillColor: none()\\n  }\\n  -- TODO: check if the points actually have labels\\n  ensure disjoint(p.text, Q.labelContainer) in label\\n  ensure disjoint(q.text, Q.labelContainer) in label\\n  ensure disjoint(r.text, Q.labelContainer) in label\\n  ensure disjoint(s.text, Q.labelContainer) in label\\n  -- ensure all sides are visible\\n  ensure norm(Q.p - Q.q) > const.minSegmentLength\\n  ensure norm(Q.q - Q.r) > const.minSegmentLength\\n  ensure norm(Q.r - Q.s) > const.minSegmentLength\\n  ensure norm(Q.s - Q.p) > const.minSegmentLength\\n  ensure norm(Q.r - Q.p) > const.minSegmentLength\\n  ensure norm(Q.s - Q.q) > const.minSegmentLength\\n}\\n\\n--FUNCTIONS\\nforall Segment s\\nwith Triangle T; Point p, q, r, a, b\\nwhere s := MidSegment(T, a, b); T := Triangle(p, q, r) {\\n  override a.vec = midpoint(q.vec, r.vec)\\n  override b.vec = midpoint(r.vec, p.vec)\\n  override s.icon = Line {\\n    start : a.vec\\n    end : b.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere p := Midpoint(l)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p); p has label\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n  ensure disjoint(p.text, l.icon) in label\\n}\\n\\n-- TODO sometimes bisector becomes a scaled version of either side length PQ or QR of angle PQR\\nforall Linelike s\\nwhere AngleBisector(a, s)\\nwith Angle a; Point p {\\n  weight = 100\\n  angleA = angleBetween(a.p - a.q, s.end - a.q) * weight\\n  angleB = angleBetween(s.end - a.q, a.r - a.q) * weight\\n  bigAngle = angleBetween(a.q - a.p, a.q - a.r) * weight\\n  ensure angleA == angleB \\n  -- HACK: make sure the angle itself is not zero\\n  ensure bigAngle > 15/180 * MathPI() * weight \\n  -- HACK: make sure the bisector end point is between angle end points. Might be too specific\\n  ensure inRange(s.end[0], a.p[0], a.r[0])\\n  ensure inRange(s.end[1], a.p[1], a.r[1])\\n}\\n\\nforall Circle c {\\n  c.radius = const.circleRadius\\n  c.vec = (?, ?)\\n\\n  c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Circle c\\nwhere c := CircleR(p, q)\\nwith Point p, q {\\n  override c.radius = vdist(p.vec, q.vec)\\n  override c.vec = p.icon.center\\n  override c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\n-- TODO this can be reimplemented when issue #621 is resolved\\n-- Circle c\\n-- where c := CircleD(p, q)\\n-- with Point p, q {\\n--   override c.radius = vdist(p.vec, q.vec) / 2\\n-- }\\n\\nforall Segment s\\nwhere s := Chord(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure norm(p.vec - c.vec) == c.radius\\n  ensure norm(q.vec - c.vec) == c.radius\\n  ensure norm(q.vec - p.vec) > const.minSegmentLength\\n}\\n\\nforall Segment s\\nwhere s := Chord(c, p, q); p has label; q has label \\nwith Circle c; Point p, q {\\n  ensure disjoint(c.icon, p.text) in label\\n  ensure disjoint(c.icon, q.text) in label\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p)\\nwith Circle c; Point p {\\n  override s.vec = p.vec - c.vec\\n  override s.icon = Line {\\n    start : c.vec\\n    end : p.icon.center\\n    strokeColor : Colors.black\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  p.icon above c.icon\\n  ensure norm(c.vec - p.vec) == c.radius\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p); p has label \\nwith Circle c; Point p {\\n  ensure disjoint(p.text, s.icon) in label\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p); p has label\\nwith Circle c; Point p {\\n  ensure disjoint(p.text, c.icon) in label\\n}\\n\\nforall Segment s\\nwhere s := Diameter(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    strokeColor : Colors.black\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure norm(midpoint(p.vec, q.vec) - c.icon.center) == 0\\n  ensure c.icon.r * 2 == norm(s.vec)\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p)\\nwith Circle c {\\n  ensure norm(c.vec - p.vec) == c.radius\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p); p has label\\nwith Circle c {\\n  ensure disjoint(p.text, c.icon) in label\\n}\\n\\nforall Point p\\nwhere CircleCenter(c, p)\\nwith Circle c {\\n  override p.vec = c.vec\\n}\\n\\nforall Shape s1, s2\\nwhere s1 has label; s2 has label {\\n  encourage notTooClose(s1.text, s2.text)\\n}\";\n//# sourceMappingURL=euclidean.style.js.map"],"names":["resolver","makeResolver","style0"],"mappings":"2CACY,MAACA,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}