{"version":3,"file":"test.trio-0af18210.js","sources":["../../../examples/dist/geometric-queries/test.substance.js","../../../examples/dist/geometric-queries/geometric-queries.style.js","../../../examples/dist/geometric-queries/geometric-queries.domain.js","../../../examples/dist/geometric-queries/test.trio.js"],"sourcesContent":["export default \"-- For each shape, draw the result of each geometric query (closest ray\\n-- intersection, closest point, and closest silhouette point).\\n\\n-- Circle\\nCircle C\\nPoint pC\\nRay rC\\nrC := rayFrom(pC)\\nPoint aC := rayIntersect(C,rC)\\nPoint bC := closestPoint(C,pC)\\nPoint cC := closestSilhouettePoint(C,pC)\\n\\n-- Rectangle\\nRectangle R\\nPoint pR\\nRay rR\\nrR := rayFrom(pR)\\nPoint aR := rayIntersect(R,rR)\\nPoint bR := closestPoint(R,pR)\\nPoint cR := closestSilhouettePoint(R,pR)\\n\\n-- Ellipse\\nEllipse E\\nPoint pE\\nRay rE\\nrE := rayFrom(pE)\\nPoint aE := rayIntersect(E,rE)\\nPoint bE := closestPoint(E,pE)\\nPoint cE := closestSilhouettePoint(E,pE)\\n\\n-- Polygon\\nPolygon P\\nPoint pP\\nRay rP\\nrP := rayFrom(pP)\\nPoint aP := rayIntersect(P,rP)\\nPoint bP := closestPoint(P,pP)\\nPoint cP := closestSilhouettePoint(P,pP)\\n\\n-- Line\\nLine L\\nPoint pL\\nRay rL\\nrL := rayFrom(pL)\\nPoint aL := rayIntersect(L,rL)\\nPoint bL := closestPoint(L,pL)\\nPoint cL := closestSilhouettePoint(L,pL)\\n\\n-- Polyline\\nPolyline M\\nPoint pM\\nRay rM\\nrM := rayFrom(pM)\\nPoint aM := rayIntersect(M,rM)\\nPoint bM := closestPoint(M,pM)\\nPoint cM := closestSilhouettePoint(M,pM)\\n\\n\";\n//# sourceMappingURL=test.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"geometric-queries\");\nexport default \"canvas {\\n   width = 800\\n   height = 700\\n}\\n\\nglobal {\\n   color shapeColor = #0003\\n   color closestColor = #66d\\n   color silhouetteColor = #0a0\\n   color rayColor = #ff6600\\n   color labelColor = #000\\n   color labelStrokeColor = #fff\\n   color labelStrokeWidth = 6\\n   color labelFont = \\\"monospace\\\"\\n   color labelFontSize = \\\"24px\\\"\\n   scalar labelFontSizeS = 24\\n\\n   scalar strokeWidth = 2\\n   scalar arrowSize = 40\\n   scalar arrowWidth = 2.5\\n   scalar perpSize = 14\\n\\n   scalar boxWidth = canvas.width/3\\n   scalar boxHeight = (canvas.height - 50)/2\\n   scalar boxPadding = 20\\n}\\n\\nlegend {\\n   scalar H = canvas.height\\n   scalar W = canvas.width\\n   scalar pad = global.boxPadding\\n\\n   scalar x0 = -W/2+pad\\n   scalar y0 = H/2 - pad\\n\\n   shape queryShape = Rectangle {\\n      center: (x0,y0)\\n      width: 30\\n      height: 30\\n      fillColor: global.shapeColor\\n      ensureOnCanvas: false\\n   }\\n   shape queryShapeLabel = Text {\\n      string: \\\"shape\\\"\\n      center: queryShape.center + (25,0)\\n      fontSize: \\\"18px\\\"\\n      fillColor: #000\\n      ensureOnCanvas: false\\n      fontWeight: \\\"bold\\\"\\n      fontFamily: \\\"sans-serif\\\"\\n      textAnchor: \\\"start\\\"\\n   }\\n\\n   scalar x1 = x0 + 110\\n   shape closestLine = Line {\\n      start: (x1,y0)\\n      end: (x1 + 40,y0)\\n      fill: \\\"none\\\"\\n      strokeColor: global.closestColor\\n      strokeWidth: 2*global.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape closestLineLabel = Text {\\n      string: \\\"closest point\\\"\\n      center: closestLine.end + (10,0)\\n      fontSize: \\\"18px\\\"\\n      fillColor: global.closestColor\\n      ensureOnCanvas: false\\n      fontWeight: \\\"bold\\\"\\n      fontFamily: \\\"sans-serif\\\"\\n      textAnchor: \\\"start\\\"\\n   }\\n\\n   scalar x2 = x1 + 195\\n   shape silhouetteLine = Line {\\n      start: (x2,y0)\\n      end: (x2 + 40,y0)\\n      fill: \\\"none\\\"\\n      strokeColor: global.silhouetteColor\\n      strokeWidth: 2*global.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape silhouetteLineLabel = Text {\\n      string: \\\"closest silhouette point\\\"\\n      center: silhouetteLine.end + (10,0)\\n      fontSize: \\\"18px\\\"\\n      fillColor: global.silhouetteColor\\n      ensureOnCanvas: false\\n      fontWeight: \\\"bold\\\"\\n      fontFamily: \\\"sans-serif\\\"\\n      textAnchor: \\\"start\\\"\\n   }\\n\\n   scalar x3 = x2 + 290\\n   shape rayLine = Line {\\n      start: (x3,y0)\\n      end: (x3 + 40,y0)\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayColor\\n      strokeWidth: 2*global.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n   shape rayLineLabel = Text {\\n      string: \\\"ray intersection\\\"\\n      center: rayLine.end + (10,0)\\n      fontSize: \\\"18px\\\"\\n      fillColor: global.rayColor\\n      ensureOnCanvas: false\\n      fontWeight: \\\"bold\\\"\\n      fontFamily: \\\"sans-serif\\\"\\n      textAnchor: \\\"start\\\"\\n   }\\n}\\n\\n-- Rules for drawing each type of shape\\n\\nforall Point p {\\n   vec2 p.x = (?,?) -- location\\n\\n   shape p.icon = Circle {\\n      center: p.x\\n      r: 5\\n      strokeWidth: 1\\n      fillColor: #000000ff\\n      ensureOnCanvas: false\\n   } \\n}\\n\\nforall Ray r {\\n   vec2 r.o = (?,?) -- origin\\n   vec2 r.d = circleRandom() -- direction\\n\\n   r.icon = Line {\\n      start: r.o\\n      end: r.o + global.arrowSize*r.d\\n      strokeColor: #000\\n      strokeWidth: global.arrowWidth\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Point p; Ray r\\nwhere r := rayFrom(p) {\\n   override r.o = p.x\\n}\\n\\nforall Shape S {\\n   shape S.box = Rectangle {\\n      center: (?,?)\\n      width: global.boxWidth\\n      height: global.boxHeight\\n      fillColor: rgba(.9,.9,.9,1)\\n      strokeColor: #fff\\n      strokeWidth: 4\\n      ensureOnCanvas: false\\n   }\\n\\n   shape S.boxLabel = Text {\\n      string: \\\"Shape\\\"\\n      center: ( S.box.center[0], S.box.center[1] + global.boxHeight/2 - global.labelFontSizeS/2 - global.boxPadding )\\n      ensureOnCanvas: false\\n      fillColor: global.labelColor\\n      fontFamily: global.labelFont\\n      fontSize: global.labelFontSize\\n      strokeWidth: global.labelStrokeWidth\\n      strokeColor: global.labelStrokeColor\\n      paintOrder: \\\"stroke\\\"\\n   }\\n}\\n\\nforall Line L {\\n   shape L.icon = Line {\\n      start: (?,?)\\n      end: (?,?)\\n      strokeWidth: 5\\n      strokeColor: global.shapeColor\\n      fill: \\\"none\\\"\\n   }\\n\\n   override L.boxLabel.string = \\\"Line\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override L.box.center = (-W+w,-H+h)/2 + (w,h)\\n}\\n\\nforall Rectangle R {\\n   shape R.icon = Rectangle {\\n      center: (?, ?)\\n      width: random(40,150)\\n      height: random(40,150)\\n      strokeWidth: 1\\n      fillColor: global.shapeColor\\n   }\\n\\n   override R.boxLabel.string = \\\"Rectangle\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override R.box.center = (-W+w,-H+h)/2 + (w,0)\\n}\\n\\nforall Polyline M {\\n   vec2 p0 = (?,?)\\n   vec2 p1 = p0 + 50*circleRandom()\\n   vec2 p2 = p1 + 50*rotateBy(unit(p1-p0),random(0,1.5))\\n   vec2 p3 = p2 + 50*rotateBy(unit(p2-p1),random(0,1.5))\\n   vec2 p4 = p3 + 50*rotateBy(unit(p3-p2),random(-1.5,0))\\n   \\n   shape M.icon = Polyline {\\n      points: [ p0, p1, p2, p3, p4 ]\\n      strokeWidth: 5.0\\n      strokeLinejoin: \\\"round\\\"\\n      strokeColor: global.shapeColor\\n   }\\n\\n   override M.boxLabel.string = \\\"Polyline\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override M.box.center = (-W+w,-H+h)/2 + (2*w,h)\\n}\\n\\nforall Polygon P {\\n   vec2 c = (?,?)\\n   scalar d = random(50,100)\\n   scalar u = circleRandom()\\n   scalar v = rot90(u)\\n   vec2 p0 = c + d*u\\n   vec2 p2 = c - d*u\\n   vec2 p1 = c + random(-50,50)*u + random(30,80)*v\\n   vec2 p3 = c + random(-50,50)*u - random(30,80)*v\\n\\n   shape P.icon = Polygon {\\n      points: [ p0, p1, p2, p3 ]\\n      fillColor: global.shapeColor\\n   }\\n\\n   override P.boxLabel.string = \\\"Polygon\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override P.box.center = (-W+w,-H+h)/2 + (0,h)\\n}\\n\\nforall Circle C {\\n   shape C.icon = Circle {\\n      center: (?,?)\\n      r: random(30,80)\\n      fillColor: global.shapeColor\\n   }\\n\\n   override C.boxLabel.string = \\\"Circle\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override C.box.center = (-W+w,-H+h)/2\\n}\\n\\nforall Point q; Shape S; Point p\\nwhere q := closestPoint(S,p) {\\n   ensure contains( S.box, p.icon, global.boxPadding )\\n}\\n\\nforall Ellipse E {\\n   shape E.icon = Ellipse {\\n      center: (?,?)\\n      rx: random(20,100)\\n      ry: random(20,100)\\n      fillColor: global.shapeColor\\n   }\\n\\n   override E.boxLabel.string = \\\"Ellipse\\\"\\n   scalar W = canvas.width\\n   scalar H = canvas.height\\n   scalar w = global.boxWidth\\n   scalar h = global.boxHeight\\n   override E.box.center = (-W+w,-H+h)/2 + (2*w,0)\\n}\\n\\nforall Shape S {\\n   ensure contains( S.box, S.icon, global.boxPadding )\\n   override S.icon.ensureOnCanvas = false\\n}\\n\\n-- Rules for geometric queries\\n\\nforall Point q; Shape S; Point p\\nwhere q := closestPoint(S,p)\\n{\\n   vec2 y = closestPoint( S.icon, p.x )\\n\\n   override q.x = y\\n   override q.icon.fillColor = #fff\\n   override q.icon.strokeColor = global.closestColor\\n   override q.icon.strokeWidth = global.strokeWidth\\n   override q.icon.ensureOnCanvas = false\\n\\n   shape q.querySegment = Line {\\n      start: p.x\\n      end: y\\n      strokeColor: global.closestColor\\n      strokeWidth: global.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Point q; Shape S; Point p\\nwhere q := closestSilhouettePoint(S,p)\\n{\\n   vec2 y = closestSilhouettePoint( S.icon, p.x )\\n\\n   override q.x = y\\n   override q.icon.fillColor = #fff\\n   override q.icon.strokeColor = global.silhouetteColor\\n   override q.icon.strokeWidth = global.strokeWidth\\n   override q.icon.ensureOnCanvas = false\\n\\n   shape q.querySegment = Line {\\n      start: p.x\\n      end: y\\n      strokeColor: global.silhouetteColor\\n      strokeWidth: global.strokeWidth\\n      ensureOnCanvas: false\\n   }\\n}\\n\\nforall Point q; Shape S; Ray r\\nwhere q := rayIntersect(S,r)\\n{\\n   -- encourage more frequent hits by pointing the ray into the box\\n   override r.d = unit(S.box.center - r.o)\\n\\n   vec2 y = rayIntersect( S.icon, r.o, r.d )\\n   vec2 q.n = rayIntersectNormal( S.icon, r.o, r.d )\\n\\n   override q.x = y\\n   override q.icon.fillColor = #fff\\n   override q.icon.strokeColor = global.rayColor\\n   override q.icon.strokeWidth = global.strokeWidth\\n   override q.icon.ensureOnCanvas = false\\n\\n   shape q.raySegment = Line {\\n      start: r.o\\n      end: y\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayColor\\n      strokeWidth: global.strokeWidth\\n      style: \\\"dashed\\\"\\n      strokeDasharray: \\\"8,6\\\"\\n      ensureOnCanvas: false\\n   }\\n\\n   shape q.normalArrow = Line {\\n      start: y\\n      end: y + global.arrowSize*q.n\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayColor\\n      strokeWidth: global.arrowWidth\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5 * norm(q.n)\\n      ensureOnCanvas: false\\n   }\\n\\n   vec2 u = global.perpSize*q.n\\n   vec2 v = global.perpSize*rot90(q.n)\\n   vec2 r.h = (0,0)\\n   shape perpMark = Polyline {\\n      points: [ y+u+r.h, y+u+v+r.h, y+v+r.h ]\\n      ensureOnCanvas: false\\n      fill: \\\"none\\\"\\n      strokeColor: global.rayColor\\n      strokeWidth: global.strokeWidth\\n   }\\n}\\n\\nforall Point q; Conic C; Ray r\\nwhere q := rayIntersect(C,r) {\\n   override r.h = -.15*global.perpSize*q.n\\n}\\n\\n-- Layering\\n\\nforall Shape S {\\n   layer S.icon above S.box\\n}\\n\\nforall Point p; Shape S {\\n   layer p.icon above S.icon\\n}\\n\\nforall Ray r; Shape S {\\n   layer r.icon above S.box\\n}\\n\\nforall Point q; Shape S; Point p\\nwhere q := closestPoint(S,p) {\\n   layer p.icon above q.querySegment\\n   layer q.icon above q.querySegment\\n}\\n\\nforall Point q; Shape S; Point p\\nwhere q := closestSilhouettePoint(S,p) {\\n   layer p.icon above q.querySegment\\n   layer q.icon above q.querySegment\\n}\\n\\nforall Point p; Ray r {\\n   layer p.icon above r.icon\\n}\\n\\nforall Point p; Point q; Ray r; Shape S\\nwhere q := rayIntersect(S,r) {\\n   layer q.icon above q.normalArrow\\n   layer q.icon above q.raySegment\\n}\\n\\nforall Point q; Ray r; Shape S\\nwhere q := rayIntersect(S,r) {\\n   layer r.icon above q.raySegment\\n}\\n\\n\";\n//# sourceMappingURL=geometric-queries.style.js.map","export default \"type Point\\ntype Ray\\n\\ntype Shape\\ntype Conic <: Shape\\ntype Line <: Shape\\ntype Polyline <: Shape\\ntype Polygon <: Shape\\ntype Rectangle <: Shape\\ntype Circle <: Conic\\ntype Ellipse <: Conic\\n\\nfunction rayFrom(Point p) -> Ray r\\nconstructor rayIntersect(Shape S, Ray r) -> Point q\\nconstructor closestPoint(Shape S, Point p) -> Point q\\nconstructor closestSilhouettePoint(Shape S, Point p) -> Point q\\n\\n\";\n//# sourceMappingURL=geometric-queries.domain.js.map","import substance from \"./test.substance.js\";\nimport style0, { resolver as resolver0 } from \"./geometric-queries.style.js\";\nimport domain from \"./geometric-queries.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"MettwurstCattle35745\",\n    excludeWarnings: [\"BBoxApproximationWarning\"]\n};\n//# sourceMappingURL=test.trio.js.map"],"names":["substance","resolver","makeResolver","style0","domain","test_trio","resolver0"],"mappings":"wEAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCFC,EAAWC,EAAa,mBAAmB,EACxDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECGAC,EAAA,CACX,UAAAL,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAF,EACA,UAAW,uBACX,gBAAiB,CAAC,0BAA0B,CAChD"}