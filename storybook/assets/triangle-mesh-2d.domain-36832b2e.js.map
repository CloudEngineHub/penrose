{"version":3,"file":"triangle-mesh-2d.domain-36832b2e.js","sources":["../../../examples/dist/triangle-mesh-2d/triangle-mesh-2d.style.js","../../../examples/dist/triangle-mesh-2d/triangle-mesh-2d.domain.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"triangle-mesh-2d\");\nexport default \"layout = [shapes, labels]\\n\\ncanvas {\\n   width = 480\\n   height = 360\\n}\\n\\nColors {\\n   color black = rgba(0.,0.,0.,1.)\\n   color red = rgba(1.,0.,0.,1.)\\n   color green = rgba(0.,.7,0.,1.)\\n   color blue = rgba(0.,0,1.,1.)\\n   color white = rgba(1.,1.,1.,1.)\\n   color lightGray = rgba(.8,.8,.8,1.)\\n   color clear = rgba(0.,0.,0.,0.)\\n   color darkBlue = rgba( 27./255., 31./255., 138./255., 1. )\\n   color semiBlue = rgba( 27./255., 31./255., 138./255., .2 )\\n}\\n\\nGlobal {\\n   scalar vertexRadius = 2.5\\n   scalar pointRadius = 2.0\\n   scalar lineThickness = 1.\\n   scalar labelBoundRadius = 8.\\n   scalar lineOffset = 8.0\\n   scalar wedgeSize = 30.0\\n\\n   shape box = Rectangle {\\n      center: (0.,0.)\\n      fillColor: none()\\n      strokeWidth: 2.\\n      width: canvas.width\\n      height: canvas.height\\n   }\\n\\n   -- string fontFamily = \\\"Linux Libertine O\\\"\\n   string fontFamily = \\\"Palatino\\\"\\n   string fontSize = \\\"18px\\\"\\n}\\n\\nforall Vertex v {\\n\\n   vec2 v.center = (?,?)\\n\\n   -- black dot\\n   shape v.icon = Circle {\\n      fillColor: Colors.black\\n      r: Global.vertexRadius\\n      center: v.center\\n   }\\n\\n   -- make sure the dot is on the canvas\\n   constraint v.onCanvas = ensure contains( Global.box, v.icon )\\n}\\n\\nforall Vertex v\\nwhere v has label {\\n\\n   v.labelAngle = ? in labels\\n   v.labelRadius = ? in labels\\n\\n   -- label\\n   shape v.text = Text {\\n      center: v.icon.center + v.labelRadius*( cos(v.labelAngle), sin(v.labelAngle ) )\\n      string: v.label\\n      fontFamily: Global.fontFamily\\n      fontSize: Global.fontSize\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Colors.black\\n   }\\n\\n   -- make sure label doesn't get too far from the dot\\n   ensure inRange( v.labelRadius, 1.02*Global.labelBoundRadius, 1.1*Global.labelBoundRadius ) in labels\\n\\n   -- invisible circle around label\\n   -- (used to prevent overlap)\\n   -- TODO requires #741 to use actual text bounding box instead\\n   shape v.bounds = Circle {\\n      center: v.text.center\\n      r: Global.labelBoundRadius\\n      fillColor: none()\\n   }\\n\\n   -- make sure the label is on the canvas\\n   ensure contains( Global.box, v.bounds ) in labels\\n\\n   -- keep the label near the dot\\n   encourage equal( norm(v.text.center - v.icon.center), Global.labelBoundRadius ) in labels\\n}\\n\\n-- make sure vertex labels don't overlap\\nforall Vertex u; Vertex v\\nwhere u has label; v has label { -- requires #774 to replace with \\\"where u has label; v has label\\\"; currently hacked-in using predicate in Domain program\\n   ensure disjoint( u.bounds, v.bounds ) in labels\\n}\\n\\nforall Edge e; Vertex i; Vertex j\\nwhere e := MakeEdge(i,j) {\\n\\n   -- grab edge endpoints\\n   vec2 pi = i.icon.center\\n   vec2 pj = j.icon.center\\n   \\n   -- black line between endpoints\\n   shape e.segment = Line {\\n      start: pi\\n      end: pj\\n      strokeColor: Colors.black\\n      strokeWidth: Global.lineThickness\\n      strokeLinecap: \\\"round\\\"\\n   }\\n\\n   -- (DEBUG) draw full line through segment\\n   -- vec2 m = (pi+pj)/2.\\n   -- shape e.line = Line {\\n   --    start: m + 100.*(pi-m)\\n   --    end: m + 100.*(pj-m)\\n   --    strokeColor: rgba( 0., 0., 0., .35 )\\n   --    strokeWidth: Global.lineThickness\\n   --    style: \\\"dashed\\\"\\n   --    strokeDasharray: \\\"4,4\\\"\\n   -- }\\n}\\n\\nforall Edge e; Vertex i; Vertex j\\nwhere e := MakeEdge(i,j); i has label; j has label {\\n   -- make sure edge doesn't cover the\\n   -- labels of its two endpoints\\n   ensure disjoint( i.bounds, e.segment, 1. ) in labels\\n   ensure disjoint( j.bounds, e.segment, 1. ) in labels\\n}\\n\\nforall Edge e\\nwhere IsBoundaryEdge( e ) {\\n   override e.segment.strokeWidth = 1.5*Global.lineThickness\\n}\\n\\n-- make sure no edge ij covers the label of\\n-- any other vertex k\\nforall Edge e; Vertex i; Vertex j; Vertex k\\nwhere e := MakeEdge(i,j); k has label {\\n   \\n   ensure disjoint( k.bounds, e.segment, 1. ) in labels\\n}\\n\\nforall Triangle t; Vertex i; Vertex j; Vertex k\\nwhere t := MakeTriangle(i,j,k)\\n{\\n   vec2 a = i.icon.center\\n   vec2 b = j.icon.center\\n   vec2 c = k.icon.center\\n\\n   -- Define circles associated with each triangle, even\\n   -- if they're never used, so that they can be easily\\n   -- referenced by other rules.  (The overhead here is\\n   -- minimal, especially because we don't need to\\n   -- differentiate through these quantities unless they\\n   -- are explicitly incorporated into some later ensure/\\n   -- encourage statement.\\n   vec2 t.circumcenter = circumcenter(a,b,c)\\n   scalar t.circumradius = circumradius(a,b,c)\\n   vec2 t.incenter = incenter(a,b,c)\\n   scalar t.inradius = inradius(a,b,c)\\n\\n   shape t.icon = Path {\\n      d: pathFromPoints(\\\"closed\\\", [a,b,c])\\n      fillColor: Colors.semiBlue\\n      strokeColor: none()\\n   }\\n\\n   -- Make sure triangles are positively\\n   -- oriented and not tiny, by making their\\n   -- signed area greater than some fixed constant.\\n   scalar A = cross2D( b-a, c-a )\\n   objective t.positiveArea = encourage lessThan( 4000., A )\\n\\n   -- Also ensure triangles are not slivers by making\\n   -- sure two of their angles are in a reasonable range\\n   -- (the third will of course make the sum equal to 180)\\n   scalar aTheta = angleFrom( b-a, c-a )\\n   scalar bTheta = angleFrom( c-b, a-b )\\n   constraint t.goodAngleA = ensure inRange( aTheta, toRadians(40.), toRadians(80.) ) in labels\\n   constraint t.goodAngleB = ensure inRange( bTheta, toRadians(40.), toRadians(80.) ) in labels\\n}\\n\\nforall Corner c; Vertex i; Vertex j; Vertex k\\nwhere c := MakeCorner(i,j,k) {\\n\\n   vec2 p = i.center\\n   vec2 q = j.center\\n   vec2 r = k.center\\n   \\n   scalar s = .25 -- arc radius as fraction of edge length\\n   scalar c.R = Global.wedgeSize -- s*norm(q-p)\\n   vec2 c.u = (q-p)/norm(q-p)\\n   vec2 c.v = (r-p)/norm(r-p)\\n   vec2 x = p + c.R*c.u\\n   vec2 y = p + c.R*c.v\\n\\n   -- for use in later constraints\\n   c.wedgeAngle = angleBetween( q-p, r-p )\\n\\n   shape c.arc = Path {\\n      fillColor: none()\\n      strokeColor: Colors.black\\n      d: arc( \\\"open\\\", x, y, (c.R,c.R), 0., 0, 0 )\\n      strokeWidth: .75\\n   }\\n\\n   shape c.arcFill = Path {\\n      d: wedge( i.center, x, y, (c.R,c.R), 0., 0, 0 )\\n      fillColor: Colors.semiBlue\\n      strokeColor: none()\\n   }\\n\\n   shape c.arcBall = Circle {\\n      center: i.center\\n      r: c.R\\n      fillColor: none()\\n      strokeColor: none()\\n   }\\n}\\n\\nforall Corner c; Vertex i; Vertex j; Vertex k\\nwhere c := MakeCorner(i,j,k); c has text label {\\n\\n   vec2 c.center = (?,?)\\n   vec2 p = i.center\\n   scalar R0 = Global.labelBoundRadius\\n\\n   shape c.text = Text {\\n      string: c.label\\n      center: c.center\\n      fontSize: Global.fontSize\\n      fontFamily: Global.fontFamily\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Colors.black\\n   }\\n\\n   -- shape c.text = Text {\\n   --    string: c.label\\n   --    center: p + (c.R+R0)*unit(c.u+c.v)\\n   --    fontSize: Global.fontSize\\n   --    fontFamily: Global.fontFamily\\n   --    fontStyle: \\\"italic\\\"\\n   --    fillColor: Colors.black\\n   -- }\\n\\n   shape c.textBounds = Circle {\\n      center: c.text.center\\n      r: 1.1 * .5 * max(c.text.width, c.text.height)\\n      fillColor: none()\\n   }\\n\\n   vec2 w = (c.u+c.v)/2.\\n   vec2 z = c.center - i.center\\n   ensure lessThan( angleBetween(w,z), c.wedgeAngle/4. )\\n   encourage near( c.textBounds, i.icon ) in labels\\n   ensure disjoint( c.textBounds, c.arcBall ) in labels\\n}\\n\\nforall Corner c1; Corner c2\\nwhere c1 has text label; c2 has text label {\\n   ensure disjoint( c1.textBounds, c2.textBounds ) in labels\\n}\\n\\nforall Point p {\\n\\n   vec2 p.center = (?,?)\\n\\n   -- white dot\\n   shape p.icon = Circle {\\n      fillColor: Colors.white\\n      strokeColor: Colors.black\\n      r: Global.pointRadius\\n      center: p.center\\n      strokeWidth: 1.\\n   }\\n\\n   -- label\\n   shape p.text = Text {\\n      center: (?,?)\\n      string: \\\"\\\"\\n      fontFamily: Global.fontFamily\\n      fontSize: Global.fontSize\\n      fontStyle: \\\"italic\\\"\\n      fillColor: Colors.black\\n   }\\n\\n   -- make sure the dot and label are both\\n   -- on the canvas\\n   ensure contains( Global.box, p.icon )\\n\\n   -- keep the label near the dot\\n   -- encourage equal( norm(p.text.center - p.icon.center), 0. )\\n}\\n\\n-- draw all points above all triangles\\nforall Point p; Triangle t {\\n   layer p.icon above t.icon\\n}\\n\\n-- draw halfedges as \\\"hook\\\" arrows\\nforall Halfedge h; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere h := MakeHalfedge(i,j); t := MakeTriangle(i,j,k)\\n{\\n   h.start = i.center\\n   h.end = j.center\\n   h.opposite = k.center\\n}\\nforall Halfedge h; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere h := MakeHalfedge(j,k); t := MakeTriangle(i,j,k)\\n{\\n   h.start = j.center\\n   h.end = k.center\\n   h.opposite = i.center\\n}\\nforall Halfedge h; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere h := MakeHalfedge(k,i); t := MakeTriangle(i,j,k)\\n{\\n   h.start = k.center\\n   h.end = i.center\\n   h.opposite = j.center\\n}\\nforall Halfedge e {\\n\\n   vec2 p0 = e.start\\n   vec2 p1 = e.end\\n   vec2 p2 = e.opposite\\n\\n   -- unit vectors along the three edges\\n   vec2 t01 = unit(p1-p0)\\n   vec2 t12 = unit(p2-p1)\\n   vec2 t20 = unit(p0-p2)\\n\\n   -- angle bisectors at the two endpoints\\n   vec2 z0 = unit(t01-t20)\\n   vec2 z1 = unit(t12-t01)\\n\\n   -- angles at the two endpoints\\n   scalar alpha0 = angleBetween( p1-p0, p2-p0 )\\n   scalar alpha1 = angleBetween( p2-p1, p0-p1 )\\n\\n   -- compute corners of constant-width inset\\n   scalar h = Global.lineOffset\\n   scalar r0 = h / sin(alpha0/2.)\\n   scalar r1 = h / sin(alpha1/2.)\\n   vec2 q0 = p0 + r0*z0\\n   vec2 q1 = p1 + r1*z1\\n\\n   -- compute truncated segment endpoints\\n   scalar L = norm(p1-p0)\\n   vec2 m = (q0+q1)/2.\\n   vec2 Q0 = m + (L/4.)*t01\\n   vec2 Q1 = m - (L/4.)*t01\\n\\n   vec2 n = rot90(t01)\\n   vec2 Q2 = Q0 + h*(n-t01)\\n\\n   e.icon = Path {\\n      strokeWidth: 2.*Global.lineThickness\\n      strokeColor: Colors.black\\n      fillColor: none()\\n      d: pathFromPoints(\\\"open\\\", [Q2,Q0,Q1])\\n   }\\n\\n   e.labelText = Text {\\n      center: m + h*n\\n      string: e.label\\n      fontFamily: \\\"Courier\\\"\\n      fontSize: \\\"6.75px\\\"\\n      fillColor: Colors.black\\n      rotation: -toDegrees(angleOf(t01))\\n   }\\n}\\n\\n-- default shape for a circle\\nforall Circle C {\\n\\n   shape C.icon = Circle {\\n      center: (?,?)\\n      r: ?\\n      fillColor: Colors.semiBlue\\n   }\\n\\n   constraint C.validRadius = ensure inRange( C.icon.r, 100, 200 )\\n   constraint C.onCanvas = ensure contains(Global.box, C.icon)\\n}\\n\\n-- Barycenter\\nforall Point p; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere t := MakeTriangle(i,j,k); p := Barycenter(t) {\\n   override p.center = barycenter( i.center, j.center, k.center )\\n   override p.icon.fillColor = Colors.red\\n}\\n\\n-- Circumcenter\\nforall Point p; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere t := MakeTriangle(i,j,k); p := Circumcenter(t) {\\n   -- put point at circumcenter \\n   override p.center = t.circumcenter\\n}\\n\\n-- Circumcircle\\nforall Circle C; Triangle t\\nwhere C := Circumcircle(t) {\\n\\n   -- since the circumcircle can be huge, it's\\n   -- too restrictive to force it on the canvas\\n   delete C.onCanvas\\n\\n   -- the circumradius will be valid by construction\\n   delete C.validRadius\\n\\n   override C.icon.center = t.circumcenter\\n   override C.icon.r = t.circumradius\\n   override C.icon.fillColor = none()\\n   override C.icon.strokeColor = rgba( 0., 0., 0., .2 )\\n   override C.icon.strokeWidth = 1.5\\n}\\n\\n-- Incenter\\nforall Point p; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere t := MakeTriangle(i,j,k); p := Incenter(t) {\\n\\n   -- put point at incenter \\n   override p.center = t.incenter\\n}\\n\\n-- Incircle\\nforall Circle C; Triangle t; Vertex i; Vertex j; Vertex k\\nwhere t := MakeTriangle(i,j,k); C := Incircle(t) {\\n   \\n   delete C.onCanvas\\n   delete C.validRadius\\n\\n   override C.icon.center = t.incenter\\n   override C.icon.r = t.inradius\\n   override C.icon.fillColor = none()\\n   override C.icon.strokeColor = rgba( 0., 0., 0., .2 )\\n   override C.icon.strokeWidth = 1.5\\n}\\n\\nforall DualEdge d; Triangle t1; Triangle t2\\nwhere d := MakeDualEdge(t1,t2) {\\n\\n   shape d.segment = Line {\\n      start: t1.circumcenter\\n      end: t2.circumcenter\\n      strokeColor: Colors.black\\n      strokeWidth: Global.lineThickness\\n      style: \\\"dashed\\\"\\n      strokeDasharray: \\\"4,4\\\"\\n   }\\n}\\n\\n-- if a length is constructed from an edge, set its\\n-- endpoints to the edge endpoints (setting things\\n-- up this way allows us to keep Length fairly generic,\\n-- e.g., it can also be used to draw the length of a\\n-- dual edge without duplicating code)\\nforall Length l; Edge e; Vertex i; Vertex j\\nwhere l := EdgeLength(e); e := MakeEdge(i,j) {\\n   vec2 l.x0 = e.segment.start\\n   vec2 l.x1 = e.segment.end\\n}\\n   \\n-- if a length is constructed from a dual edge, set its\\n-- endpoints to the dual edge endpoints\\nforall Length l; DualEdge d; Triangle s; Triangle t\\nwhere l := DualEdgeLength(d); d := MakeDualEdge(s,t) {\\n   vec2 l.x0 = d.segment.start\\n   vec2 l.x1 = d.segment.end\\n}\\n   \\n-- draw lengths as segments with straight ends\\nforall Length l {\\n\\n   vec2 u = unit(l.x1-l.x0)\\n   vec2 n = -rot90(u)\\n   scalar w = Global.lineOffset\\n\\n   scalar l.strokeWidth = .8*Global.lineThickness\\n\\n   shape l.marker = Line {\\n      start: l.x0 + w*n\\n      end: l.x1 + w*n\\n      strokeColor: Colors.black\\n      strokeWidth: l.strokeWidth\\n   }\\n   shape l.end0 = Line {\\n      start: l.marker.start + .35*w*n\\n      end: l.marker.start - .35*w*n\\n      strokeColor: Colors.black\\n      strokeWidth: l.strokeWidth\\n   }\\n   shape l.end1 = Line {\\n      start: l.marker.end + .35*w*n\\n      end: l.marker.end - .35*w*n\\n      strokeColor: Colors.black\\n      strokeWidth: l.strokeWidth\\n   }\\n\\n   vec2 m = (l.x0+l.x1)/2.\\n   shape l.text = Equation {\\n      center: m + 2.*w*n\\n      string: l.label\\n      fillColor: Colors.black\\n      fontSize: Global.fontSize\\n   }\\n}\\n\\n-- mark a positively-oriented triangle with a\\n-- circular arrow pointing in the counter-clockwise\\n-- direction\\nforall Triangle t\\nwhere IsPositivelyOriented(t) {\\n   \\n   scalar R = .5*t.inradius\\n   scalar t0 = toRadians( -60. )\\n   scalar t1 = toRadians( 240. )\\n   vec2 p0 = t.incenter + R*( cos(t0), sin(t0) )\\n   vec2 p1 = t.incenter + R*( cos(t1), sin(t1) )\\n\\n   shape t.orientationArc = Path {\\n      fillColor: none()\\n      strokeColor: Colors.black\\n      d: arc( \\\"open\\\", p0, p1, (R,R), 0., 1, 0 )\\n      strokeWidth: 2.*Global.lineThickness\\n      endArrowhead: \\\"straight\\\"\\n      endArrowheadSize: .5\\n   }\\n}\\nforall Triangle t\\nwhere IsNegativelyOriented(t) {\\n   \\n   scalar R = .5*t.inradius\\n   scalar t0 = toRadians( -60. )\\n   scalar t1 = toRadians( 240. )\\n   vec2 p0 = t.incenter + R*( cos(t0), sin(t0) )\\n   vec2 p1 = t.incenter + R*( cos(t1), sin(t1) )\\n\\n   shape t.orientationArc = Path {\\n      fillColor: none()\\n      strokeColor: Colors.black\\n      d: arc( \\\"open\\\", p0, p1, (R,R), 0., 1, 0 )\\n      strokeWidth: 2.*Global.lineThickness\\n      startArrowhead: \\\"straight\\\"\\n      startArrowheadSize: .5\\n   }\\n}\\n\\n-- draw flipped edge as dashed line\\nforall Edge e\\nwhere IsFlipped( e ) {\\n   e.segment.strokeDasharray = \\\"5,5\\\"\\n   override e.segment.strokeLinecap = \\\"butt\\\"\\n}\\n\\n-- put edge labels on one side of the edge or another\\nforall Edge ij; Vertex i; Vertex j\\nwhere ij := MakeEdge(i,j); ij has math label {\\n\\n   vec2 pi = i.center\\n   vec2 pj = j.center\\n   vec2 m = (pi+pj)/2.\\n   vec2 u = unit(pj-pi)\\n   vec2 n = rot90(u)\\n\\n   vec2 ij.c = (?,?)\\n   scalar h = ?\\n\\n   -- ensure that offset h is either plus or minus 1\\n   scalar s = h*h\\n   ensure equal( 1., s )\\n\\n   -- put label at edge midpoint, offset in the plus\\n   -- or minus normal direction by some fixed amount\\n   shape ij.labelText = Equation {\\n      center: m + 12.*h*n\\n      string: ij.label\\n      fontSize: Global.fontSize\\n      fillColor: Colors.black\\n   }\\n}\\n\\n-- if triangles are concyclic, put vertices on a common circle\\nforall Triangle s; Triangle t; Vertex i; Vertex j; Vertex k; Vertex l\\nwhere s := MakeTriangle(i,j,k); t := MakeTriangle(j,i,l); Concyclic(s,t) {\\n\\n   scalar r0 = 100.\\n   vec2 c0 = (?,?)\\n\\n   shape disk = Circle {\\n      center: c0\\n      r: r0\\n      fillColor: Colors.semiBlue\\n   }\\n\\n   ensure contains( Global.box, disk )\\n   ensure equal( norm( i.center-c0 ), r0 )\\n   ensure equal( norm( j.center-c0 ), r0 )\\n   ensure equal( norm( k.center-c0 ), r0 )\\n   ensure equal( norm( l.center-c0 ), r0 )\\n}\\n\\nforall Point p; Edge ab; Edge cd; Vertex a; Vertex b; Vertex c; Vertex d\\nwhere p := Intersection(ab,cd); ab := MakeEdge(a,b); cd := MakeEdge(c,d) {\\n\\n   vec2 x = a.center\\n   vec2 y = b.center\\n   vec2 z = c.center\\n   vec2 w = d.center\\n\\n   override p.center = lineLineIntersection( x, y, z, w )\\n\\n   layer p.icon above ab.segment\\n   layer p.icon above cd.segment\\n}\\n\\n-- Specific to diagrams/angle-equivalence.substance\\n-- TODO requires #776 to import these rules from an example-specific Style module\\n\\n-- Don't draw vertices as dots in this\\n-- example (but still keep the icons, for\\n-- other purposes).\\n--- angle-equivalence --- forall Vertex v {\\n--- angle-equivalence ---    override v.icon.r = 0.\\n--- angle-equivalence --- }\\n--- angle-equivalence --- \\n--- angle-equivalence --- similarityMap {\\n--- angle-equivalence ---    scalar scale = .5\\n--- angle-equivalence ---    scalar angle = ?\\n--- angle-equivalence ---    vec2 shift = (canvas.width/3.,0.)\\n--- angle-equivalence --- }\\n--- angle-equivalence --- \\n--- angle-equivalence --- forall Vertex v; Vertex v0\\n--- angle-equivalence --- where v := similarity(v0) {\\n--- angle-equivalence --- \\n--- angle-equivalence ---    scalar s = similarityMap.scale\\n--- angle-equivalence ---    scalar theta = similarityMap.angle\\n--- angle-equivalence ---    vec2 u = similarityMap.shift\\n--- angle-equivalence --- \\n--- angle-equivalence ---    override v.center = s*rotateBy(v0.center,theta) + u\\n--- angle-equivalence ---    delete v.onCanvas\\n--- angle-equivalence --- }\\n--- angle-equivalence --- \\n--- angle-equivalence --- -- don't constrain triangle geometry so much\\n--- angle-equivalence --- forall Triangle t; Vertex i; Vertex j; Vertex k; Vertex i0\\n--- angle-equivalence --- where t := MakeTriangle(i,j,k); i := similarity(i0) {\\n--- angle-equivalence ---    delete t.positiveArea\\n--- angle-equivalence ---    delete t.goodAngleA\\n--- angle-equivalence ---    delete t.goodAngleB\\n--- angle-equivalence --- }\\n--- angle-equivalence --- \\n--- angle-equivalence --- -- make sure triangles are disjoint if they are made similar\\n--- angle-equivalence --- forall Triangle t1, t2\\n--- angle-equivalence --- where t1 := MakeTriangle(i, j, k); t2 := MakeTriangle(I, J, K); i := similarity(i); j := similarity(j); k := similarity(k);\\n--- angle-equivalence --- with Vertex i, j, k, I, J, K {\\n--- angle-equivalence ---    ensure disjoint(t1.icon, t2.icon)\\n--- angle-equivalence --- }\\n\\n-- Specific to diagrams/concyclic-pair.substance\\n-- TODO requires #776 to import these rules from an example-specific Style module\\n\\n--- concyclic-pair --- -- make vertex dots bigger\\n--- concyclic-pair --- forall Vertex v {\\n--- concyclic-pair ---    override v.icon.r = 1.75*Global.vertexRadius\\n--- concyclic-pair --- }\\n--- concyclic-pair --- \\n--- concyclic-pair --- -- make corner labels larger and dark blue\\n--- concyclic-pair --- forall Corner c; Vertex i; Vertex j; Vertex k\\n--- concyclic-pair --- where c := MakeCorner(i,j,k); c has text label {\\n--- concyclic-pair ---    override c.text.fontSize = \\\"25px\\\"\\n--- concyclic-pair ---    override c.text.fillColor = Colors.darkBlue\\n--- concyclic-pair --- }\\n--- concyclic-pair --- \\n--- concyclic-pair --- -- don't draw black outline on arcs\\n--- concyclic-pair --- forall Corner c; Vertex i; Vertex j; Vertex k\\n--- concyclic-pair --- where c := MakeCorner(i,j,k) {\\n--- concyclic-pair ---    delete c.arc\\n--- concyclic-pair --- }\\n--- concyclic-pair --- \\n--- concyclic-pair --- -- make edges thicker\\n--- concyclic-pair --- forall Edge e {\\n--- concyclic-pair ---    override e.segment.strokeWidth = 2*Global.lineThickness\\n--- concyclic-pair --- }\\n--- concyclic-pair --- \\n--- concyclic-pair --- -- make boundary edges thicker\\n--- concyclic-pair --- forall Edge e\\n--- concyclic-pair --- where IsBoundaryEdge( e ) {\\n--- concyclic-pair ---    override e.segment.strokeWidth = 3*Global.lineThickness\\n--- concyclic-pair --- }\\n--- concyclic-pair --- \\n--- concyclic-pair --- -- corner labels shouldn't overlap diagonals\\n--- concyclic-pair --- forall Edge e; Corner c; Vertex i; Vertex j; Vertex k; Vertex l\\n--- concyclic-pair --- where c := MakeCorner(i,j,k); e := MakeEdge(l,i) {\\n--- concyclic-pair ---    ensure disjoint( c.textBounds, e.segment )\\n--- concyclic-pair --- }\\n--- concyclic-pair --- forall Edge e; Corner c; Vertex i; Vertex j; Vertex k; Vertex l\\n--- concyclic-pair --- where c := MakeCorner(i,j,k); e := MakeEdge(i,l) {\\n--- concyclic-pair ---    ensure disjoint( c.textBounds, e.segment )\\n--- concyclic-pair --- }\";\n//# sourceMappingURL=triangle-mesh-2d.style.js.map","export default \"-- Mesh combinatorics\\ntype Vertex\\ntype Edge\\ntype Halfedge\\ntype DualEdge\\ntype Triangle\\ntype Corner\\n\\nconstructor MakeEdge(Vertex i, Vertex j) -> Edge\\nconstructor MakeHalfedge(Vertex from, Vertex to) -> Halfedge\\nconstructor MakeTriangle(Vertex i, Vertex j, Vertex k) -> Triangle\\nconstructor MakeCorner( Vertex inner, Vertex outer1, Vertex outer2 ) -> Corner\\nconstructor MakeDualEdge(Triangle a, Triangle b) -> DualEdge\\n\\npredicate IsBoundaryVertex(Vertex v)\\npredicate IsBoundaryEdge(Edge e)\\npredicate IsBoundaryTriangle(Triangle t)\\n\\npredicate HasLabel(Vertex v)\\n\\npredicate IsPositivelyOriented(Triangle t)\\npredicate IsNegativelyOriented(Triangle t)\\n\\n-- Geometry\\ntype Point\\ntype Circle\\ntype Length\\n\\nconstructor Barycenter(Triangle t) -> Point\\nconstructor Circumcenter(Triangle t) -> Point\\nconstructor Incenter(Triangle t) -> Point\\n\\nconstructor Circumcircle(Triangle t) -> Circle\\nconstructor Incircle(Triangle t) -> Circle\\n\\nconstructor EdgeLength(Edge e) -> Length\\nconstructor DualEdgeLength(DualEdge d) -> Length\\n\\nconstructor Intersection(Edge e, Edge f) -> Point\\n\\n-- Specific to angle-equivalence.substance\\nfunction similarity(Vertex i) -> Vertex\\n\\n-- Specific to concyclic-pair.substance\\npredicate IsFlipped(Edge e)\\npredicate Concyclic(Triangle s, Triangle t)\\n\\n\";\n//# sourceMappingURL=triangle-mesh-2d.domain.js.map"],"names":["resolver","makeResolver","style0","domain"],"mappings":"2CACY,MAACA,EAAWC,EAAa,kBAAkB,EACvDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BCFfC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}