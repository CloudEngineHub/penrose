{"version":3,"file":"timeline.style-c6b3801f.js","sources":["../../../examples/dist/timeline/timeline.domain.js","../../../examples/dist/timeline/timeline.style.js"],"sourcesContent":["export default \"type Category\\ntype Quarter \\ntype Task\\ntype Year\\n\\nconstructor MkTask (Quarter start, Quarter end) -> Task\\nconstructor MkQuarter(Year y) -> Quarter\\n\\n--seperated category into new predicate to avoid match de-deuplication\\npredicate In(Task t, Category c)\\n\\n\\n-- The following predicates (Before, First, and Last) are neccesary to get around Style language\\n-- limitations related to aggregation.\\n-- If style aggregation is ever supported the style program should use that feature\\n-- and these predicates should be removed.\\n\\n--declares the immediate prior category\\npredicate Before(Category, Category)\\n-- declares the first quarter of the year\\npredicate First(Quarter q, Year y)\\n-- declares the last quarter of the year\\npredicate Last(Quarter q, Year y)\";\n//# sourceMappingURL=timeline.domain.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"timeline\");\nexport default \"canvas {\\n    width = 1200\\n    height = 550\\n}\\n\\nlayout = [sort, disjoint]\\n\\ncolors {\\n    darkgray = #333333\\n    gray = #D3D3D3\\n    lightgray = #F5F5F5\\n    green = #B6DDBF\\n    purple = #D4CEE8\\n    blue = #d5e3ff\\n}\\n\\nglobal {\\n    --- parameters that user may want to tweek\\n    taskHeight = 35\\n    taskLabelFontSize = \\\"18px\\\"\\n    taskFontStyle = \\\"italic\\\"\\n    periodFontSize = \\\"20px\\\"\\n    periodFontStyle = \\\"bold\\\"\\n\\n    fontFamily = \\\"Garamond\\\"\\n\\n    marginTop = 25\\n    marginBottom = 25\\n    marginLeft = 25\\n    marginRight = 25\\n\\n    yearHeight = 40\\n    quarterHeight = 40\\n\\n    gridLineWeight = 2\\n    taskStrokeWeight = 1\\n    taskCornerRadius = 8\\n    taskPadding = 10\\n\\n    --- parameters that are calculated\\n    topGridY = (canvas.height / 2) - marginTop\\n    topQuarterY = topGridY - yearHeight\\n    lineY = topQuarterY - quarterHeight\\n    bottomGridY = -(canvas.height / 2) + marginBottom\\n    startX =- (canvas.width / 2) + marginLeft\\n    endX = (canvas.width / 2) - marginRight\\n    lineLength = endX - startX\\n    startLine = (startX, lineY)\\n    endLine = (endX, lineY)\\n    shape baseline = Line {\\n        start : startLine\\n        end : endLine\\n        strokeWidth : global.gridLineWeight\\n        strokeColor: colors.gray\\n    }\\n\\n}\\n\\nforall Category c {\\n    -- compute an HSVA color: H is based on the category index with a random phase shift of [0, 100] degrees. S=30, H=100, and A=100%.\\n    phaseShift = unitRandom() * 50 \\n    hue = 360 / match_total * match_id + phaseShift\\n    c.fillColor = hsva(hue, 30, 100, 1)\\n}\\n\\nforall Year y {\\n    y.minX = ?\\n    y.maxX = ?\\n    y.centerX = average2(y.minX, y.maxX)\\n    y.centerY = global.topGridY - (global.yearHeight / 2)\\n    y.icon = Text {\\n        center : (y.centerX, y.centerY)\\n        string : y.label\\n        fillColor : colors.darkgray\\n        fontSize : global.periodFontSize\\n        fontStyle : global.periodFontStyle\\n        fontFamily: global.fontFamily\\n    }\\n    y.slotBegin = Line {\\n        start : (y.minX,global.topQuarterY)\\n        end : (y.minX,global.topGridY)\\n        strokeWidth : global.gridLineWeight\\n        strokeColor: colors.gray\\n    }\\n    y.slotEnd = Line {\\n        start : (y.maxX,global.topQuarterY)\\n        end : (y.maxX,global.topGridY)\\n        strokeWidth : global.gridLineWeight\\n        strokeColor: colors.gray\\n    }\\n}\\n\\nforall Quarter q {\\n    denominator = (match_total * 2)\\n    index = (match_id - 1) * 2\\n    startRatio = index / denominator\\n    middleRatio = (index + 1) / denominator\\n    endRatio = (index + 2) / denominator\\n    ratioX = ((match_id * 2) - 1) / (match_total * 2)\\n    totalSlotX = global.lineLength\\n    q.startSlotX = global.startX + startRatio * totalSlotX\\n    q.middleSlotX = global.startX + middleRatio * totalSlotX\\n    q.endSlotX = global.startX +endRatio * totalSlotX\\n    q.x = q.middleSlotX\\n    q.y = global.lineY + (global.quarterHeight / 2)\\n    q.icon = Text {\\n        center : (q.x, q.y)\\n        string : q.label\\n        fillColor : colors.darkgray\\n        fontSize : global.periodFontSize\\n        fontStyle : global.periodFontStyle\\n        fontFamily: global.fontFamily\\n    }\\n    q.slotBegin = Line {\\n        start : (q.startSlotX,global.bottomGridY)\\n        end : (q.startSlotX,global.topQuarterY)\\n        strokeWidth : global.gridLineWeight\\n        strokeColor: colors.gray\\n    }\\n    q.slotEnd = Line {\\n        start : (q.endSlotX,global.bottomGridY)\\n        end : (q.endSlotX,global.topQuarterY)\\n        strokeWidth : global.gridLineWeight\\n        strokeColor: colors.gray\\n    }\\n    layer q.slotEnd below global.baseline\\n    layer q.slotBegin below global.baseline\\n}\\n\\n\\ncollect Quarter q into qs\\nwhere q := MkQuarter(y)\\nforeach Year y {\\n    override y.minX = minList(listof startSlotX from qs)\\n    override y.maxX = maxList(listof   endSlotX from qs)\\n}\\n\\nforall Task e\\nwhere e := MkTask(start, end)\\nwith Quarter start; Quarter end;{\\n    e.centerY = ?\\n    topBox = e.centerY + global.taskHeight/2\\n    bottomBox = e.centerY - global.taskHeight/2\\n    centerX = ((end.endSlotX - start.startSlotX) / 2) + start.startSlotX\\n    e.icon = Rectangle {\\n        height : global.taskHeight\\n        width : end.endSlotX - start.startSlotX\\n        center: (centerX, e.centerY)\\n        cornerRadius : global.taskCornerRadius\\n        strokeWidth : global.taskStrokeWeight\\n        strokeColor: colors.darkgray\\n    }\\n\\n    e.text = Text {\\n        string : e.label\\n        fontSize : global.taskLabelFontSize\\n        fillColor : colors.darkgray\\n        center : (centerX, e.centerY)\\n        fontStyle: global.taskFontStyle\\n        fontFamily: global.fontFamily\\n    }\\n    topWithPadding = global.lineY - global.taskPadding\\n    ensure lessThan(topBox, topWithPadding)\\n    bottomWithPadding = global.bottomGridY + global.taskPadding\\n    ensure greaterThan(bottomBox, bottomWithPadding)\\n    layer e.icon above global.baseline\\n    layer e.text above e.icon\\n}\\n\\nforall Task e \\nwhere In(e, c)\\nwith Category c {\\n   e.icon.fillColor = c.fillColor\\n}\\n\\nforall Task e1; Task e2\\nwhere In(e1, c1); In(e2, c2); Before(c2, c1)\\nwith Category c1, c2\\n{\\n  ensure e1.centerY > (e2.centerY + global.taskPadding + global.taskHeight) in [sort,disjoint]\\n}\\n\\nforall Task e1, e2 {\\n    ensure disjoint(e1.icon, e2.icon, global.taskPadding) in disjoint\\n}\\n\\n-- `penrose-project-timeline` styling\\nforall Task e\\nwhere In(e, `access`)\\nwith Category `access` {\\n   override e.icon.fillColor = colors.green\\n}\\n\\nforall Task e\\nwhere In (e, `milestone`)\\nwith  Category `milestone` {\\n   override e.icon.fillColor = colors.blue\\n}\\n\\nforall Task e\\nwhere In(e, `outcome`)\\nwith Category `outcome` {\\n   override e.icon.fillColor = colors.purple\\n}\";\n//# sourceMappingURL=timeline.style.js.map"],"names":["domain","resolver","makeResolver","style0"],"mappings":"2CAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mCCCFC,EAAWC,EAAa,UAAU,EAC/CC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;"}