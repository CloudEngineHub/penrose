{"version":3,"file":"siggraph-teaser.trio-4c27b2a2.js","sources":["../../../examples/dist/geometry-domain/teaser.substance.js","../../../examples/dist/geometry-domain/euclidean-teaser.style.js","../../../examples/dist/geometry-domain/siggraph-teaser.trio.js"],"sourcesContent":["export default \"Plane P\\nPoint p, q, r, s\\nIn(p, P)\\nIn(q, P)\\nIn(r, P)\\nIn(s, P)\\nLet a := Segment(p, q)\\nLet b := Segment(p, r)\\nPoint m := Midpoint(a)\\nIn(m, P)\\nAngle theta := InteriorAngle(q, p, r)\\nLet t := Triangle(p, r, s)\\nRay w := Bisector(theta)\\nSegment h := PerpendicularBisector(a, m)\\nAutoLabel p, q, r, s, m\\nLabel P $E^2$\";\n//# sourceMappingURL=teaser.substance.js.map","import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"geometry-domain\");\nexport default \"-- Original Style: https://github.com/penrose/penrose/blob/90e88c5a075d6a75698c49c2feb101275ae64af8/examples/geometry-domain/euclidean.sty\\n-- Original comp. functions: https://github.com/penrose/penrose/blob/90e88c5a075d6a75698c49c2feb101275ae64af8/src/Penrose/Functions.hs\\n\\ncanvas {\\n  width = 800\\n  height = 700\\n}\\n\\nColors {\\n    -- Keenan palette\\n    black = #000000\\n    white = #fff\\n    darkpurple = #8c90c1\\n    lightpurple = #d0d3e6\\n    purple2 = rgba(0.106, 0.122, 0.54, 0.2)\\n    verylightpurple = rgba(0.953, 0.957, 0.977, 1.0)\\n    purple3 = rgba(0.557, 0.627, 0.769, 1.0)\\n    midnightblue = rgba(0.14, 0.16, 0.52, 1.0)\\n    none = none()\\n}\\n\\nconst {\\n    pi = 3.14159\\n    arrowheadSize = 0.65\\n    strokeWidth = 1.75\\n    textPadding = 7.0\\n    textPadding2 = 25.0\\n    repelWeight = 0.7 -- TODO: Reverted from 0.0\\n    repelWeight2 = 0.5\\n    fontSize = \\\"25px\\\"\\n    containPadding = 50.0\\n    rayLength = 100.0\\n    pointRadius = 4.0\\n    pointStroke = 0.0\\n    thetaRadius = 30.0\\n    circleRadius = 150.0\\n    labelPadding = 30.0\\n    minSegmentLength = 80.0\\n    minLineLength = 200.0\\n}\\n\\n--------------------------------------------------------------------------------\\n-- START of \\\"euclidean.style\\\"\\n\\n--Plane\\nforall Plane p {\\n  width = canvas.width * .8\\n  height = canvas.height * .8\\n  p.text = Equation {\\n    center : ((width / 2.0) - const.textPadding2, (height / 2.0) - const.textPadding2)\\n    string : p.label\\n    fontSize : const.fontSize\\n  }\\n\\n  -- inner: #f3f4f9, outer: #8e93c4\\n  p.icon = Rectangle {\\n    -- angle : 0.0\\n    -- fillColor : Colors.purple2\\n    fillColor : Colors.none -- TODO: arrange angle markers so plane can be opaque\\n    strokeColor : Colors.purple3\\n    strokeWidth : 2.0\\n    center : (0.0, 0.0)\\n    width : width\\n    height : height\\n  }\\n\\n  p.text above p.icon\\n}\\n\\n--Point\\nforall Point p {\\n  p.x = ?\\n  p.y = ?\\n  p.vec = (p.x, p.y)\\n  p.color = Colors.black\\n\\n  p.icon = Circle {\\n    center: p.vec\\n    r : const.pointRadius\\n    fillColor : Colors.black\\n    strokeWidth : 0.0\\n    strokeColor : Colors.black\\n  }\\n\\n  p.text = Equation {\\n    string : p.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n  }\\n  ensure equal(signedDistance(p.text, p.vec), const.textPadding + const.pointRadius)\\n}\\n\\n-- default: if `Point` is not on a `Plane`, the point should be below the plane to stay hidden\\nforall Point p\\nwith Plane P {\\n  p.iconOnPlane = ensure disjoint(p.icon, P.icon)\\n  p.textOnPlane = ensure disjoint(p.text, P.icon)\\n}\\n\\nforall Point p\\nwith Plane P\\nwhere In(p, P) {\\n  -- TODO: the problem is that this ensures the padding is const? Or is > padding okay?\\n  -- There's a choice of whether to put padding on the point or the text for containment\\n  override p.iconOnPlane = ensure contains(P.icon, p.icon, const.containPadding)\\n  override p.textOnPlane = ensure contains(P.icon, p.text, 0.0)\\n\\n  p.icon above P.icon\\n  p.text above P.icon\\n}\\n\\nforall Point p, q, r\\nwhere Collinear(p, q, r) {\\n  ensure collinear(p.icon.center, q.icon.center, r.icon.center)\\n  -- HACK: make sure q is between p and r\\n  -- TODO: should this be in Substance instead?\\n  ensure inRange(q.icon.center[0], p.icon.center[0], r.icon.center[0])\\n  ensure inRange(q.icon.center[1], p.icon.center[1], r.icon.center[1])\\n  encourage notTooClose(p.icon, q.icon, const.repelWeight)\\n  encourage notTooClose(q.icon, r.icon, const.repelWeight)\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l) {\\n  ensure equal(signedDistance(l.icon, p.vec), 0)\\n}\\n\\nforall Point p\\nwith Linelike l\\nwhere On(p, l); p has label {\\n  ensure disjoint(l.icon, p.text)\\n}\\n\\n--Linelike\\nforall Linelike l {\\n  l.color = Colors.black\\n\\n  l.icon = Line {\\n    start : (?, ?)\\n    end : (?, ?)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Ray r\\nwhere r := Ray(base, direction)\\nwith Point base; Point direction {\\n  r.start = base.vec\\n  r.end = direction.vec\\n  r.vec = direction.vec - base.vec\\n\\n  override r.icon = Line {\\n    start : base.icon.center\\n    end : ptOnLine(base.vec, direction.vec, norm(r.vec) + 40.)\\n    strokeColor : r.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n  -- labeling\\n  ensure disjoint(r.icon, base.text)\\n  ensure disjoint(r.icon, direction.text)\\n}\\n\\nforall Ray r {\\n    r.length = const.rayLength\\n}\\n\\nforall Ray r\\nwith Angle theta; Point x; Point y; Point z\\nwhere r := Bisector(theta); theta := InteriorAngle(y, x, z) {\\n  -- find the vector for the bisector ray\\n  xy = normalize(y.vec - x.vec)\\n  xz = normalize(z.vec - x.vec)\\n  r_vec = xy + xz\\n  -- change from generic `Linelike` shape to a specific shape for `Ray`\\n  override r.icon = Line {\\n    start: x.vec\\n    end:  (r.length * normalize(r_vec)) + x.vec\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    endArrowhead: \\\"straight\\\"\\n    endArrowheadSize : const.arrowheadSize\\n  }\\n  r.icon below x.icon\\n}\\n\\nforall Line l\\nwhere l := Line(p, q)\\nwith Point p; Point q {\\n  l.start = p.vec\\n  l.end = q.vec\\n  l.vec = q.vec - p.vec\\n  override l.icon = Line {\\n    start : ptOnLine(p.vec,q.vec, -40.)\\n    end : ptOnLine(p.vec, q.vec, norm(l.vec) + 40.)\\n    strokeColor : l.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    endArrowhead : \\\"straight\\\"\\n    startArrowhead: \\\"straight\\\"\\n    startArrowheadSize: const.arrowheadSize\\n    endArrowheadSize: const.arrowheadSize\\n  }\\n\\n  -- edge case\\n  ensure lessThan(const.minLineLength, norm(l.vec))\\n\\n  -- labeling\\n  ensure disjoint(l.icon, p.text)\\n  ensure disjoint(l.icon, q.text)\\n}\\n\\nforall Linelike l1, l2 -- should this work with rays and lines?\\nwhere ParallelMarker1(l1, l2) {\\n  l1.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l1.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n  l2.tick1 = Path {\\n    d : pathFromPoints(\\\"open\\\", chevron(l2.icon, 20.))\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Linelike l1, l2\\nwhere Parallel(l1, l2) {\\n  -- the dot product of the unit vectors of parallel lines is 1\\n  -- HACK: scaling to 10000s for convergence\\n  ensure equal(10000, dot(normalize(l1.vec), normalize(l2.vec)) * 10000)\\n}\\n--Segment\\nforall Segment e\\nwhere e := Segment(p, q)\\nwith Point p; Point q {\\n  e.vec = [q.x - p.x, q.y - p.y]\\n  e.start = p.vec\\n  e.end = q.vec\\n\\n  override e.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : e.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above e.icon\\n  q.icon above e.icon\\n\\n  -- edge case\\n  ensure lessThan(const.minSegmentLength, norm(e.vec))\\n\\n  -- labeling\\n  ensure disjoint(p.text, e.icon)\\n  ensure disjoint(q.text, e.icon)\\n}\\n\\nforall Segment e; Plane p {\\n  e.icon above p.icon\\n}\\n\\nforall Linelike s, t\\nwhere EqualLength(s, t) {\\n  ensure equal(vdist(s.icon.start, s.icon.end), vdist(t.icon.start, t.icon.end))\\n}\\n\\n--TODO eventually this should also provide an equal length marker since it is bisecting the segment\\nforall Segment s\\nwhere s := PerpendicularBisector(s2, p)\\nwith Segment s2; Point p {\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : midpoint(s2.icon.start, s2.icon.end)\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Segment s\\nwhere s := PerpendicularBisectorLabelPts(s2, p1, p2)\\nwith Segment s2; Point p1, p2 {\\n  override p2.vec = midpoint(s2.icon.start, s2.icon.end)\\n  override s.icon = Line {\\n    start : p1.icon.center\\n    end : p2.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, 20.), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, 20.), ptOnLine(s.icon.end, s2.icon.end, 20.)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n}\\n\\nforall Linelike s, t \\nwhere EqualLengthMarker(s, t) as e {\\n  e.equivGroup = match_id\\n  override s.tick = Path {\\n    d : ticksOnLine(s.icon.start, s.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  override t.tick = Path {\\n    d : ticksOnLine(t.icon.start, t.icon.end, 15., e.equivGroup, 10.)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n  }\\n  s.tick above s.icon\\n  t.tick above t.icon\\n}\\n\\n-- HACK: since we cannot handle transitive predicates and don't allow recursive expressions, we redeclare the shapes so the tick counts are the same\\nforall Linelike s, t, u\\nwhere EqualLengthMarker(s, t) as e1; EqualLengthMarker(t, u) as e2 {\\n  minEquivGroup = min(e1.equivGroup, e2.equivGroup)\\n  -- minEquivGroup = e2.equivGroup\\n  override s.tick.d = ticksOnLine(s.icon.start, s.icon.end, 15., minEquivGroup, 10.) \\n  override u.tick.d = ticksOnLine(u.icon.start, u.icon.end, 15., minEquivGroup, 10.) \\n  override t.tick.d = ticksOnLine(t.icon.start, t.icon.end, 15., minEquivGroup, 10.) \\n}\\n\\n--Angle\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r)\\nwith Point p; Point q; Point r {\\n  theta.p = p.vec\\n  theta.q = q.vec\\n  theta.r = r.vec\\n  theta.color = #000\\n  theta.side1 = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  theta.side2 = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : theta.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  \\n  theta.radius = const.thetaRadius\\n  encourage nonDegenerateAngle(p.icon, q.icon, r.icon)\\n  theta.side1 below p.icon, q.icon\\n  theta.side2 below q.icon, r.icon\\n}\\n\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r); theta has label\\nwith Point p; Point q; Point r {\\n  padding = const.textPadding + const.pointRadius + theta.text.width\\n  labelDir = normalize((p.vec - q.vec) + (r.vec - q.vec))\\n  theta.text = Equation {\\n    string : theta.label\\n    fillColor : Colors.black\\n    fontSize : const.fontSize\\n    center: q.vec + labelDir*padding\\n  }\\n}\\n\\nforall Angle a, b\\nwhere EqualAngleMarker(a, b) {\\n  --find points from p->q, then q->r for each vector. draw vectors for each\\n  startA = ptOnLine(a.q, a.p, a.radius)\\n  endA = ptOnLine(a.q, a.r, a.radius)\\n  sweepA = arcSweepFlag(a.q, startA, endA)\\n\\n  startB = ptOnLine(b.q, b.p, b.radius)\\n  endB = ptOnLine(b.q, b.r, b.radius)\\n  sweepB = arcSweepFlag(b.q, startB, endB)\\n\\n  spacing = 10\\n\\n  override a.mark = Path {\\n    d : repeatedArcs(startA, endA, a.p, a.r, (a.radius, a.radius), match_id, spacing, sweepA)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n  override b.mark = Path {\\n    d : repeatedArcs(startB, endB, b.p, b.r, (a.radius, a.radius), match_id, spacing, sweepB)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n    fillColor: Colors.none\\n }\\n}\\n\\nforall Angle a, b\\nwhere EqualAngle(a, b) {\\n  -- make sure angle a is equal to angle b\\n  -- HACK: increase the magnitude of angles\\n  weight = 100\\n  angleA = angleBetween(a.p - a.q, a.r - a.q) * weight\\n  angleB = angleBetween(b.p - b.q, b.r - b.q) * weight\\n  ensure equal(angleA, angleB) \\n}\\n\\nforall Angle a\\nwhere RightUnmarked(a) {\\n  -- ensure perpendicular(a.p, a.q, a.r)\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure equal(0, dot(u, v))\\n}\\n\\nforall Angle a\\nwhere RightMarked(a) {\\n  --render half square path of size a.radius\\n  markSize = 10\\n  override a.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(a.q, a.p, markSize), innerPointOffset(a.q, a.p, a.r, markSize), ptOnLine(a.q, a.r, markSize)])\\n    strokeWidth : 2.0\\n    strokeColor : #000\\n    fillColor : Colors.none\\n  }\\n  vec2 u = a.p - a.q\\n  vec2 v = a.r - a.q\\n  ensure equal(0, dot(u, v))\\n}\\n\\nforall Angle a\\nwhere Acute(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), 0, MathPI()/2)\\n}\\n\\nforall Angle a\\nwhere Obtuse(a) {\\n  ensure inRange(angleBetween(a.p - a.q, a.r - a.q), MathPI()/2, MathPI())\\n}\\n\\nforall Triangle t; Plane P \\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.PQ above P.icon\\n  t.QR above P.icon\\n  t.RP above P.icon\\n  t.icon above P.icon\\n}\\n\\nforall Triangle t\\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.color = Colors.black\\n  t.PQ = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.QR = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.RP = Line {\\n    start : r.icon.center\\n    end : p.icon.center\\n    strokeColor : t.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  t.icon = Path {\\n    d: pathFromPoints(\\\"closed\\\", [p.vec, q.vec, r.vec])\\n    fillColor: none()\\n  }\\n  ensure lessThan(const.minSegmentLength, length(t.PQ))\\n  ensure lessThan(const.minSegmentLength, length(t.QR))\\n  ensure lessThan(const.minSegmentLength, length(t.RP))\\n  ensure disjoint(t.icon, p.text)\\n  ensure disjoint(t.icon, q.text)\\n  ensure disjoint(t.icon, r.text)\\n  t.PQ below p.icon\\n  t.PQ below q.icon\\n  t.QR below q.icon\\n  t.QR below r.icon\\n  t.RP below r.icon\\n  t.RP below p.icon\\n}\\n\\nforall Point p\\nwith Triangle T; Point t1, t2, t3\\nwhere T := Triangle(t1, t2, t3); Incenter(p, T) {\\n  override p.vec = incenter(t1.vec, t2.vec, t3.vec)\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.incenterIcon = Circle {\\n    center : p.vec\\n    r : inradius(t1.vec, t2.vec, t3.vec) - const.strokeWidth\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    strokeStyle: \\\"dashed\\\"\\n    fillColor : Colors.none\\n  }\\n  T.incenterIcon below t1.icon\\n  T.incenterIcon below t2.icon\\n  T.incenterIcon below t3.icon\\n}\\n\\nforall Point p\\nwhere Circumcenter(p, T)\\nwith Triangle T {\\n  clr = Colors.darkpurple\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  p.icon above T.PQ\\n  p.icon above T.QR\\n  p.icon above T.RP\\n  T.icon = Circle {\\n    center : p.vec\\n    r : ?\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : Colors.none\\n    strokeStyle: \\\"dashed\\\"\\n  }\\n  ensure equal(norm(T.PQ.start - p.vec), T.icon.r)\\n  ensure equal(norm(T.QR.start - p.vec), T.icon.r)\\n  ensure equal(norm(T.RP.start - p.vec), T.icon.r)\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.QR.start)\\n  encourage repelPt(const.repelWeight, T.QR.start, T.RP.start)\\n}\\n\\nforall Point p\\nwhere Centroid(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  override p.vec = vmul(1/3, T.PQ.start + T.QR.start + T.RP.start)\\n  override p.icon = Circle {\\n    center : p.vec\\n    r : const.pointRadius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : clr\\n    fillColor : clr\\n  }\\n  override T.icon = Line {\\n    start : T.PQ.start\\n    end : midpoint(T.QR.start, T.QR.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.line2 = Line {\\n    start : T.QR.start\\n    end : midpoint(T.RP.start, T.RP.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  override T.icon3 = Line {\\n    start : T.RP.start\\n    end : midpoint(T.PQ.start, T.PQ.end)\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere Orthocenter(p, T)\\nwith Triangle T {\\n  clr = setOpacity(Colors.darkpurple, 0.6)\\n  T.icon = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon2 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  T.icon3 = Line {\\n    start : (?, ?)\\n    end : p.vec\\n    strokeColor : clr\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  -- TODO make it so that predicates can reference other predicates. 3/4 of these are copy-pasted from the Collinear predicate\\n  ensure collinear(T.PQ.start, T.icon.start, T.PQ.end)\\n  ensure collinear(T.QR.start, T.icon2.start, T.QR.end)  \\n  ensure collinear(T.RP.start, T.icon3.start, T.RP.end)\\n\\n  ensure perpendicular(T.PQ.start, T.icon.start, p.vec)\\n  ensure perpendicular(T.QR.start, T.icon2.start, p.vec)  \\n  ensure perpendicular(T.RP.start, T.icon3.start, p.vec)\\n\\n  encourage repelPt(const.repelWeight, T.PQ.start, T.icon.start)\\n  encourage repelPt(const.repelWeight, T.PQ.end, T.icon.start)\\n\\n  encourage repelPt(const.repelWeight, T.QR.start, T.icon2.start)\\n  encourage repelPt(const.repelWeight, T.QR.end, T.icon2.start)\\n\\n  encourage repelPt(const.repelWeight, T.RP.start, T.icon3.start)\\n  encourage repelPt(const.repelWeight, T.RP.end, T.icon3.start)\\n\\n}\\n\\n--Rectangle\\n-- -- Should the rectangle be constructed from the points, or vice versa?\\nforall Rectangle R\\nwhere R := Rectangle(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  override R.color = Colors.none\\n  override R.icon = Path {\\n      d : pathFromPoints(\\\"closed\\\", [p.icon.center, q.icon.center, r.icon.center, s.icon.center])\\n      strokeWidth : const.strokeWidth\\n      fillColor : R.color\\n      strokeColor : Colors.black\\n    }\\n  ensure equal(vdist(p.icon.center, q.icon.center), vdist(r.icon.center, s.icon.center))\\n  ensure equal(vdist(p.icon.center, s.icon.center), vdist(q.icon.center, r.icon.center))\\n\\n  ensure perpendicular(p.icon.center, q.icon.center, r.icon.center)\\n  ensure perpendicular(q.icon.center, s.icon.center, r.icon.center)\\n\\n  -- R.icon above P.icon\\n}\\n\\nforall Quadrilateral Q\\nwhere Q := Quadrilateral(p, q, r, s)\\nwith Point p; Point q; Point r; Point s {\\n  Q.p = p.icon.center\\n  Q.q = q.icon.center\\n  Q.r = r.icon.center\\n  Q.s = s.icon.center\\n\\n  override Q.color = Colors.black\\n  Q.side1 = Line {\\n    start : Q.p\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side2 = Line {\\n    start : Q.r\\n    end : Q.q\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side3 = Line {\\n    start : Q.s\\n    end : Q.r\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  Q.side4 = Line {\\n    start : Q.p\\n    end : Q.s\\n    strokeColor : Q.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }  \\n  Q.labelContainer = Path {\\n    d: pathFromPoints(\\\"closed\\\", [Q.p, Q.q, Q.r, Q.s])\\n    fillColor: none()\\n  }\\n  -- TODO: check if the points actually have labels\\n  ensure disjoint(p.text, Q.labelContainer)\\n  ensure disjoint(q.text, Q.labelContainer)\\n  ensure disjoint(r.text, Q.labelContainer)\\n  ensure disjoint(s.text, Q.labelContainer)\\n  -- ensure all sides are visible\\n  ensure lessThan(const.minSegmentLength, norm(Q.p - Q.q))\\n  ensure lessThan(const.minSegmentLength, norm(Q.q - Q.r))\\n  ensure lessThan(const.minSegmentLength, norm(Q.r - Q.s))\\n  ensure lessThan(const.minSegmentLength, norm(Q.s - Q.p))\\n  ensure lessThan(const.minSegmentLength, norm(Q.r - Q.p))\\n  ensure lessThan(const.minSegmentLength, norm(Q.s - Q.q))\\n}\\n\\n--FUNCTIONS\\nforall Segment s\\nwith Triangle T; Point p, q, r, a, b\\nwhere s := MidSegment(T, a, b); T := Triangle(p, q, r) {\\n  override a.vec = midpoint(q.vec, r.vec)\\n  override b.vec = midpoint(r.vec, p.vec)\\n  override s.icon = Line {\\n    start : a.vec\\n    end : b.vec\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n}\\n\\nforall Point p\\nwhere p := Midpoint(l)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n}\\n\\nforall Point p\\nwhere Midpoint(l, p); p has label\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n  ensure disjoint(p.text, l.icon)\\n}\\n\\n-- TODO sometimes bisector becomes a scaled version of either side length PQ or QR of angle PQR\\nforall Linelike s\\nwhere AngleBisector(a, s)\\nwith Angle a; Point p {\\n  weight = 10000\\n  angleA = angleBetween(a.p - a.q, s.end - a.q) * weight\\n  angleB = angleBetween(s.end - a.q, a.r - a.q) * weight\\n  ensure equal(angleA, angleB) \\n  -- HACK: make sure the bisector end point is between angle end points. Might be too specific\\n  ensure inRange(s.end[0], a.p[0], a.r[0])\\n  ensure inRange(s.end[1], a.p[1], a.r[1])\\n  -- FIXME: NaN when using the following\\n  -- v1 = normalize(a.p - a.q) \\n  -- v2 = normalize(s.end - a.q)\\n  -- v3 = normalize(a.r - a.q)\\n  -- angleA = angleFrom(v1, v2) * weight\\n  -- angleB = angleFrom(v2, v3) * weight\\n\\n}\\n\\nforall Circle c {\\n  c.radius = const.circleRadius\\n  c.vec = (?, ?)\\n\\n  c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\nforall Circle c\\nwhere c := CircleR(p, q)\\nwith Point p, q {\\n  override c.radius = vdist(p.vec, q.vec)\\n  override c.vec = p.icon.center\\n  override c.icon = Circle {\\n    center : c.vec\\n    r : c.radius\\n    strokeWidth : const.strokeWidth\\n    strokeColor : Colors.black\\n    fillColor : Colors.none\\n  }\\n}\\n\\n-- TODO this can be reimplemented when issue #621 is resolved\\n-- Circle c\\n-- where c := CircleD(p, q)\\n-- with Point p, q {\\n--   override c.radius = vdist(p.vec, q.vec) / 2\\n-- }\\n\\nforall Segment s\\nwhere s := Chord(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeColor : s.color\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure equal(norm(p.vec - c.vec), c.radius)\\n  ensure equal(norm(q.vec - c.vec), c.radius)\\n}\\n\\nforall Segment s\\nwhere s := Chord(c, p, q); p has label; q has label \\nwith Circle c; Point p, q {\\n  ensure disjoint(c.icon, p.text)\\n  ensure disjoint(c.icon, q.text)\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p)\\nwith Circle c; Point p {\\n  override s.vec = p.vec - c.vec\\n  override s.icon = Line {\\n    start : c.vec\\n    end : p.icon.center\\n    strokeColor : Colors.black\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n  }\\n  p.icon above c.icon\\n  ensure equal(norm(c.vec - p.vec), c.radius)\\n}\\n\\nforall Segment s\\nwhere s := Radius(c, p); p has label\\nwith Circle c; Point p {\\n  ensure disjoint(p.text, c.icon)\\n}\\n\\nforall Segment s\\nwhere s := Diameter(c, p, q)\\nwith Circle c; Point p, q {\\n  override s.vec = q.vec - p.vec\\n  override s.icon = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeWidth : const.strokeWidth\\n    style : \\\"solid\\\"\\n    strokeColor : Colors.black\\n  }\\n\\n  p.icon above c.icon\\n  q.icon above c.icon\\n  ensure equal(norm(midpoint(p.vec, q.vec) - c.icon.center), 0)\\n  ensure equal(c.icon.r * 2, norm(s.vec))\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p)\\nwith Circle c {\\n  ensure equal(norm(c.vec - p.vec), c.radius)\\n}\\n\\nforall Point p\\nwhere OnCircle(c, p); p has label\\nwith Circle c {\\n  ensure disjoint(p.text, c.icon)\\n}\\n\\nforall Point p\\nwhere CircleCenter(c, p)\\nwith Circle c {\\n  override p.vec = c.vec\\n}\\n-- END of \\\"euclidean.style\\\"\\n--------------------------------------------------------------------------------\\n\\n--Plane\\nforall Plane p {\\n  dim = 700.0\\n  override p.text.center = ((dim / 2.0) - const.textPadding2, (dim / 2.0) - const.textPadding2)\\n  -- inner: \\n  override p.icon = Rectangle {\\n    fillColor : #f3f4f9\\n    strokeColor : #8e93c4\\n    strokeWidth : 2.0\\n    center : (0.0, 0.0)\\n    width : dim\\n    height : dim\\n  }\\n\\n  p.text above p.icon\\n}\\n\\nforall Triangle t\\nwhere t := Triangle(p, q, r)\\nwith Point p; Point q; Point r {\\n  t.strokeWidth = 0.0\\n  override t.PQ = Line {\\n    start : p.icon.center\\n    end : q.icon.center\\n    strokeWidth : t.strokeWidth\\n  }\\n  override t.QR = Line {\\n    start : q.icon.center\\n    end : r.icon.center\\n    strokeWidth : t.strokeWidth\\n  }\\n  override t.RP = Line {\\n    start : r.icon.center\\n    end : p.icon.center\\n    strokeWidth : t.strokeWidth\\n  }\\n  override t.icon = Path {\\n    d : pathFromPoints(\\\"closed\\\", [p.icon.center, r.icon.center, q.icon.center])\\n    fillColor: Colors.purple2\\n    strokeWidth: 0\\n  }\\n  ensure lessThan(const.minSegmentLength, length(t.PQ))\\n  ensure lessThan(const.minSegmentLength, length(t.QR))\\n  ensure lessThan(const.minSegmentLength, length(t.RP))\\n  ensure disjoint(t.icon, p.text)\\n  ensure disjoint(t.icon, q.text)\\n  ensure disjoint(t.icon, r.text)\\n  t.PQ below p.icon\\n  t.PQ below q.icon\\n  t.QR below q.icon\\n  t.QR below r.icon\\n  t.RP below r.icon\\n  t.RP below p.icon\\n}\\n\\n--Angle\\nforall Angle theta\\nwhere theta := InteriorAngle(p, q, r)\\nwith Point p; Point q; Point r {\\n  override theta.p = p.vec\\n  override theta.q = q.vec\\n  override theta.r = r.vec\\n\\n  override theta.radius = const.thetaRadius\\n  encourage nonDegenerateAngle(p.icon, q.icon, r.icon)\\n  startA = ptOnLine(theta.q, theta.p, theta.radius)\\n  endA = ptOnLine(theta.q, theta.r, theta.radius)\\n  sweepA = arcSweepFlag(theta.q, startA, endA)\\n  theta.mark = Path {\\n    d : arc(\\\"open\\\", startA, endA, (theta.radius, theta.radius), 0, 0, sweepA)\\n    strokeWidth : 2.0\\n    strokeColor : Colors.darkpurple\\n    -- fillColor : #ffffff40\\n  }\\n  theta.mark below theta.side1, theta.side2\\n}\\n\\nforall Segment s\\nwhere s := PerpendicularBisector(s2, p)\\nwith Segment s2; Point p {\\n  override s.icon = Line {\\n    end : p.icon.center\\n    startArrowhead: \\\"straight\\\"\\n    startArrowheadSize: const.arrowheadSize\\n    strokeColor : Colors.darkpurple\\n    strokeWidth : const.strokeWidth\\n  }\\n  startA = ptOnLine(s.icon.end, s.icon.start, const.thetaRadius)\\n  endA = ptOnLine(s.icon.end, s2.icon.end, const.thetaRadius)\\n  sweepA = arcSweepFlag(s.icon.end, startA, endA)\\n\\n  markSize = 10\\n  override s.mark = Path {\\n    d : pathFromPoints(\\\"open\\\", [ptOnLine(s.icon.end, s.icon.start, markSize), innerPointOffset(s.icon.end, s.icon.start, s2.icon.end, markSize), ptOnLine(s.icon.end, s2.icon.end, markSize)])\\n    strokeWidth : 2.0\\n    strokeColor : Colors.black\\n  }\\n\\n  ensure disjoint(s.icon, p.text)\\n  ensure perpendicular(s.icon.start, s.icon.end, s2.icon.end)\\n  ensure equal(norm(s.icon.end - s.icon.start), const.rayLength)\\n}\\n\\nforall Point p\\nwhere p := Midpoint(l)\\nwith Linelike l {\\n  override p.vec = midpoint(l.icon.start, l.icon.end)\\n  override p.icon.fillColor = Colors.white\\n  override p.icon.strokeColor = Colors.black\\n  override p.icon.strokeWidth = 1\\n  layer p.icon above l.icon\\n  ensure disjoint(l.icon, p.text)\\n}\\n\\nforall Ray r\\nwith Angle theta\\nwhere r := Bisector(theta) {\\n  override r.icon.strokeColor = Colors.darkpurple\\n}\\n\";\n//# sourceMappingURL=euclidean-teaser.style.js.map","import substance from \"./teaser.substance.js\";\nimport style0, { resolver as resolver0 } from \"./euclidean-teaser.style.js\";\nimport domain from \"./geometry.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"StromboliCat61816\"\n};\n//# sourceMappingURL=siggraph-teaser.trio.js.map"],"names":["substance","resolver","makeResolver","style0","siggraphTeaser_trio","resolver0","domain"],"mappings":"0HAAA,MAAAA,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eCCFC,EAAWC,EAAa,iBAAiB,EACtDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCAC,EAAA,CACX,UAAAJ,EACA,MAAO,CACH,CAAE,SAAUG,EAAQ,SAAUE,CAAW,CAC5C,EACD,OAAAC,EACA,UAAW,mBACf"}