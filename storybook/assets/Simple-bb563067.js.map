{"version":3,"file":"Simple-bb563067.js","sources":["../../../core/dist/renderer/AttrMapSvg.js","../../../core/dist/renderer/AttrHelper.js","../../../core/dist/renderer/Circle.js","../../../core/dist/renderer/dragUtils.js","../../../core/dist/renderer/Ellipse.js","../../../core/dist/renderer/Equation.js","../../../core/dist/renderer/not_found.js","../../../core/dist/renderer/util.js","../../../core/dist/renderer/Image.js","../../../core/dist/renderer/Line.js","../../../core/dist/renderer/Path.js","../../../core/dist/renderer/Polygon.js","../../../core/dist/renderer/Polyline.js","../../../core/dist/renderer/Rectangle.js","../../../core/dist/renderer/Text.js","../../../core/dist/renderer/Renderer.js","../../../core/dist/index.js","../../src/fetchPathResolver.ts","../../src/Simple.tsx"],"sourcesContent":["/**\n * Mapping from internal \"non-kebab\" Penrose names to SVG \"kebab\" names\n */\nexport const attrMapSvg = {\n    accentHeight: \"accent-height\",\n    alignmentBaseline: \"alignment-baseline\",\n    arabicForm: \"arabic-form\",\n    baselineShift: \"baseline-shift\",\n    capHeight: \"cap-height\",\n    clipPath: \"clip-path\",\n    clipRule: \"clip-rule\",\n    colorInterpolation: \"color-interpolation\",\n    colorInterpolationFilters: \"color-interpolation-filters\",\n    colorProfile: \"color-profile\",\n    colorRendering: \"color-rendering\",\n    dominantBaseline: \"dominant-baseline\",\n    enableBackground: \"enable-background\",\n    fillOpacity: \"fill-opacity\",\n    fillRule: \"fill-rule\",\n    floodColor: \"flood-color\",\n    floodOpacity: \"flood-opacity\",\n    fontFamily: \"font-family\",\n    fontSize: \"font-size\",\n    fontSizeAdjust: \"font-size-adjust\",\n    fontStretch: \"font-stretch\",\n    fontStyle: \"font-style\",\n    fontVariant: \"font-variant\",\n    fontWeight: \"font-weight\",\n    glyphName: \"glyph-name\",\n    glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n    glyphOrientationVertical: \"glyph-orientation-vertical\",\n    horizAdvX: \"horiz-adv-x\",\n    horizOriginX: \"horiz-origin-x\",\n    imageRendering: \"image-rendering\",\n    letterSpacing: \"letter-spacing\",\n    lightingColor: \"lighting-color\",\n    markerEnd: \"marker-end\",\n    markerMid: \"marker-mid\",\n    markerStart: \"marker-start\",\n    overlinePosition: \"overline-position\",\n    overlineThickness: \"overline-thickness\",\n    panose1: \"panose-1\",\n    paintOrder: \"paint-order\",\n    pointerEvents: \"pointer-events\",\n    renderingIntent: \"rendering-intent\",\n    shapeRendering: \"shape-rendering\",\n    stopColor: \"stop-color\",\n    stopOpacity: \"stop-opacity\",\n    strikethroughPosition: \"strikethrough-position\",\n    strikethroughThickness: \"strikethrough-thickness\",\n    strokeDasharray: \"stroke-dasharray\",\n    strokeDashoffset: \"stroke-dashoffset\",\n    strokeLinecap: \"stroke-linecap\",\n    strokeLinejoin: \"stroke-linejoin\",\n    strokeMiterlimit: \"stroke-miterlimit\",\n    strokeOpacity: \"stroke-opacity\",\n    strokeWidth: \"stroke-width\",\n    textAnchor: \"text-anchor\",\n    textDecoration: \"text-decoration\",\n    textRendering: \"text-rendering\",\n    transformOrigin: \"transform-origin\",\n    underlinePosition: \"underline-position\",\n    underlineThickness: \"underline-thickness\",\n    unicodeBidi: \"unicode-bidi\",\n    unicodeRange: \"unicode-range\",\n    unitsPerEm: \"units-per-em\",\n    vAlphabetic: \"v-alphabetic\",\n    vHanging: \"v-hanging\",\n    vIdeographic: \"v-ideographic\",\n    vMathematical: \"v-mathematical\",\n    vectorEffect: \"vector-effect\",\n    vertAdvY: \"vert-adv-y\",\n    vertOriginX: \"vert-origin-x\",\n    vertOriginY: \"vert-origin-y\",\n    wordSpacing: \"word-spacing\",\n    writingMode: \"writing-mode\",\n};\n//# sourceMappingURL=AttrMapSvg.js.map","/**\n * Provides an assortment of utility functions shared across shapes that computes\n * output SVG properties using the optimized shape properties as input.\n */\nimport { toFontRule } from \"../utils/CollectLabels\";\nimport { isKeyOf, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util\";\nimport { attrMapSvg } from \"./AttrMapSvg\";\n/**\n * Auto-map to SVG any input properties for which we lack specific logic.\n *\n * Apply a map, AttrMapSvg, to perform any target-specific property name translation,\n * i.e., map from Penrose camel case formal to SVG mixed-case/kebab format.  Property names\n * not found in the map are mapped straight across.\n *\n * Note: Right now we are neither validating the SVG property names nor its contents.  The\n * thinking is to add an optional validator to the end of the pipeline at some point rather\n * than implement validation for all passthrough SVG properties inside Penrose.\n *\n * Note: This is an \"escape hatch\" for \"passthrough\" SVG properties we don't currently support.\n *\n * Note: SVG property names are case sensitive.\n */\nexport const attrAutoFillSvg = (shape, elem, attrAlreadyMapped) => {\n    // Internal properties to never auto-map to SVG\n    const attrToNeverAutoMap = [\n        \"strokeStyle\",\n        \"name\",\n        \"ensureOnCanvas\",\n    ];\n    // Merge the mapped and never-map properties.  Convert to Set\n    const attrToNotAutoMap = new Set(attrAlreadyMapped.concat(attrToNeverAutoMap));\n    // Map unknown/unseen attributes with values to SVG output.\n    // This is the \"escape hatch\" for properties we don't support.\n    //\n    // NOTE: `style` is handled as a special case, because some of\n    // the built-in properties will write to it __and__ the user\n    // should be able to append to it. Therefore, we check if there's\n    // an existing value in `style` and append to it if true.\n    for (const [propKey, propVal] of shape.passthrough) {\n        if ((propVal.tag === \"StrV\" && propVal.contents === \"\") ||\n            attrToNotAutoMap.has(propKey))\n            continue;\n        if (isKeyOf(propKey, attrMapSvg)) {\n            const mappedPropKey = attrMapSvg[propKey];\n            if (!elem.hasAttribute(mappedPropKey)) {\n                elem.setAttribute(mappedPropKey, propVal.contents.toString());\n            }\n        }\n        else if (propKey === \"style\" && propVal.contents !== \"\") {\n            const style = elem.getAttribute(propKey);\n            if (style === null) {\n                elem.setAttribute(propKey, propVal.contents.toString());\n            }\n            else {\n                elem.setAttribute(propKey, `${style}${propVal.contents.toString()}`);\n            }\n        }\n        else {\n            if (!elem.hasAttribute(propKey)) {\n                elem.setAttribute(propKey, propVal.contents.toString());\n            }\n        }\n    }\n};\n/**\n * Maps fillColor --> fill, fill-opacity\n */\nexport const attrFill = (properties, elem) => {\n    const color = properties.fillColor;\n    const alpha = toSvgOpacityProperty(color.contents);\n    elem.setAttribute(\"fill\", toSvgPaintProperty(color.contents));\n    // Fill opacity only relevant if fill is present\n    if (color.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"fill-opacity\", alpha.toString());\n    }\n    return [\"fillColor\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center --> cx, cy\n */\nexport const attrCenter = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    elem.setAttribute(\"cx\", x.toString());\n    elem.setAttribute(\"cy\", y.toString());\n    return [\"center\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps scale --> transform\n */\nexport const attrScale = (properties, elem) => {\n    let scale = properties.scale.contents;\n    scale = scale || 1;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null ? `scale(${scale})` : transform + `scale{${scale}}`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"scale\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> transform\n */\nexport const attrTransformCoords = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `translate(${x - w.contents / 2}, ${y - h.contents / 2})`\n            : transform + `translate(${x - w.contents / 2}, ${y - h.contents / 2})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height --> x, y\n */\nexport const attrXY = (properties, canvasSize, elem) => {\n    const center = properties.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"x\", (x - w.contents / 2).toString());\n    elem.setAttribute(\"y\", (y - h.contents / 2).toString());\n    return [\"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps center, width, height, rotation --> transform\n *\n * Rotates a GPI by n degrees about a center\n * Note: elem must be `transform`able\n * NOTE: must be called before transform translate coords (matrix rules)\n * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform\n */\nexport const attrRotation = (properties, canvasSize, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    const center = properties.center;\n    const rotation = properties.rotation.contents;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    let transform = elem.getAttribute(\"transform\");\n    transform =\n        transform === null\n            ? `rotate(${rotation}, ${x}, ${y})`\n            : transform + `rotate(${rotation}, ${x}, ${y})`;\n    elem.setAttribute(\"transform\", transform);\n    return [\"rotation\", \"center\", \"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps width, height --> width, height\n */\nexport const attrWH = (properties, elem) => {\n    const w = properties.width;\n    const h = properties.height;\n    elem.setAttribute(\"width\", w.contents.toString());\n    elem.setAttribute(\"height\", h.contents.toString());\n    return [\"width\", \"height\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps cornerRadius --> rx\n */\nexport const attrCornerRadius = (properties, elem) => {\n    const rx = properties.cornerRadius;\n    elem.setAttribute(\"rx\", rx.contents.toString());\n    return [\"cornerRadius\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps string --> new TextNode\n */\nexport const attrString = (properties, elem) => {\n    const str = properties.string;\n    const text = document.createTextNode(str.contents.toString());\n    elem.appendChild(text);\n    return [\"string\"]; // Return array of input properties programatically mapped\n};\nexport const DASH_ARRAY = \"7,5\";\n/**\n * Maps strokeColor --> stroke, stroke-opacity\n *      strokeWidth --> stroke-width\n *      strokeDasharray, strokeStyle --> stroke-dasharray\n *      strokeLinecap --> stroke-linecap\n */\nexport const attrStroke = (properties, elem) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const strokeColor = properties.strokeColor;\n    const strokeAlpha = toSvgOpacityProperty(strokeColor.contents);\n    const thickness = properties.strokeWidth.contents;\n    elem.setAttribute(\"stroke\", toSvgPaintProperty(strokeColor.contents));\n    attrMapped.push(\"strokeColor\", \"strokeWidth\");\n    // Stroke opacity, width, and dashiness only relevant if stroke is present\n    if (strokeColor.contents.tag !== \"NONE\") {\n        elem.setAttribute(\"stroke-opacity\", strokeAlpha.toString());\n        elem.setAttribute(\"stroke-width\", thickness.toString());\n        if (\"strokeDasharray\" in properties &&\n            properties.strokeDasharray.contents !== \"\") {\n            elem.setAttribute(\"stroke-dasharray\", properties.strokeDasharray.contents);\n        }\n        else if (\"strokeStyle\" in properties &&\n            properties.strokeStyle.contents === \"dashed\") {\n            elem.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n            attrMapped.push(\"strokeDasharray\", \"strokeStyle\");\n        }\n        if (\"strokeLinecap\" in properties &&\n            properties.strokeLinecap.contents !== \"\") {\n            elem.setAttribute(\"stroke-linecap\", properties.strokeLinecap.contents);\n        }\n        else {\n            elem.setAttribute(\"stroke-linecap\", \"butt\");\n        }\n        attrMapped.push(\"strokeLinecap\");\n    }\n    return attrMapped; // Return array of input properties programatically mapped\n};\n/**\n * Maps name --> new Title\n */\nexport const attrTitle = (properties, elem) => {\n    const name = properties.name;\n    const title = document.createElementNS(\"http://www.w3.org/2000/svg\", \"title\");\n    title.textContent = name.contents;\n    elem.appendChild(title);\n    return [\"name\"]; // Return array of input properties programatically mapped\n};\n/**\n * Maps fontFamily, fontSize, fontStretch, fontStyle, fontVariant, fontWeight, lineHeight -> font\n */\nexport const attrFont = (shape, elem) => {\n    const fontString = toFontRule(shape);\n    const existingStyle = elem.getAttribute(\"style\");\n    // TODO: check if `lineHeight` is valid\n    elem.setAttribute(\"style\", existingStyle\n        ? `${existingStyle}; font: ${fontString};`\n        : `font: ${fontString};`);\n    return [\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStretch\",\n        \"fontStyle\",\n        \"fontVariant\",\n        \"fontWeight\",\n        \"lineHeigh\",\n    ]; // Return array of input properties programatically mapped\n};\n/**\n * Maps points -> points\n */\nexport const attrPolyPoints = (shape, canvasSize, elem) => {\n    const points = shape.points;\n    const pointsTransformed = points.contents.map((p) => toScreen([p[0], p[1]], canvasSize));\n    elem.setAttribute(\"points\", pointsTransformed.toString());\n    return [\"points\"];\n};\n//# sourceMappingURL=AttrHelper.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst RenderCircle = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Fill the output SVG attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    elem.setAttribute(\"r\", shape.r.contents.toString());\n    attrToNotAutoMap.push(\"r\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderCircle;\n//# sourceMappingURL=Circle.js.map","import { start } from \"@penrose/optimizer\";\n/**\n * Retrieve data from drag events and update varying state accordingly\n */\nexport const dragUpdate = (state, id, dx, dy) => {\n    const xs = [...state.varyingValues];\n    // TODO: fix dragging\n    const updated = {\n        ...state,\n        params: start(xs.length),\n        varyingValues: xs,\n    };\n    return updated;\n};\n//# sourceMappingURL=dragUtils.js.map","import { attrAutoFillSvg, attrCenter, attrFill, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst RenderEllipse = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"ellipse\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrCenter(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    elem.setAttribute(\"rx\", shape.rx.contents.toString());\n    attrToNotAutoMap.push(\"rx\");\n    elem.setAttribute(\"ry\", shape.ry.contents.toString());\n    attrToNotAutoMap.push(\"ry\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderEllipse;\n//# sourceMappingURL=Ellipse.js.map","import { getAdValueAsString } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrFill, attrRotation, attrTitle, attrTransformCoords, attrWH, } from \"./AttrHelper\";\nconst RenderEquation = (shape, { canvasSize, labels }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Indicator: pre-rendered label was found\n    let labelFound = false;\n    const retrievedLabel = labels.get(getAdValueAsString(shape.name));\n    if (retrievedLabel && retrievedLabel.tag === \"EquationData\") {\n        // Clone the retrieved node first to avoid mutating existing labels\n        const renderedLabel = retrievedLabel.rendered.cloneNode(true);\n        const g = renderedLabel.getElementsByTagName(\"g\")[0];\n        attrToNotAutoMap.push(...attrFill(shape, g));\n        // Map Width/Height\n        attrToNotAutoMap.push(...attrWH(shape, renderedLabel));\n        g.setAttribute(\"stroke\", \"none\");\n        g.setAttribute(\"stroke-width\", \"0\");\n        const fontSize = shape.fontSize;\n        renderedLabel.setAttribute(\"style\", `font-size: ${fontSize.contents}`);\n        // Append the element & indicate the rendered label was found\n        elem.appendChild(renderedLabel);\n        labelFound = true;\n    }\n    if (!labelFound) {\n        // Fallback case: generate plain-text (non-rendered) label from string\n        const txt = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n        txt.textContent = getAdValueAsString(shape.string);\n        attrToNotAutoMap.push(\"string\");\n        elem.appendChild(txt);\n        // Map the attributes we have\n        attrToNotAutoMap.push(...attrFill(shape, elem));\n        attrToNotAutoMap.push(...attrWH(shape, elem));\n    }\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderEquation;\n//# sourceMappingURL=Equation.js.map","export const image = `<?xml version='1.0' encoding='UTF-8' standalone='no'?>\n<!-- Created with Inkscape (http://www.inkscape.org/) -->\n<!-- https://commons.wikimedia.org/wiki/File:Tox_hallucin.svg -->\n<svg\n   xmlns:dc='http://purl.org/dc/elements/1.1/'\n   xmlns:cc='http://creativecommons.org/ns#'\n   xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'\n   xmlns:svg='http://www.w3.org/2000/svg'\n   xmlns='http://www.w3.org/2000/svg'\n   xmlns:xlink='http://www.w3.org/1999/xlink'\n   xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd'\n   xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape'\n   width='100%'\n   height='100%'\n   id='svg2'\n   sodipodi:version='0.32'\n preserveAspectRatio='none'  inkscape:version='0.46'\n viewBox='0 0 300 300'  version='1.0'\n   sodipodi:docname='tox hallucin.svg'\n   inkscape:output_extension='org.inkscape.output.svg.inkscape'>\n  <defs\n     id='defs4'>\n    <linearGradient\n       inkscape:collect='always'\n       id='linearGradient3191'>\n      <stop\n         style='stop-color:#ff8d00;stop-opacity:1;'\n         offset='0'\n         id='stop3193' />\n      <stop\n         style='stop-color:#ff8d00;stop-opacity:0;'\n         offset='1'\n         id='stop3195' />\n    </linearGradient>\n    <linearGradient\n       id='linearGradient3175'>\n      <stop\n         style='stop-color:#00ccff;stop-opacity:1;'\n         offset='0'\n         id='stop3177' />\n      <stop\n         style='stop-color:#ff1300;stop-opacity:0;'\n         offset='1'\n         id='stop3179' />\n    </linearGradient>\n    <linearGradient\n       id='linearGradient3155'>\n      <stop\n         style='stop-color:#ffffff;stop-opacity:1;'\n         offset='0'\n         id='stop3157' />\n      <stop\n         style='stop-color:#efff00;stop-opacity:1;'\n         offset='1'\n         id='stop3159' />\n    </linearGradient>\n    <inkscape:perspective\n       sodipodi:type='inkscape:persp3d'\n       inkscape:vp_x='0 : 526.18109 : 1'\n       inkscape:vp_y='0 : 1000 : 0'\n       inkscape:vp_z='744.09448 : 526.18109 : 1'\n       inkscape:persp3d-origin='372.04724 : 350.78739 : 1'\n       id='perspective10' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3155'\n       id='radialGradient3161'\n       cx='88.527176'\n       cy='113.77536'\n       fx='88.527176'\n       fy='113.77536'\n       r='138.2794'\n       gradientUnits='userSpaceOnUse'\n       gradientTransform='matrix(0.999944,-1.9657533,1.153884,0.5869605,-136.45929,210.24015)' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3155'\n       id='radialGradient3227'\n       gradientUnits='userSpaceOnUse'\n       gradientTransform='matrix(0.999944,-1.9657533,1.153884,0.5869605,-136.45929,210.24015)'\n       cx='88.527176'\n       cy='113.77536'\n       fx='88.527176'\n       fy='113.77536'\n       r='138.2794' />\n    <radialGradient\n       inkscape:collect='always'\n       xlink:href='#linearGradient3191'\n       id='radialGradient3197'\n       cx='70.968475'\n       cy='160.37096'\n       fx='70.968475'\n       fy='160.37096'\n       r='21.348242'\n       gradientTransform='matrix(1,0,0,0.9729729,0,4.3343583)'\n       gradientUnits='userSpaceOnUse' />\n  </defs>\n  <sodipodi:namedview\n     id='base'\n     pagecolor='#ffffff'\n     bordercolor='#666666'\n     borderopacity='1.0'\n     gridtolerance='10000'\n     guidetolerance='10'\n     objecttolerance='10'\n     inkscape:pageopacity='0.0'\n     inkscape:pageshadow='2'\n     inkscape:zoom='1.624463'\n     inkscape:cx='101.39954'\n     inkscape:cy='85.047263'\n     inkscape:document-units='px'\n     inkscape:current-layer='layer1'\n     showgrid='false'\n     inkscape:window-width='1073'\n     inkscape:window-height='720'\n     inkscape:window-x='9'\n     inkscape:window-y='37' />\n  <metadata\n     id='metadata7'>\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=''>\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource='http://purl.org/dc/dcmitype/StillImage' />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <g\n     inkscape:label='Layer 1'\n     inkscape:groupmode='layer'\n     id='layer1'>\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#efff00;fill-opacity:1.0;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path2383'\n       sodipodi:cx='149.64484'\n       sodipodi:cy='150.35516'\n       sodipodi:rx='138.2794'\n       sodipodi:ry='138.2794'\n       d='M 287.92424,150.35516 A 138.2794,138.2794 0 1 1 11.365433,150.35516 A 138.2794,138.2794 0 1 1 287.92424,150.35516 z' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3161'\n       sodipodi:cx='103.94469'\n       sodipodi:cy='104.13142'\n       sodipodi:rx='24.748737'\n       sodipodi:ry='37.476658'\n       d='M 128.69342,104.13142 A 24.748737,37.476658 0 1 1 79.19595,104.13142 A 24.748737,37.476658 0 1 1 128.69342,104.13142 z'\n       transform='matrix(-0.9582289,-0.2860021,-0.2860021,0.9582289,325.97792,44.974994)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3167'\n       sodipodi:cx='106.5'\n       sodipodi:cy='114'\n       sodipodi:rx='9.5'\n       sodipodi:ry='10'\n       d='M 116,114 A 9.5,10 0 1 1 97,114 A 9.5,10 0 1 1 116,114 z'\n       transform='matrix(1.6054105,0,0,1.4584426,27.357721,-51.363012)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#ffffff;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3168'\n       sodipodi:cx='103.94469'\n       sodipodi:cy='104.13142'\n       sodipodi:rx='24.748737'\n       sodipodi:ry='37.476658'\n       d='M 128.69342,104.13142 A 24.748737,37.476658 0 1 1 79.19595,104.13142 A 24.748737,37.476658 0 1 1 128.69342,104.13142 z'\n       transform='matrix(-0.9532299,0.302246,0.302246,0.9532299,175.23598,-14.157525)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#000000;fill-opacity:1;stroke:#000000;stroke-width:10;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3170'\n       sodipodi:cx='106.5'\n       sodipodi:cy='114'\n       sodipodi:rx='9.5'\n       sodipodi:ry='10'\n       d='M 116,114 A 9.5,10 0 1 1 97,114 A 9.5,10 0 1 1 116,114 z'\n       transform='matrix(1.5359163,0,0,1.6024784,-55.141915,-65.123921)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924528999999999;stroke:#000000;stroke-width:4.92309473;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3195'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,0.2640954,-11.044101)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:4.92309475;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3197'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,152.64503,26.616757)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924528999999999;stroke:#000000;stroke-width:4.92309473;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3199'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.8086003,0,0,0.8164126,208.91913,1.5592222)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3201'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,107.50785,6.167405)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3203'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,18.350997,91.123147)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3205'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,241.47652,68.717237)' />\n    <path\n       sodipodi:type='arc'\n       style='opacity:1;fill:#00e3ff;fill-opacity:0.47924529;stroke:#000000;stroke-width:7.66160011;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1'\n       id='path3207'\n       sodipodi:cx='45.27861'\n       sodipodi:cy='56.802517'\n       sodipodi:rx='21.939119'\n       sodipodi:ry='22.8727'\n       d='M 67.21773,56.802517 A 21.939119,22.8727 0 1 1 23.339491,56.802517 A 21.939119,22.8727 0 1 1 67.21773,56.802517 z'\n       transform='matrix(0.5225444,0,0,0.5216243,190.12964,149.00508)' />\n    <path\n       id='path3209'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 61.524095,141.5056 L 61.524095,150.8265 M 61.557643,163.12376 L 61.557643,172.44466 M 75.425271,156.87515 L 66.971345,156.87515 M 56.778194,157.01501 L 48.324268,157.01501 M 71.584095,145.37378 L 65.167078,152.13403 M 56.725303,161.07608 L 50.308286,167.83633 M 71.085092,166.09132 L 64.953634,160.27118 M 57.464465,153.35509 L 51.333007,147.53495' />\n    <path\n       id='path3221'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 86.725071,37.423625 L 86.725071,46.744525 M 86.758619,59.041785 L 86.758619,68.362685 M 100.62625,52.793175 L 92.172321,52.793175 M 81.97917,52.933035 L 73.525244,52.933035 M 96.785071,41.291805 L 90.368054,48.052055 M 81.926279,56.994105 L 75.509262,63.754355 M 96.286068,62.009345 L 90.15461,56.189205 M 82.665441,49.273115 L 76.533983,43.452975' />\n    <path\n       id='path3223'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 253.0319,128.4217 L 253.0319,137.7426 M 253.06544,150.03986 L 253.06544,159.36076 M 266.93307,143.79125 L 258.47915,143.79125 M 248.286,143.93111 L 239.83207,143.93111 M 263.0919,132.28988 L 256.67488,139.05013 M 248.2331,147.99218 L 241.81609,154.75243 M 262.59289,153.00742 L 256.46144,147.18728 M 248.97227,140.27119 L 242.84081,134.45105' />\n    <path\n       id='path3225'\n       style='fill:none;fill-rule:evenodd;stroke:#000000;stroke-width:2.7166822;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 279.70375,5.2605113 L 279.70375,14.581411 M 279.73729,26.878671 L 279.73729,36.199571 M 293.60492,20.630061 L 285.151,20.630061 M 274.95784,20.769921 L 266.50392,20.769921 M 289.76375,9.1286912 L 283.34673,15.888941 M 274.90495,24.830991 L 268.48794,31.591241 M 289.26474,29.846231 L 283.13328,24.026091 M 275.64412,17.110001 L 269.51266,11.289861'\n       inkscape:transform-center-x='-6.2757294'\n       inkscape:transform-center-y='-7.0601956' />\n    <path\n       style='fill:#ffffff;fill-opacity:0.47924529;fill-rule:evenodd;stroke:#000000;stroke-width:1.2715199px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1'\n       d='M 99.300775,203.95684 L 55.102321,211.07101 C 63.275993,251.4092 43.33167,297.03463 67.500148,296.25246 C 91.668625,295.4703 75.132299,239.93649 75.132299,227.42183 C 75.132299,214.90716 96.756726,203.17467 99.300775,203.95684 z'\n       id='path3227'\n       sodipodi:nodetypes='ccssc' />\n    <path\n       style='fill:#ffffff;fill-opacity:1;fill-rule:evenodd;stroke:#000000;stroke-width:10;stroke-linecap:butt;stroke-linejoin:bevel;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1'\n       d='M 46.678979,210.37636 C 46.678979,210.37636 61.688317,182.90612 101.76017,180.50181 C 148.43916,177.70107 158.61785,218.03349 198.85245,218.77857 C 250.19932,219.71215 256.73439,187.03686 256.73439,187.03686 L 257.66797,186.10329 C 255.4936,218.71891 214.56016,233.58514 186.79701,232.12826 C 154.98692,230.45901 145.34234,210.03157 116.69745,202.90772 C 90.073723,196.28652 46.678979,210.37636 46.678979,210.37636 z'\n       id='path3193'\n       sodipodi:nodetypes='cssccssc' />\n  </g>\n</svg>`;\n//# sourceMappingURL=not_found.js.map","import { isKeyOf } from \"../utils/Util\";\n// Refactored version of `makeIdsUnique` in https://github.com/iconfu/svg-inject/blob/064ac002930deaf96eefb95eaf953c5ef5287992/src/svg-inject.js\n// MIT License\n// Copyright (c) 2018 INCORS GmbH, the creators of iconfu.com\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nlet uniqueIdCounter = 1;\nexport const makeIdsUnique = (svgElem, onlyReferenced) => {\n    const ID_SUFFIX = \"--inject-\";\n    // Map of IRI referenceable tag names to properties that can reference them. This is defined in\n    // https://www.w3.org/TR/SVG11/linking.html#processingIRI\n    const IRI_TAG_PROPERTIES_MAP = {\n        clipPath: [\"clip-path\"],\n        \"color-profile\": null,\n        cursor: null,\n        filter: null,\n        linearGradient: [\"fill\", \"stroke\"],\n        marker: [\"marker\", \"marker-end\", \"marker-mid\", \"marker-start\"],\n        mask: null,\n        pattern: [\"fill\", \"stroke\"],\n        radialGradient: [\"fill\", \"stroke\"],\n    };\n    const idSuffix = ID_SUFFIX + uniqueIdCounter++;\n    // Regular expression for functional notations of an IRI references. This will find occurences in the form\n    // url(#anyId) or url(\"#anyId\") (for Internet Explorer) and capture the referenced ID\n    const funcIriRegex = /url\\(\"?#([a-zA-Z][\\w:.-]*)\"?\\)/g;\n    // Get all elements with an ID. The SVG spec recommends to put referenced elements inside <defs> elements, but\n    // this is not a requirement, therefore we have to search for IDs in the whole SVG.\n    const idElements = svgElem.querySelectorAll(\"[id]\");\n    let idElem;\n    // An object containing referenced IDs  as keys is used if only referenced IDs should be uniquified.\n    // If this object does not exist, all IDs will be uniquified.\n    const referencedIds = onlyReferenced\n        ? new Set()\n        : undefined;\n    const iriTagNames = new Set();\n    const iriProperties = [];\n    let changed = false;\n    let i, j;\n    if (idElements.length) {\n        // Make all IDs unique by adding the ID suffix and collect all encountered tag names\n        // that are IRI referenceable from properities.\n        for (i = 0; i < idElements.length; i++) {\n            const tagName = idElements[i].localName; // Use non-namespaced tag name\n            // Make ID unique if tag name is IRI referenceable\n            if (isKeyOf(tagName, IRI_TAG_PROPERTIES_MAP)) {\n                iriTagNames.add(tagName);\n            }\n        }\n        // Get all properties that are mapped to the found IRI referenceable tags\n        iriTagNames.forEach((tagName) => {\n            (IRI_TAG_PROPERTIES_MAP[tagName] || [tagName]).forEach(function (mappedProperty) {\n                // Add mapped properties to array of iri referencing properties.\n                // Use linear search here because the number of possible entries is very small (maximum 11)\n                if (iriProperties.indexOf(mappedProperty) < 0) {\n                    iriProperties.push(mappedProperty);\n                }\n            });\n        });\n        if (iriProperties.length) {\n            // Add \"style\" to properties, because it may contain references in the form 'style=\"fill:url(#myFill)\"'\n            iriProperties.push(\"style\");\n        }\n        // Run through all elements of the SVG and replace IDs in references.\n        // To get all descending elements, getElementsByTagName('*') seems to perform faster than querySelectorAll('*').\n        // Since svgElem.getElementsByTagName('*') getElementsByTagName not return the svg element itself, we have to handle it separately.\n        const descElements = svgElem.getElementsByTagName(\"*\");\n        let element = svgElem;\n        let propertyName;\n        let value;\n        let newValue;\n        for (i = -1; element !== null;) {\n            if (element.localName === \"style\") {\n                // If element is a style element, replace IDs in all occurences of \"url(#anyId)\" in text content\n                value = element.textContent;\n                newValue =\n                    value &&\n                        value.replace(funcIriRegex, function (_, id) {\n                            if (referencedIds) {\n                                referencedIds.add(id);\n                            }\n                            return \"url(#\" + id + idSuffix + \")\";\n                        });\n                if (newValue !== value) {\n                    element.textContent = newValue;\n                }\n            }\n            else if (element.hasAttributes()) {\n                // Run through all property names for which IDs were found\n                for (j = 0; j < iriProperties.length; j++) {\n                    propertyName = iriProperties[j];\n                    value = element.getAttribute(propertyName);\n                    newValue =\n                        value &&\n                            value.replace(funcIriRegex, function (_, id) {\n                                if (referencedIds) {\n                                    referencedIds.add(id);\n                                }\n                                return \"url(#\" + id + idSuffix + \")\";\n                            });\n                    if (newValue && newValue !== value) {\n                        element.setAttribute(propertyName, newValue);\n                    }\n                }\n                // Replace IDs in xlink:ref and href attributes\n                for (const refAttrName of [\"xlink:href\", \"href\"]) {\n                    let iri = element.getAttribute(refAttrName);\n                    if (iri && /^\\s*#/.test(iri)) {\n                        // Check if iri is non-null and internal reference\n                        iri = iri.trim();\n                        element.setAttribute(refAttrName, iri + idSuffix);\n                        if (referencedIds) {\n                            // Add ID to referenced IDs\n                            referencedIds.add(iri.substring(1));\n                        }\n                    }\n                }\n            }\n            element = descElements.item(++i);\n        }\n        for (i = 0; i < idElements.length; i++) {\n            idElem = idElements[i];\n            // If set of referenced IDs exists, make only referenced IDs unique,\n            // otherwise make all IDs unique.\n            if (!referencedIds || referencedIds.has(idElem.id)) {\n                // Add suffix to element's ID\n                idElem.id += idSuffix;\n                changed = true;\n            }\n        }\n    }\n    // return true if SVG element has changed\n    return changed;\n};\n//# sourceMappingURL=util.js.map","import { attrAutoFillSvg, attrRotation, attrTitle, attrTransformCoords, attrWH, } from \"./AttrHelper\";\nimport * as notFound from \"./not_found\";\nimport { makeIdsUnique } from \"./util\";\nconst RenderImage = async (shape, { canvasSize, pathResolver }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    const path = shape.href.contents;\n    let rawSVG = await pathResolver(path);\n    if (rawSVG === undefined) {\n        console.error(`Could not resolve image path ${path}`);\n        rawSVG = notFound.image;\n    }\n    attrToNotAutoMap.push(\"href\");\n    elem.innerHTML = rawSVG;\n    // We assume the first svg element in the file is the one to display\n    const svg = elem.querySelector(\"svg\");\n    makeIdsUnique(elem, false);\n    attrToNotAutoMap.push(...attrWH(shape, svg));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTransformCoords(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderImage;\n//# sourceMappingURL=Image.js.map","import { getArrowhead, round2, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util\";\nimport { DASH_ARRAY, attrAutoFillSvg, attrTitle } from \"./AttrHelper\";\nexport const arrowHead = (id, color, opacity, arrow, size, flip) => {\n    const marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"marker\");\n    marker.setAttribute(\"id\", id);\n    marker.setAttribute(\"markerUnits\", \"strokeWidth\");\n    marker.setAttribute(\"markerWidth\", round2(arrow.width * size).toString());\n    marker.setAttribute(\"markerHeight\", round2(arrow.height * size).toString());\n    marker.setAttribute(\"viewBox\", arrow.viewbox);\n    marker.setAttribute(\"refX\", arrow.refX.toString());\n    marker.setAttribute(\"refY\", arrow.refY.toString());\n    if (flip) {\n        marker.setAttribute(\"orient\", \"auto\");\n    }\n    else {\n        marker.setAttribute(\"orient\", \"auto-start-reverse\");\n    }\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"d\", arrow.path);\n    if (arrow.fillKind === \"stroke\") {\n        path.setAttribute(\"fill\", \"none\");\n        marker.setAttribute(\"stroke\", color);\n        marker.setAttribute(\"stroke-opacity\", opacity.toString());\n    } /* if (arrow.fillKind === \"fill\") */\n    else {\n        path.setAttribute(\"fill\", color);\n        path.setAttribute(\"fill-opacity\", opacity.toString());\n    }\n    if (arrow.style) {\n        Object.entries(arrow.style).forEach(([key, value]) => {\n            path.setAttribute(key, value);\n        });\n    }\n    marker.appendChild(path);\n    return marker;\n};\nconst makeRoomForArrows = (shape, startArrowhead, endArrowhead) => {\n    // Keep a list of which input properties we programatically mapped\n    const attrMapped = [];\n    const [lineSX, lineSY] = [shape.start.contents[0], shape.start.contents[1]];\n    const [lineEX, lineEY] = [shape.end.contents[0], shape.end.contents[1]];\n    const startArrowheadSize = shape.startArrowheadSize.contents;\n    const endArrowheadSize = shape.endArrowheadSize.contents;\n    const thickness = shape.strokeWidth.contents;\n    attrMapped.push(\"start\", \"end\", \"startArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\", \"strokeWidth\");\n    // height * size = Penrose computed arrow size\n    // multiplied by thickness since the arrow size uses markerUnits, which is strokeWidth by default:\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/markerUnits\n    const length = Math.sqrt((lineSX - lineEX) ** 2 + (lineSY - lineEY) ** 2);\n    // Subtract off the arrowHeight from each side.\n    // See https://math.stackexchange.com/a/2045181 for a derivation.\n    let arrowSX, arrowSY;\n    if (startArrowhead) {\n        const startFlip = shape.flipStartArrowhead.contents;\n        const startArrowWidth = (startFlip\n            ? startArrowhead.refX\n            : startArrowhead.width - startArrowhead.refX) *\n            startArrowheadSize *\n            thickness;\n        const dx = (startArrowWidth / length) * (lineSX - lineEX);\n        const dy = (startArrowWidth / length) * (lineSY - lineEY);\n        [arrowSX, arrowSY] = [lineSX - dx, lineSY - dy];\n    }\n    else {\n        [arrowSX, arrowSY] = [lineSX, lineSY];\n    }\n    let arrowEX, arrowEY;\n    if (endArrowhead) {\n        const endArrowWidth = (endArrowhead.width - endArrowhead.refX) * endArrowheadSize * thickness;\n        [arrowEX, arrowEY] = [\n            lineEX - (endArrowWidth / length) * (lineEX - lineSX),\n            lineEY - (endArrowWidth / length) * (lineEY - lineSY),\n        ];\n    }\n    else {\n        [arrowEX, arrowEY] = [lineEX, lineEY];\n    }\n    return [\n        [\n            [arrowSX, arrowSY],\n            [arrowEX, arrowEY],\n        ],\n        attrMapped,\n    ];\n};\nconst RenderLine = (shape, { canvasSize, namespace, variation }) => {\n    const startArrowhead = getArrowhead(shape.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.endArrowhead.contents);\n    const [[[arrowSX, arrowSY], [arrowEX, arrowEY]], attrToNotAutoMap] = makeRoomForArrows(shape, startArrowhead, endArrowhead);\n    const [sx, sy] = toScreen([arrowSX, arrowSY], canvasSize);\n    const [ex, ey] = toScreen([arrowEX, arrowEY], canvasSize);\n    const path = `M ${sx} ${sy} L ${ex} ${ey}`;\n    const color = toSvgPaintProperty(shape.strokeColor.contents);\n    const thickness = shape.strokeWidth.contents;\n    const opacity = toSvgOpacityProperty(shape.strokeColor.contents);\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    // an unique id for this instance is determined by the variation and namespace\n    const unique = `${namespace}-${variation}-${shape.name.contents}`;\n    const startArrowId = unique + \"-startArrowId\";\n    const endArrowId = unique + \"-endArrowId\";\n    if (startArrowhead) {\n        const startArrowheadSize = shape.startArrowheadSize.contents;\n        const flip = shape.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, color, opacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowheadSize = shape.endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, color, opacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"strokeColor\", \"strokeWidth\", \"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\", \"startArrowheadSize\", \"endArrowheadSize\");\n    const pathElem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    pathElem.setAttribute(\"d\", path);\n    // Opacity and width only relevant if stroke is present\n    if (shape.strokeColor.contents.tag !== \"NONE\") {\n        pathElem.setAttribute(\"stroke-opacity\", opacity.toString());\n        pathElem.setAttribute(\"stroke-width\", thickness.toString());\n    }\n    pathElem.setAttribute(\"stroke\", color);\n    // factor out an AttrHelper\n    if (shape.strokeDasharray.contents !== \"\") {\n        pathElem.setAttribute(\"stroke-dasharray\", shape.strokeDasharray.contents);\n    }\n    else if (shape.strokeStyle.contents === \"dashed\") {\n        pathElem.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n    }\n    attrToNotAutoMap.push(\"strokeDasharray\", \"strokeStyle\");\n    if (shape.strokeLinecap.contents !== \"\") {\n        pathElem.setAttribute(\"stroke-linecap\", shape.strokeLinecap.contents);\n    }\n    else {\n        pathElem.setAttribute(\"stroke-linecap\", \"butt\"); // same default as SVG\n    }\n    attrToNotAutoMap.push(\"strokeLinecap\");\n    // TODO: dedup in AttrHelper\n    if (startArrowhead) {\n        pathElem.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        pathElem.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(pathElem);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderLine;\n//# sourceMappingURL=Line.js.map","import _ from \"lodash\";\nimport { getArrowhead, toScreen, toSvgOpacityProperty, toSvgPaintProperty, } from \"../utils/Util\";\nimport { DASH_ARRAY, attrAutoFillSvg, attrTitle } from \"./AttrHelper\";\nimport { arrowHead } from \"./Line\";\nconst toPathString = (pathData, canvasSize) => pathData\n    .map((pathCmd) => {\n    const { cmd, contents } = pathCmd;\n    if (contents.length === 0 && cmd !== \"Z\") {\n        console.error(\"WARNING: empty path\");\n        return \"\";\n    }\n    const pathStr = _.flatten(\n    // the `number[]` type annotation is necessary to ensure that a compile\n    // error occurs here if more `SubPath` subtypes are added in the future\n    contents.map((c) => {\n        switch (c.tag) {\n            case \"CoordV\": {\n                return toScreen([c.contents[0], c.contents[1]], canvasSize);\n            }\n            case \"ValueV\": {\n                return c.contents;\n            }\n        }\n    })).join(\" \");\n    return `${cmd} ${pathStr}`;\n})\n    .join(\" \");\nconst Shadow = (id) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"filter\");\n    elem.setAttribute(\"id\", id);\n    elem.setAttribute(\"x\", \"0\");\n    elem.setAttribute(\"y\", \"0\");\n    elem.setAttribute(\"width\", \"200%\");\n    elem.setAttribute(\"height\", \"200%\");\n    elem.innerHTML = `\n    <feOffset result=\"offOut\" in=\"SourceAlpha\" dx=\"5\" dy=\"5\" />\n       <feGaussianBlur result=\"blurOut\" in=\"offOut\" stdDeviation=\"4\" />\n       <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" />\n       <feComponentTransfer>\n         <feFuncA type=\"linear\" slope=\"0.5\" />\n       </feComponentTransfer>\n       <feMerge>\n         <feMergeNode />\n         <feMergeNode in=\"SourceGraphic\" />\n       </feMerge>\n    `;\n    return elem;\n};\nexport const RenderPath = (shape, { canvasSize }) => {\n    // TODO: distinguish between fill opacity and stroke opacity\n    const startArrowId = shape.name.contents + \"-startArrowId\";\n    const endArrowId = shape.name.contents + \"-endArrowId\";\n    const shadowId = shape.name.contents + \"-shadow\";\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const strokeWidth = shape.strokeWidth.contents;\n    const strokeColor = toSvgPaintProperty(shape.strokeColor.contents);\n    const strokeOpacity = toSvgOpacityProperty(shape.strokeColor.contents);\n    const fillColor = toSvgPaintProperty(shape.fillColor.contents);\n    const fillOpacity = toSvgOpacityProperty(shape.fillColor.contents);\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    const startArrowhead = getArrowhead(shape.startArrowhead.contents);\n    const endArrowhead = getArrowhead(shape.endArrowhead.contents);\n    if (startArrowhead) {\n        const startArrowId = shape.name.contents + \"-startArrowId\";\n        const startArrowheadSize = shape.startArrowheadSize.contents;\n        const flip = shape.flipStartArrowhead.contents;\n        elem.appendChild(arrowHead(startArrowId, strokeColor, strokeOpacity, startArrowhead, startArrowheadSize, flip));\n    }\n    if (endArrowhead) {\n        const endArrowId = shape.name.contents + \"-endArrowId\";\n        const endArrowheadSize = shape.endArrowheadSize.contents;\n        elem.appendChild(arrowHead(endArrowId, strokeColor, strokeOpacity, endArrowhead, endArrowheadSize, false));\n    }\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"name\", \"strokeColor\", \"startArrowhead\", \"flipStartArrowhead\", \"endArrowhead\");\n    elem.appendChild(Shadow(shadowId));\n    const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    path.setAttribute(\"stroke\", strokeColor);\n    path.setAttribute(\"fill\", fillColor);\n    attrToNotAutoMap.push(\"fillColor\", \"strokeColor\");\n    // Stroke opacity and width only relevant if paint is present\n    if (shape.strokeColor.contents.tag !== \"NONE\") {\n        path.setAttribute(\"stroke-width\", strokeWidth.toString());\n        path.setAttribute(\"stroke-opacity\", strokeOpacity.toString());\n        attrToNotAutoMap.push(\"strokeColor\", \"strokeWidth\");\n    }\n    // Fill opacity only relevant if paint is present\n    if (shape.fillColor.contents.tag !== \"NONE\") {\n        path.setAttribute(\"fill-opacity\", fillOpacity.toString());\n        attrToNotAutoMap.push(\"fillColor\");\n    }\n    // factor out an AttrHelper\n    if (\"strokeDasharray\" in shape && shape.strokeDasharray.contents !== \"\") {\n        path.setAttribute(\"stroke-dasharray\", shape.strokeDasharray.contents);\n    }\n    else if (shape.strokeStyle.contents === \"dashed\") {\n        path.setAttribute(\"stroke-dasharray\", DASH_ARRAY.toString());\n    }\n    attrToNotAutoMap.push(\"strokeDasharray\", \"strokeStyle\");\n    // TODO: ded\n    path.setAttribute(\"d\", toPathString(shape.d.contents, canvasSize));\n    attrToNotAutoMap.push(\"d\");\n    if (startArrowhead) {\n        path.setAttribute(\"marker-start\", `url(#${startArrowId})`);\n        attrToNotAutoMap.push(\"startArrowhead\");\n    }\n    if (endArrowhead) {\n        path.setAttribute(\"marker-end\", `url(#${endArrowId})`);\n        attrToNotAutoMap.push(\"endArrowhead\");\n    }\n    elem.appendChild(path);\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPath;\n//# sourceMappingURL=Path.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst RenderPolygon = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polygon\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPolygon;\n//# sourceMappingURL=Polygon.js.map","import { attrAutoFillSvg, attrFill, attrPolyPoints, attrScale, attrStroke, attrTitle, } from \"./AttrHelper\";\nconst RenderPolyline = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"polyline\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrScale(shape, elem));\n    attrToNotAutoMap.push(...attrPolyPoints(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderPolyline;\n//# sourceMappingURL=Polyline.js.map","import { attrAutoFillSvg, attrCornerRadius, attrFill, attrRotation, attrStroke, attrTitle, attrWH, attrXY, } from \"./AttrHelper\";\nconst RenderRectangle = (shape, { canvasSize }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(...attrXY(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrWH(shape, elem));\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrCornerRadius(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderRectangle;\n//# sourceMappingURL=Rectangle.js.map","import { toScreen } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrFill, attrFont, attrRotation, attrString, attrStroke, attrTitle, attrWH, } from \"./AttrHelper\";\nconst RenderText = (shape, { canvasSize, labels }) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    // Keep track of which input properties we programatically mapped\n    const attrToNotAutoMap = [];\n    // Map/Fill the shape attributes while keeping track of input properties mapped\n    attrToNotAutoMap.push(\"x\", \"y\");\n    attrToNotAutoMap.push(...attrFill(shape, elem));\n    attrToNotAutoMap.push(...attrStroke(shape, elem));\n    attrToNotAutoMap.push(...attrTitle(shape, elem));\n    attrToNotAutoMap.push(...attrString(shape, elem));\n    attrToNotAutoMap.push(...attrRotation(shape, canvasSize, elem));\n    attrToNotAutoMap.push(...attrFont(shape, elem));\n    // Get width/height of the text if available\n    const name = shape.name;\n    const retrievedLabel = labels.get(name.contents);\n    // Directly render the text with [x, y] in screen coordinates without transforming them using `width` and `height`\n    const center = shape.center;\n    const [x, y] = toScreen([center.contents[0], center.contents[1]], canvasSize);\n    if (retrievedLabel && retrievedLabel.tag === \"TextData\") {\n        // adjust the y-coordinate of the text center s.t. it's the center of the bbox\n        // see https://user-images.githubusercontent.com/11740102/149545843-84406be2-b3dc-4294-b01f-26ef8a2098ee.png for an illustration\n        const descent = retrievedLabel.descent.contents;\n        const height = retrievedLabel.height.contents;\n        const centerY = y + (height / 2 - descent);\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", centerY.toString());\n        attrToNotAutoMap.push(...attrWH(shape, elem));\n    }\n    else {\n        elem.setAttribute(\"x\", x.toString());\n        elem.setAttribute(\"y\", y.toString());\n    }\n    elem.setAttribute(\"font-size-adjust\", shape.fontSizeAdjust.contents);\n    elem.setAttribute(\"alignment-baseline\", shape.alignmentBaseline.contents);\n    elem.setAttribute(\"dominant-baseline\", shape.dominantBaseline.contents);\n    elem.setAttribute(\"ascent\", shape.ascent.contents.toString());\n    elem.setAttribute(\"descent\", shape.descent.contents.toString());\n    elem.setAttribute(\"text-anchor\", shape.textAnchor.contents.toString());\n    elem.setAttribute(\"visibility\", shape.visibility.contents);\n    attrToNotAutoMap.push(\"fontSizeAdjust\", \"alignmentBaseline\", \"dominantBaseline\", \"ascent\", \"descent\", \"textAnchor\", \"visibility\");\n    // Directly Map across any \"unknown\" SVG properties\n    attrAutoFillSvg(shape, elem, attrToNotAutoMap);\n    return elem;\n};\nexport default RenderText;\n//# sourceMappingURL=Text.js.map","/* Renderer.ts\n *\n * A simple translation layer for turning Shapes into SVG tags.\n *\n */\nimport { isLinelike, isRectlike } from \"../contrib/Utils\";\nimport { getValueAsShapeList } from \"../utils/Util\";\nimport { attrAutoFillSvg, attrTitle } from \"./AttrHelper\";\nimport RenderCircle from \"./Circle\";\nimport { dragUpdate } from \"./dragUtils\";\nimport RenderEllipse from \"./Ellipse\";\nimport RenderEquation from \"./Equation\";\nimport RenderImage from \"./Image\";\nimport RenderLine from \"./Line\";\nimport RenderPath from \"./Path\";\nimport RenderPolygon from \"./Polygon\";\nimport RenderPolyline from \"./Polyline\";\nimport RenderRectangle from \"./Rectangle\";\nimport RenderText from \"./Text\";\n/**\n * Converts screen to relative SVG coords\n * Thanks to\n * https://www.petercollingridge.co.uk/tutorials/svg/interactive/dragging/\n * @param e\n * @param svg\n */\nconst getPosition = ({ clientX, clientY }, svg) => {\n    const CTM = svg.getScreenCTM();\n    if (CTM !== null) {\n        return { x: (clientX - CTM.e) / CTM.a, y: (clientY - CTM.f) / CTM.d };\n    }\n    return { x: 0, y: 0 };\n};\n/**\n *\n * @param state\n * @param updateState Callback for drag-updated state\n * @param pathResolver Resolves paths to static strings\n * @returns\n */\nexport const RenderInteractive = async (state, updateState, pathResolver, namespace) => {\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"width\", \"100%\");\n    svg.setAttribute(\"height\", \"100%\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"viewBox\", `0 0 ${state.canvas.width} ${state.canvas.height}`);\n    const onDrag = (id, dx, dy) => {\n        updateState(dragUpdate(state, id, dx, dy));\n    };\n    const shapes = state.computeShapes(state.varyingValues);\n    await RenderShapes(shapes, svg, {\n        labels: state.labelCache,\n        canvasSize: state.canvas.size,\n        variation: state.variation,\n        namespace,\n        pathResolver,\n    }, {\n        updateState,\n        onDrag,\n        parentSVG: svg,\n    });\n    return svg;\n};\n/**\n * Renders a static SVG of the shapes and labels.\n * @param pathResolver Resolves paths to static strings\n */\nexport const RenderStatic = async (state, pathResolver, namespace) => {\n    const { varyingValues, computeShapes, labelCache: labels, canvas, variation, } = state;\n    const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    svg.setAttribute(\"version\", \"1.2\");\n    svg.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n    svg.setAttribute(\"viewBox\", `0 0 ${canvas.width} ${canvas.height}`);\n    const shapes = computeShapes(varyingValues);\n    await RenderShapes(shapes, svg, {\n        labels,\n        canvasSize: canvas.size,\n        variation,\n        namespace,\n        pathResolver,\n    }, undefined);\n    return svg;\n};\nconst RenderGroup = async (groupShape, shapeProps, interactiveProp) => {\n    const elem = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    const subShapes = getValueAsShapeList(groupShape.shapes);\n    for (const shape of subShapes) {\n        const childSvg = await RenderShape(shape, shapeProps, interactiveProp);\n        elem.appendChild(childSvg);\n    }\n    attrAutoFillSvg(groupShape, elem, [...attrTitle(groupShape, elem), \"shapes\"]);\n    return elem;\n};\nconst RenderShapeSvg = async (shape, renderProps) => {\n    switch (shape.shapeType) {\n        case \"Circle\":\n            return RenderCircle(shape, renderProps);\n        case \"Ellipse\":\n            return RenderEllipse(shape, renderProps);\n        case \"Equation\":\n            return RenderEquation(shape, renderProps);\n        case \"Image\":\n            return RenderImage(shape, renderProps);\n        case \"Line\":\n            return RenderLine(shape, renderProps);\n        case \"Path\":\n            return RenderPath(shape, renderProps);\n        case \"Polygon\":\n            return RenderPolygon(shape, renderProps);\n        case \"Polyline\":\n            return RenderPolyline(shape, renderProps);\n        case \"Rectangle\":\n            return RenderRectangle(shape, renderProps);\n        case \"Text\":\n            return RenderText(shape, renderProps);\n    }\n};\nexport const RenderShape = async (shape, renderProps, interactiveProp) => {\n    if (shape.shapeType === \"Group\") {\n        const outSvg = await RenderGroup(shape, renderProps, interactiveProp);\n        return outSvg;\n    }\n    else {\n        const elem = await RenderShapeSvg(shape, renderProps);\n        if (!interactiveProp) {\n            return elem;\n        }\n        else {\n            const g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n            if (isLinelike(shape)) {\n                g.setAttribute(\"pointer-events\", \"visibleStroke\");\n            }\n            else if (isRectlike(shape)) {\n                g.setAttribute(\"pointer-events\", \"bounding-box\");\n            }\n            else {\n                g.setAttribute(\"pointer-events\", \"auto\");\n            }\n            g.appendChild(elem);\n            const onMouseDown = (e) => {\n                const { clientX, clientY } = e;\n                const { x: tempX, y: tempY } = getPosition({ clientX, clientY }, interactiveProp.parentSVG);\n                const { width: bboxW, height: bboxH, x: bboxX, y: bboxY, } = e.target.getBBox({ stroke: true });\n                const minX = tempX - bboxX;\n                const maxX = renderProps.canvasSize[0] - bboxW + (tempX - bboxX);\n                const minY = tempY - bboxY;\n                const maxY = renderProps.canvasSize[1] - bboxH + (tempY - bboxY);\n                g.setAttribute(\"opacity\", \"0.5\");\n                let dx = 0, dy = 0;\n                const onMouseMove = (e) => {\n                    const { x, y } = getPosition(e, interactiveProp.parentSVG);\n                    const constrainedX = clamp(x, minX, maxX);\n                    const constrainedY = clamp(y, minY, maxY);\n                    dx = constrainedX - tempX;\n                    dy = tempY - constrainedY;\n                    g.setAttribute(`transform`, `translate(${dx},${-dy})`);\n                };\n                const onMouseUp = () => {\n                    g.setAttribute(\"opacity\", \"1\");\n                    document.removeEventListener(\"mouseup\", onMouseUp);\n                    document.removeEventListener(\"mousemove\", onMouseMove);\n                    interactiveProp.onDrag(shape.name.contents, dx, dy);\n                };\n                document.addEventListener(\"mouseup\", onMouseUp);\n                document.addEventListener(\"mousemove\", onMouseMove);\n            };\n            g.addEventListener(\"mousedown\", onMouseDown);\n            return g;\n        }\n    }\n};\nconst RenderShapes = async (shapes, svg, renderProps, interactiveProp) => {\n    for (const shape of shapes) {\n        const elem = await RenderShape(shape, renderProps, interactiveProp);\n        svg.appendChild(elem);\n    }\n};\nconst clamp = (x, min, max) => Math.min(Math.max(x, min), max);\n//# sourceMappingURL=Renderer.js.map","import { start, stepUntil } from \"@penrose/optimizer\";\nimport seedrandom from \"seedrandom\";\nimport { compileDomain } from \"./compiler/Domain\";\nimport { compileStyle } from \"./compiler/Style\";\nimport { compileSubstance } from \"./compiler/Substance\";\nimport { RenderInteractive, RenderStatic, } from \"./renderer/Renderer\";\nimport { collectLabels, insertPending } from \"./utils/CollectLabels\";\nimport { andThen, err, nanError, ok, showError } from \"./utils/Error\";\nimport { safe } from \"./utils/Util\";\n/**\n * Use the current resample seed to sample all shapes in the State.\n * @param state current state\n */\nexport const resample = (state) => {\n    const rng = seedrandom(state.variation);\n    return insertPending({\n        ...state,\n        varyingValues: state.inputs.map(({ meta }) => meta.init.tag === \"Sampled\" ? meta.init.sampler(rng) : meta.init.pending),\n        currentStageIndex: 0,\n        params: start(state.varyingValues.length),\n    });\n};\nconst step = (state, numSteps) => {\n    const { constraintSets, optStages, currentStageIndex } = state;\n    const stage = optStages[currentStageIndex];\n    const masks = safe(constraintSets.get(stage), \"missing stage\");\n    const xs = new Float64Array(state.varyingValues);\n    let i = 0;\n    const params = stepUntil((x, weight, grad) => state.gradient(masks, x, weight, grad).phi, xs, state.params, () => i++ >= numSteps);\n    return { ...state, varyingValues: Array.from(xs), params };\n};\n/**\n * Take n steps in the optimizer given the current state.\n * @param state current state\n * @param numSteps number of steps to take (default: 10000)\n */\nexport const stepState = (state, numSteps = 10000) => {\n    const steppedState = step(state, numSteps);\n    if (stateConverged(steppedState) && !finalStage(steppedState)) {\n        const nextInitState = nextStage(steppedState);\n        return nextInitState;\n    }\n    else {\n        return steppedState;\n    }\n};\nexport const nextStage = (state) => {\n    if (finalStage(state)) {\n        return state;\n    }\n    else {\n        return {\n            ...state,\n            currentStageIndex: state.currentStageIndex + 1,\n            params: start(state.varyingValues.length),\n        };\n    }\n};\nexport const stepNextStage = (state, numSteps = 10000) => {\n    let currentState = state;\n    while (!(currentState.params.optStatus === \"Error\") &&\n        !stateConverged(currentState)) {\n        currentState = step(currentState, numSteps);\n    }\n    return nextStage(currentState);\n};\n/**\n * Take n steps in the optimizer given the current state.\n * @param state current state\n * @param numSteps number of steps to take (default: 10000)\n */\nexport const stepStateSafe = (state, numSteps = 10000) => {\n    const res = stepState(state, numSteps);\n    if (res.params.optStatus === \"Error\") {\n        return err({\n            errorType: \"RuntimeError\",\n            ...nanError(\"\", res),\n        });\n    }\n    return ok(res);\n};\n/**\n * Repeatedly take one step in the optimizer given the current state until convergence.\n * @param state current state\n */\nexport const stepUntilConvergence = (state, numSteps = 10000) => {\n    let currentState = state;\n    while (!(currentState.params.optStatus === \"Error\") &&\n        (!stateConverged(currentState) || !finalStage(currentState))) {\n        if (stateConverged(currentState)) {\n            currentState = nextStage(currentState);\n        }\n        currentState = stepState(currentState, numSteps);\n    }\n    if (currentState.params.optStatus === \"Error\") {\n        return err({\n            errorType: \"RuntimeError\",\n            ...nanError(\"\", currentState),\n        });\n    }\n    return ok(currentState);\n};\nconst stepUntilConvergenceOrThrow = (state) => {\n    const result = stepUntilConvergence(state);\n    if (result.isErr()) {\n        throw Error(showError(result.error));\n    }\n    else {\n        return result.value;\n    }\n};\n/**\n * Embed a static Penrose diagram in a DOM node.\n *\n * @param prog a Penrose trio and variation\n * @param node a node in the DOM tree\n * @param pathResolver a resolver function for fetching Style imports\n * @param name the name of the diagram\n */\nexport const diagram = async (prog, node, pathResolver, name) => {\n    const res = await compileTrio(prog);\n    if (res.isOk()) {\n        const state = await prepareState(res.value);\n        const optimized = stepUntilConvergenceOrThrow(state);\n        const rendered = await RenderStatic(optimized, pathResolver, name ?? \"\");\n        node.appendChild(rendered);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Embed an interactive Penrose diagram in a DOM node.\n *\n * @param prog a Penrose trio and variation\n * @param pathResolver a resolver function for fetching Style imports\n * @param node a node in the DOM tree\n * @param name the name of the diagram\n */\nexport const interactiveDiagram = async (prog, node, pathResolver, name) => {\n    const updateData = async (state) => {\n        const stepped = stepUntilConvergenceOrThrow(state);\n        const rendering = await RenderInteractive(stepped, updateData, pathResolver, name ?? \"\");\n        node.replaceChild(rendering, node.firstChild);\n    };\n    const res = await compileTrio(prog);\n    if (res.isOk()) {\n        const state = await prepareState(res.value);\n        const optimized = stepUntilConvergenceOrThrow(state);\n        const rendering = await RenderInteractive(optimized, updateData, pathResolver, name ?? \"\");\n        node.appendChild(rendering);\n    }\n    else {\n        throw Error(`Error when generating Penrose diagram: ${showError(res.error)}`);\n    }\n};\n/**\n * Given a trio of Domain, Substance, and Style programs, compile them into an initial `State`. Note that this function does _not_ evaluate the shapes. Generation of shapes is handled in `prepareState`.\n * @param domainProg a Domain program string\n * @param subProg a Substance program string\n * @param styProg a Style program string\n */\nexport const compileTrio = async (prog) => {\n    const domainRes = compileDomain(prog.domain);\n    const subRes = andThen((env) => compileSubstance(prog.substance, env), domainRes);\n    const styRes = subRes.isErr()\n        ? err(subRes.error)\n        : await compileStyle(prog.variation, prog.style, ...subRes.value);\n    return styRes;\n};\n/**\n * Collect labels and images (if applicable).\n * @param state an initial diagram state\n */\nexport const prepareState = async (state) => {\n    const labelCache = await collectLabels(state.shapes);\n    if (labelCache.isErr()) {\n        throw Error(showError(labelCache.error));\n    }\n    return insertPending({ ...state, labelCache: labelCache.value });\n};\n/**\n * Returns true if state is converged\n * @param state current state\n */\nexport const stateConverged = (state) => state.params.optStatus === \"EPConverged\";\n/**\n * Returns true if the diagram state is on the last layout stage in the layout pipeline\n * @param state current state\n */\nexport const finalStage = (state) => state.currentStageIndex === state.optStages.length - 1;\n/**\n * Returns true if state is the initial frame\n * @param state current state\n */\nexport const stateInitial = (state) => state.params.optStatus === \"NewIter\";\n/**\n * Read and flatten the registry file for Penrose examples into a list of program trios.\n *\n * @param registry JSON file of the registry\n * @param galleryOnly Only return trios where `gallery === true`\n */\nexport const readRegistry = (registry, galleryOnly) => {\n    const { substances, styles, domains, trios } = registry;\n    const res = [];\n    for (const trioEntry of trios) {\n        const { domain: dslID, style: styID, substance: subID, variation, gallery, name, } = trioEntry;\n        const domain = domains[dslID];\n        const substance = substances[subID];\n        const style = styles[styID];\n        const trio = {\n            substanceURI: registry.root + substance.URI,\n            styleURI: registry.root + style.URI,\n            domainURI: registry.root + domain.URI,\n            substanceID: subID,\n            domainID: dslID,\n            styleID: styID,\n            variation,\n            name: name ?? `${subID}-${styID}`,\n            id: `${subID}-${styID}`,\n            gallery: gallery ?? false,\n        };\n        if (!galleryOnly || trioEntry.gallery) {\n            res.push(trio);\n        }\n    }\n    return res;\n};\nconst evalGrad = (s) => {\n    const { constraintSets, optStages, currentStageIndex } = s;\n    const stage = optStages[currentStageIndex];\n    const masks = safe(constraintSets.get(stage), \"missing stage\");\n    const x = new Float64Array(s.varyingValues);\n    // we constructed `x` to throw away, so it's OK to update it in-place with the\n    // gradient after computing the energy\n    return s.gradient(masks, x, s.params.weight, x);\n};\n/**\n * Evaluate the overall energy of a `State`.\n * @param s a state\n * @returns a scalar value of the current energy\n */\nexport const evalEnergy = (s) => evalGrad(s).phi;\n// TODO: maybe don't also compute the gradient, just to throw it away\n/**\n * Evaluate a list of constraints/objectives.\n * @param s a state\n * @returns a list of the energies of the requested functions, evaluated at the `varyingValues` in the `State`\n */\nexport const evalFns = (s) => {\n    // Evaluate the energy of each requested function (of the given type) on the varying values in the state\n    const outputs = evalGrad(s);\n    // TODO: maybe don't also compute the gradient, just to throw it away\n    return { constrEngs: outputs.constraints, objEngs: outputs.objectives };\n};\nexport { checkDomain, compileDomain, parseDomain } from \"./compiler/Domain\";\nexport { checkSubstance, compileSubstance, parseSubstance, prettySubstance, } from \"./compiler/Substance\";\nexport { constrDict } from \"./contrib/Constraints\";\nexport { compDict } from \"./contrib/Functions\";\nexport { objDict } from \"./contrib/Objectives\";\nexport { RenderInteractive, RenderStatic } from \"./renderer/Renderer\";\nexport { makeCanvas, simpleContext } from \"./shapes/Samplers\";\nexport { sampleShape, shapeTypes } from \"./shapes/Shapes\";\nimport * as Value_1 from \"./types/value\";\nexport { Value_1 as Value };\nexport { showError } from \"./utils/Error\";\nexport { hexToRgba, prettyPrintExpr, prettyPrintFn, prettyPrintPath, rgbaToHex, zip2, } from \"./utils/Util\";\n//# sourceMappingURL=index.js.map","export default async function fetchResolver(\n  path: string\n): Promise<string | undefined> {\n  const response = await fetch(path);\n  if (!response.ok) {\n    console.error(`could not fetch ${path}`);\n    return undefined;\n  }\n  return await response.text();\n}\n","import {\n  compileTrio,\n  PathResolver,\n  PenroseError,\n  PenroseState,\n  prepareState,\n  RenderInteractive,\n  RenderStatic,\n  resample,\n  showError,\n  stateConverged,\n  stepState,\n  stepUntilConvergence,\n} from \"@penrose/core\";\nimport React from \"react\";\nimport fetchResolver from \"./fetchPathResolver\";\n\nexport interface SimpleProps {\n  domain: string;\n  substance: string;\n  style: string;\n  variation: string;\n  stepSize?: number;\n  interactive?: boolean; // considered true by default\n  animate?: boolean; // considered false by default\n  onFrame?: (frame: PenroseState) => void;\n  imageResolver?: PathResolver;\n  name?: string;\n}\n\nexport interface SimpleState {\n  error?: PenroseError;\n}\n\nclass Simple extends React.Component<SimpleProps, SimpleState> {\n  readonly canvasRef = React.createRef<HTMLDivElement>();\n  penroseState: PenroseState | undefined = undefined;\n  timerID: number | undefined = undefined; // for animation\n\n  constructor(props: SimpleProps) {\n    super(props);\n    this.state = {\n      error: undefined,\n    };\n  }\n\n  compile = async (): Promise<void> => {\n    this.penroseState = undefined;\n    this.setState({ error: undefined });\n    const compilerResult = await compileTrio(this.props);\n    if (compilerResult.isOk()) {\n      this.penroseState = await prepareState(compilerResult.value);\n      this.setState({ error: undefined }); // clear out errors\n    } else {\n      this.setState({ error: compilerResult.error });\n    }\n  };\n\n  converge = async (): Promise<void> => {\n    if (this.penroseState) {\n      const stepped = stepUntilConvergence(this.penroseState);\n      if (stepped.isOk()) {\n        this.penroseState = stepped.value;\n      } else {\n        this.setState({ error: stepped.error });\n      }\n    }\n  };\n\n  tick = () => {\n    if (\n      this.props.animate &&\n      this.penroseState &&\n      !stateConverged(this.penroseState)\n    ) {\n      this.penroseState = stepState(\n        this.penroseState,\n        this.props.stepSize ?? 1\n      );\n      this.renderCanvas();\n    }\n  };\n\n  componentDidMount = async () => {\n    await this.compile();\n    if (!this.props.animate) {\n      await this.converge();\n    }\n    this.renderCanvas();\n    this.timerID = window.setInterval(() => this.tick(), 1000 / 60);\n  };\n\n  componentDidUpdate = async (prevProps: SimpleProps) => {\n    // re-compile if the programs change\n    if (\n      this.props.domain !== prevProps.domain ||\n      this.props.substance !== prevProps.substance ||\n      this.props.style !== prevProps.style\n    ) {\n      await this.compile();\n      if (!this.props.animate) {\n        await this.converge();\n      }\n      this.renderCanvas();\n      return;\n    }\n\n    // update the component only if there's no error\n    // in the case of an error, they component should not attempt to re-render\n    if (this.penroseState && !this.state.error) {\n      if (\n        this.props.variation !== prevProps.variation ||\n        this.props.animate !== prevProps.animate\n      ) {\n        this.penroseState.variation = this.props.variation;\n        this.penroseState = resample(this.penroseState);\n        if (!this.props.animate) {\n          await this.converge();\n        }\n        this.renderCanvas();\n        return;\n      } else if (this.props.interactive !== prevProps.interactive) {\n        this.renderCanvas();\n        return;\n      }\n    }\n  };\n\n  componentWillUnmount = () => {\n    clearInterval(this.timerID);\n  };\n\n  renderCanvas = async () => {\n    if (this.canvasRef.current === null) {\n      return <div>rendering...</div>;\n    } else {\n      const node = this.canvasRef.current;\n      if (this.penroseState) {\n        const renderedState: SVGSVGElement = await (this.props.interactive ===\n        false\n          ? RenderStatic(\n              this.penroseState,\n              this.props.imageResolver ?? fetchResolver,\n              this.props.name ?? \"\"\n            )\n          : RenderInteractive(\n              this.penroseState,\n              async (newState: PenroseState) => {\n                this.penroseState = newState;\n                if (!this.props.animate) {\n                  await this.converge();\n                }\n                this.renderCanvas();\n              },\n              this.props.imageResolver ?? fetchResolver,\n              this.props.name ?? \"\"\n            ));\n        // to avoid overflowing the parent div, force the height and width to be 100%\n        renderedState.setAttribute(\"height\", \"100%\");\n        renderedState.setAttribute(\"width\", \"100%\");\n        if (node.firstChild !== null) {\n          node.replaceChild(renderedState, node.firstChild);\n        } else {\n          node.appendChild(renderedState);\n        }\n        // propagate state update\n        if (this.props.onFrame) {\n          this.props.onFrame(this.penroseState);\n        }\n      } else {\n        return <div>rendering...</div>;\n      }\n    }\n  };\n\n  render = () => {\n    const { error } = this.state;\n    return (\n      <div style={{ width: \"100%\", height: \"100%\" }}>\n        {!error && (\n          <div style={{ width: \"100%\", height: \"100%\" }} ref={this.canvasRef} />\n        )}\n        {error && (\n          <div style={{ padding: \"1em\", height: \"100%\" }}>\n            <div style={{ fontWeight: 700 }}>1 error:</div>\n            <div style={{ fontFamily: \"monospace\" }}>\n              {showError(error)\n                .toString()\n                .split(\"\\n\")\n                .map((line: string, key: number) => (\n                  <p key={`err-ln-${key}`} style={{ margin: 0 }}>\n                    {line}\n                  </p>\n                ))}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  };\n}\n\nexport { Simple };\n"],"names":["attrMapSvg","attrAutoFillSvg","__name","shape","elem","attrAlreadyMapped","attrToNeverAutoMap","attrToNotAutoMap","propKey","propVal","isKeyOf","mappedPropKey","style","attrFill","properties","color","alpha","toSvgOpacityProperty","toSvgPaintProperty","attrCenter","canvasSize","center","x","y","toScreen","attrScale","scale","transform","attrTransformCoords","w","h","attrXY","attrRotation","rotation","attrWH","attrCornerRadius","rx","attrString","str","text","DASH_ARRAY","attrStroke","attrMapped","strokeColor","strokeAlpha","thickness","attrTitle","name","title","attrFont","fontString","toFontRule","existingStyle","attrPolyPoints","pointsTransformed","p","RenderCircle","dragUpdate","state","id","dx","dy","xs","start","RenderEllipse","RenderEquation","labels","labelFound","retrievedLabel","getAdValueAsString","renderedLabel","g","fontSize","txt","image","uniqueIdCounter","makeIdsUnique","svgElem","onlyReferenced","ID_SUFFIX","IRI_TAG_PROPERTIES_MAP","idSuffix","funcIriRegex","idElements","idElem","referencedIds","iriTagNames","iriProperties","changed","i","j","tagName","mappedProperty","descElements","element","propertyName","value","newValue","_","refAttrName","iri","RenderImage","pathResolver","path","rawSVG","notFound.image","svg","arrowHead","opacity","arrow","size","flip","marker","round2","key","makeRoomForArrows","startArrowhead","endArrowhead","lineSX","lineSY","lineEX","lineEY","startArrowheadSize","endArrowheadSize","length","arrowSX","arrowSY","startArrowWidth","arrowEX","arrowEY","endArrowWidth","RenderLine","namespace","variation","getArrowhead","sx","sy","ex","ey","unique","startArrowId","endArrowId","pathElem","toPathString","pathData","pathCmd","cmd","contents","pathStr","c","Shadow","RenderPath","shadowId","strokeWidth","strokeOpacity","fillColor","fillOpacity","RenderPolygon","RenderPolyline","RenderRectangle","RenderText","descent","height","centerY","getPosition","clientX","clientY","CTM","RenderInteractive","updateState","onDrag","shapes","RenderShapes","RenderStatic","varyingValues","computeShapes","canvas","RenderGroup","groupShape","shapeProps","interactiveProp","subShapes","getValueAsShapeList","childSvg","RenderShape","RenderShapeSvg","renderProps","isLinelike","isRectlike","onMouseDown","e","tempX","tempY","bboxW","bboxH","bboxX","bboxY","minX","maxX","minY","maxY","onMouseMove","constrainedX","clamp","constrainedY","onMouseUp","min","max","resample","rng","seedrandom","insertPending","meta","step","numSteps","constraintSets","optStages","currentStageIndex","stage","masks","safe","params","stepUntil","weight","grad","stepState","steppedState","stateConverged","finalStage","nextStage","stepUntilConvergence","currentState","err","nanError","ok","compileTrio","prog","domainRes","compileDomain","subRes","andThen","env","compileSubstance","compileStyle","prepareState","labelCache","collectLabels","showError","fetchResolver","response","Simple","React","undefined","props","compilerResult","error","stepped","prevProps","clearInterval","_jsx","node","renderedState","newState","_jsxs","canvasRef","line"],"mappings":"sZAGO,MAAMA,EAAa,CACtB,aAAc,gBACd,kBAAmB,qBACnB,WAAY,cACZ,cAAe,iBACf,UAAW,aACX,SAAU,YACV,SAAU,YACV,mBAAoB,sBACpB,0BAA2B,8BAC3B,aAAc,gBACd,eAAgB,kBAChB,iBAAkB,oBAClB,iBAAkB,oBAClB,YAAa,eACb,SAAU,YACV,WAAY,cACZ,aAAc,gBACd,WAAY,cACZ,SAAU,YACV,eAAgB,mBAChB,YAAa,eACb,UAAW,aACX,YAAa,eACb,WAAY,cACZ,UAAW,aACX,2BAA4B,+BAC5B,yBAA0B,6BAC1B,UAAW,cACX,aAAc,iBACd,eAAgB,kBAChB,cAAe,iBACf,cAAe,iBACf,UAAW,aACX,UAAW,aACX,YAAa,eACb,iBAAkB,oBAClB,kBAAmB,qBACnB,QAAS,WACT,WAAY,cACZ,cAAe,iBACf,gBAAiB,mBACjB,eAAgB,kBAChB,UAAW,aACX,YAAa,eACb,sBAAuB,yBACvB,uBAAwB,0BACxB,gBAAiB,mBACjB,iBAAkB,oBAClB,cAAe,iBACf,eAAgB,kBAChB,iBAAkB,oBAClB,cAAe,iBACf,YAAa,eACb,WAAY,cACZ,eAAgB,kBAChB,cAAe,iBACf,gBAAiB,mBACjB,kBAAmB,qBACnB,mBAAoB,sBACpB,YAAa,eACb,aAAc,gBACd,WAAY,eACZ,YAAa,eACb,SAAU,YACV,aAAc,gBACd,cAAe,iBACf,aAAc,gBACd,SAAU,aACV,YAAa,gBACb,YAAa,gBACb,YAAa,eACb,YAAa,cACjB,ECtDaC,EAAkBC,EAAA,CAACC,EAAOC,EAAMC,IAAsB,CAE/D,MAAMC,EAAqB,CACvB,cACA,OACA,gBACR,EAEUC,EAAmB,IAAI,IAAIF,EAAkB,OAAOC,CAAkB,CAAC,EAQ7E,SAAW,CAACE,EAASC,CAAO,IAAKN,EAAM,YACnC,GAAK,EAAAM,EAAQ,MAAQ,QAAUA,EAAQ,WAAa,IAChDF,EAAiB,IAAIC,CAAO,GAEhC,GAAIE,EAAQF,EAASR,CAAU,EAAG,CAC9B,MAAMW,EAAgBX,EAAWQ,GAC5BJ,EAAK,aAAaO,CAAa,GAChCP,EAAK,aAAaO,EAAeF,EAAQ,SAAS,SAAQ,CAAE,CAEnE,SACQD,IAAY,SAAWC,EAAQ,WAAa,GAAI,CACrD,MAAMG,EAAQR,EAAK,aAAaI,CAAO,EACnCI,IAAU,KACVR,EAAK,aAAaI,EAASC,EAAQ,SAAS,SAAQ,CAAE,EAGtDL,EAAK,aAAaI,EAAS,GAAGI,IAAQH,EAAQ,SAAS,YAAY,CAE1E,MAEQL,EAAK,aAAaI,CAAO,GAC1BJ,EAAK,aAAaI,EAASC,EAAQ,SAAS,SAAQ,CAAE,CAItE,EAzC+B,mBA6ClBI,EAAWX,EAAA,CAACY,EAAYV,IAAS,CAC1C,MAAMW,EAAQD,EAAW,UACnBE,EAAQC,EAAqBF,EAAM,QAAQ,EACjD,OAAAX,EAAK,aAAa,OAAQc,EAAmBH,EAAM,QAAQ,CAAC,EAExDA,EAAM,SAAS,MAAQ,QACvBX,EAAK,aAAa,eAAgBY,EAAM,SAAU,CAAA,EAE/C,CAAC,WAAW,CACvB,EATwB,YAaXG,GAAajB,EAAA,CAACY,EAAYM,EAAYhB,IAAS,CACxD,MAAMiB,EAASP,EAAW,OACpB,CAACQ,EAAGC,CAAC,EAAIC,EAAS,CAACH,EAAO,SAAS,GAAIA,EAAO,SAAS,EAAE,EAAGD,CAAU,EAC5E,OAAAhB,EAAK,aAAa,KAAMkB,EAAE,SAAU,CAAA,EACpClB,EAAK,aAAa,KAAMmB,EAAE,SAAU,CAAA,EAC7B,CAAC,QAAQ,CACpB,EAN0B,cAUbE,GAAYvB,EAAA,CAACY,EAAYV,IAAS,CAC3C,IAAIsB,EAAQZ,EAAW,MAAM,SAC7BY,EAAQA,GAAS,EACjB,IAAIC,EAAYvB,EAAK,aAAa,WAAW,EAC7C,OAAAuB,EACIA,IAAc,KAAO,SAASD,KAAWC,EAAY,SAASD,KAClEtB,EAAK,aAAa,YAAauB,CAAS,EACjC,CAAC,OAAO,CACnB,EARyB,aAYZC,GAAsB1B,EAAA,CAACY,EAAYM,EAAYhB,IAAS,CACjE,MAAMiB,EAASP,EAAW,OACpB,CAACQ,EAAGC,CAAC,EAAIC,EAAS,CAACH,EAAO,SAAS,GAAIA,EAAO,SAAS,EAAE,EAAGD,CAAU,EACtES,EAAIf,EAAW,MACfgB,EAAIhB,EAAW,OACrB,IAAIa,EAAYvB,EAAK,aAAa,WAAW,EAC7C,OAAAuB,EACIA,IAAc,KACR,aAAaL,EAAIO,EAAE,SAAW,MAAMN,EAAIO,EAAE,SAAW,KACrDH,EAAY,aAAaL,EAAIO,EAAE,SAAW,MAAMN,EAAIO,EAAE,SAAW,KAC3E1B,EAAK,aAAa,YAAauB,CAAS,EACjC,CAAC,SAAU,QAAS,QAAQ,CACvC,EAZmC,uBAgBtBI,GAAS7B,EAAA,CAACY,EAAYM,EAAYhB,IAAS,CACpD,MAAMiB,EAASP,EAAW,OACpB,CAACQ,EAAGC,CAAC,EAAIC,EAAS,CAACH,EAAO,SAAS,GAAIA,EAAO,SAAS,EAAE,EAAGD,CAAU,EACtES,EAAIf,EAAW,MACfgB,EAAIhB,EAAW,OACrB,OAAAV,EAAK,aAAa,KAAMkB,EAAIO,EAAE,SAAW,GAAG,SAAQ,CAAE,EACtDzB,EAAK,aAAa,KAAMmB,EAAIO,EAAE,SAAW,GAAG,SAAQ,CAAE,EAC/C,CAAC,SAAU,QAAS,QAAQ,CACvC,EARsB,UAiBTE,EAAe9B,EAAA,CAACY,EAAYM,EAAYhB,IAAS,CAChDU,EAAW,MACXA,EAAW,OACrB,MAAMO,EAASP,EAAW,OACpBmB,EAAWnB,EAAW,SAAS,SAC/B,CAACQ,EAAGC,CAAC,EAAIC,EAAS,CAACH,EAAO,SAAS,GAAIA,EAAO,SAAS,EAAE,EAAGD,CAAU,EAC5E,IAAIO,EAAYvB,EAAK,aAAa,WAAW,EAC7C,OAAAuB,EACIA,IAAc,KACR,UAAUM,MAAaX,MAAMC,KAC7BI,EAAY,UAAUM,MAAaX,MAAMC,KACnDnB,EAAK,aAAa,YAAauB,CAAS,EACjC,CAAC,WAAY,SAAU,QAAS,QAAQ,CACnD,EAb4B,gBAiBfO,EAAShC,EAAA,CAACY,EAAYV,IAAS,CACxC,MAAMyB,EAAIf,EAAW,MACfgB,EAAIhB,EAAW,OACrB,OAAAV,EAAK,aAAa,QAASyB,EAAE,SAAS,SAAQ,CAAE,EAChDzB,EAAK,aAAa,SAAU0B,EAAE,SAAS,SAAQ,CAAE,EAC1C,CAAC,QAAS,QAAQ,CAC7B,EANsB,UAUTK,GAAmBjC,EAAA,CAACY,EAAYV,IAAS,CAClD,MAAMgC,EAAKtB,EAAW,aACtB,OAAAV,EAAK,aAAa,KAAMgC,EAAG,SAAS,SAAQ,CAAE,EACvC,CAAC,cAAc,CAC1B,EAJgC,oBAQnBC,GAAanC,EAAA,CAACY,EAAYV,IAAS,CAC5C,MAAMkC,EAAMxB,EAAW,OACjByB,EAAO,SAAS,eAAeD,EAAI,SAAS,SAAQ,CAAE,EAC5D,OAAAlC,EAAK,YAAYmC,CAAI,EACd,CAAC,QAAQ,CACpB,EAL0B,cAMbC,EAAa,MAObC,EAAavC,EAAA,CAACY,EAAYV,IAAS,CAE5C,MAAMsC,EAAa,CAAA,EACbC,EAAc7B,EAAW,YACzB8B,EAAc3B,EAAqB0B,EAAY,QAAQ,EACvDE,EAAY/B,EAAW,YAAY,SACzC,OAAAV,EAAK,aAAa,SAAUc,EAAmByB,EAAY,QAAQ,CAAC,EACpED,EAAW,KAAK,cAAe,aAAa,EAExCC,EAAY,SAAS,MAAQ,SAC7BvC,EAAK,aAAa,iBAAkBwC,EAAY,SAAU,CAAA,EAC1DxC,EAAK,aAAa,eAAgByC,EAAU,SAAU,CAAA,EAClD,oBAAqB/B,GACrBA,EAAW,gBAAgB,WAAa,GACxCV,EAAK,aAAa,mBAAoBU,EAAW,gBAAgB,QAAQ,EAEpE,gBAAiBA,GACtBA,EAAW,YAAY,WAAa,WACpCV,EAAK,aAAa,mBAAoBoC,EAAW,SAAU,CAAA,EAC3DE,EAAW,KAAK,kBAAmB,aAAa,GAEhD,kBAAmB5B,GACnBA,EAAW,cAAc,WAAa,GACtCV,EAAK,aAAa,iBAAkBU,EAAW,cAAc,QAAQ,EAGrEV,EAAK,aAAa,iBAAkB,MAAM,EAE9CsC,EAAW,KAAK,eAAe,GAE5BA,CACX,EA/B0B,cAmCbI,EAAY5C,EAAA,CAACY,EAAYV,IAAS,CAC3C,MAAM2C,EAAOjC,EAAW,KAClBkC,EAAQ,SAAS,gBAAgB,6BAA8B,OAAO,EAC5E,OAAAA,EAAM,YAAcD,EAAK,SACzB3C,EAAK,YAAY4C,CAAK,EACf,CAAC,MAAM,CAClB,EANyB,aAUZC,GAAW/C,EAAA,CAACC,EAAOC,IAAS,CACrC,MAAM8C,EAAaC,GAAWhD,CAAK,EAC7BiD,EAAgBhD,EAAK,aAAa,OAAO,EAE/C,OAAAA,EAAK,aAAa,QAASgD,EACrB,GAAGA,YAAwBF,KAC3B,SAASA,IAAa,EACrB,CACH,aACA,WACA,cACA,YACA,cACA,aACA,WACR,CACA,EAhBwB,YAoBXG,GAAiBnD,EAAA,CAACC,EAAOiB,EAAYhB,IAAS,CAEvD,MAAMkD,EADSnD,EAAM,OACY,SAAS,IAAKoD,GAAM/B,EAAS,CAAC+B,EAAE,GAAIA,EAAE,EAAE,EAAGnC,CAAU,CAAC,EACvF,OAAAhB,EAAK,aAAa,SAAUkD,EAAkB,SAAU,CAAA,EACjD,CAAC,QAAQ,CACpB,EAL8B,kBCvPxBE,GAAetD,EAAA,CAACC,EAAO,CAAE,WAAAiB,KAAiB,CAC5C,MAAMhB,EAAO,SAAS,gBAAgB,6BAA8B,QAAQ,EAEtEG,EAAmB,CAAA,EAEzB,OAAAA,EAAiB,KAAK,GAAGM,EAASV,EAAOC,CAAI,CAAC,EAC9CG,EAAiB,KAAK,GAAGY,GAAWhB,EAAOiB,EAAYhB,CAAI,CAAC,EAC5DG,EAAiB,KAAK,GAAGkC,EAAWtC,EAAOC,CAAI,CAAC,EAChDG,EAAiB,KAAK,GAAGuC,EAAU3C,EAAOC,CAAI,CAAC,EAC/CA,EAAK,aAAa,IAAKD,EAAM,EAAE,SAAS,SAAQ,CAAE,EAClDI,EAAiB,KAAK,GAAG,EAEzBN,EAAgBE,EAAOC,EAAMG,CAAgB,EACtCH,CACX,EAdqB,gBCGRqD,GAAavD,EAAA,CAACwD,EAAOC,EAAIC,EAAIC,IAAO,CAC7C,MAAMC,EAAK,CAAC,GAAGJ,EAAM,aAAa,EAOlC,MALgB,CACZ,GAAGA,EACH,OAAQK,EAAMD,EAAG,MAAM,EACvB,cAAeA,CACvB,CAEA,EAT0B,cCHpBE,GAAgB9D,EAAA,CAACC,EAAO,CAAE,WAAAiB,KAAiB,CAC7C,MAAMhB,EAAO,SAAS,gBAAgB,6BAA8B,SAAS,EAEvEG,EAAmB,CAAA,EAEzB,OAAAA,EAAiB,KAAK,GAAGM,EAASV,EAAOC,CAAI,CAAC,EAC9CG,EAAiB,KAAK,GAAGY,GAAWhB,EAAOiB,EAAYhB,CAAI,CAAC,EAC5DG,EAAiB,KAAK,GAAGkC,EAAWtC,EAAOC,CAAI,CAAC,EAChDG,EAAiB,KAAK,GAAGuC,EAAU3C,EAAOC,CAAI,CAAC,EAC/CA,EAAK,aAAa,KAAMD,EAAM,GAAG,SAAS,SAAQ,CAAE,EACpDI,EAAiB,KAAK,IAAI,EAC1BH,EAAK,aAAa,KAAMD,EAAM,GAAG,SAAS,SAAQ,CAAE,EACpDI,EAAiB,KAAK,IAAI,EAE1BN,EAAgBE,EAAOC,EAAMG,CAAgB,EACtCH,CACX,EAhBsB,iBCChB6D,GAAiB/D,EAAA,CAACC,EAAO,CAAE,WAAAiB,EAAY,OAAA8C,CAAM,IAAO,CACtD,MAAM9D,EAAO,SAAS,gBAAgB,6BAA8B,GAAG,EAEjEG,EAAmB,CAAA,EAEzBA,EAAiB,KAAK,GAAGyB,EAAa7B,EAAOiB,EAAYhB,CAAI,CAAC,EAC9DG,EAAiB,KAAK,GAAGqB,GAAoBzB,EAAOiB,EAAYhB,CAAI,CAAC,EACrEG,EAAiB,KAAK,GAAGuC,EAAU3C,EAAOC,CAAI,CAAC,EAE/C,IAAI+D,EAAa,GACjB,MAAMC,EAAiBF,EAAO,IAAIG,EAAmBlE,EAAM,IAAI,CAAC,EAChE,GAAIiE,GAAkBA,EAAe,MAAQ,eAAgB,CAEzD,MAAME,EAAgBF,EAAe,SAAS,UAAU,EAAI,EACtDG,EAAID,EAAc,qBAAqB,GAAG,EAAE,GAClD/D,EAAiB,KAAK,GAAGM,EAASV,EAAOoE,CAAC,CAAC,EAE3ChE,EAAiB,KAAK,GAAG2B,EAAO/B,EAAOmE,CAAa,CAAC,EACrDC,EAAE,aAAa,SAAU,MAAM,EAC/BA,EAAE,aAAa,eAAgB,GAAG,EAClC,MAAMC,EAAWrE,EAAM,SACvBmE,EAAc,aAAa,QAAS,cAAcE,EAAS,UAAU,EAErEpE,EAAK,YAAYkE,CAAa,EAC9BH,EAAa,EAChB,CACD,GAAI,CAACA,EAAY,CAEb,MAAMM,EAAM,SAAS,gBAAgB,6BAA8B,MAAM,EACzEA,EAAI,YAAcJ,EAAmBlE,EAAM,MAAM,EACjDI,EAAiB,KAAK,QAAQ,EAC9BH,EAAK,YAAYqE,CAAG,EAEpBlE,EAAiB,KAAK,GAAGM,EAASV,EAAOC,CAAI,CAAC,EAC9CG,EAAiB,KAAK,GAAG2B,EAAO/B,EAAOC,CAAI,CAAC,CAC/C,CAED,OAAAH,EAAgBE,EAAOC,EAAMG,CAAgB,EACtCH,CACX,EAvCuB,kBCFVsE,GAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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"}