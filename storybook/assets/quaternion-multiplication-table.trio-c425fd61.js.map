{"version":3,"file":"quaternion-multiplication-table.trio-c425fd61.js","sources":["../../../examples/dist/group-theory/MultiplicationTable.style.js","../../../examples/dist/group-theory/quaternion-multiplication-table.trio.js"],"sourcesContent":["import { makeResolver } from \"../resolver.js\";\nexport const resolver = makeResolver(\"group-theory\");\nexport default \"canvas {\\n    width = 240\\n    height = 200\\n}\\n\\ncolors {\\n   lightGray = rgba( .8, .8, .8, 1. )\\n   mediumGray = rgba( .6, .6, .6, 1. )\\n   darkGray = rgba( .4, .4, .4, 1. )\\n}\\n\\nglobal {\\n   scalar tableWidth = 180\\n   scalar tableHeight = 180\\n\\n   scalar boxPadding = 2.0\\n}\\n\\n-- draw each group element as a label for a row and column\\nforall Element g\\n{\\n   scalar m = match_id\\n   scalar n = match_total\\n\\n   -- associate each group element with a value t ∈ [0,1]\\n   scalar g.t = m / n\\n\\n   -- compute horizontal/vertical coordinates u/v for each element\\n   scalar g.u = ( g.t - 0.5 ) * global.tableHeight\\n   scalar g.v = ( (1.-g.t) - 0.5 ) * global.tableWidth\\n\\n   -- compute box widths/heights (for later use by cascading rules)\\n   scalar g.width = global.tableWidth / n\\n   scalar g.height= global.tableHeight / n\\n\\n   -- define a color associated with this element\\n\\n   -- -- Random colors\\n   -- scalar g.R = ?\\n   -- scalar g.G = ?\\n   -- scalar g.B = ?\\n   -- ensure inRange( g.R, 0, 1 )\\n   -- ensure inRange( g.G, 0, 1 )\\n   -- ensure inRange( g.B, 0, 1 )\\n\\n   -- -- Rainbow colors\\n   -- scalar π = MathPI()\\n   -- scalar θ = 2.*π * g.t\\n   -- scalar φ = 2.*π/3.\\n   -- scalar g.R = .5 + .5*cos(θ + 0.*φ)\\n   -- scalar g.G = .5 + .5*cos(θ + 2.*φ)\\n   -- scalar g.B = .5 + .5*cos(θ + 4.*φ)\\n   \\n     -- \\\"Hot\\\" colors\\n     scalar T = .1 + .8*(1.-g.t)\\n     scalar s = max(0,min(1,T)) -- clamp to [0,1]\\n     scalar g.R = 1-sqr(1-max(0,min(1,3*T)))\\n     scalar g.G = 3.*s*s - 2.*s*s*s\\n     scalar g.B = max(0,min(1,3*T - 2))\\n\\n   color g.boxColor = rgba( g.R, g.G, g.B, .75 )\\n   color g.labelColor= rgba( .75*g.R, .75*g.G, .75*g.B, 1. )\\n\\n   shape g.rowLabel = Equation {\\n       string: g.label\\n       center: (-global.tableWidth/2, g.v )\\n       fontSize: \\\"8px\\\"\\n       fillColor: colors.darkGray\\n   }\\n\\n   shape g.colLabel = Equation {\\n       string: g.label\\n       center: (g.u, global.tableHeight/2)\\n       fontSize: \\\"8px\\\"\\n       fillColor: colors.darkGray\\n   }\\n}\\n\\n-- -- if colors are chosen randomly, encourage them to be far apart in RGB space\\n-- forall Element a; Element b\\n-- {\\n--    encourage equal( 0, 1./abs(a.R-b.R) )\\n--    encourage equal( 0, 1./abs(a.G-b.G) )\\n--    encourage equal( 0, 1./abs(a.B-b.B) )\\n-- }\\n\\n-- draw a box for each product in the multiplication table\\nforall Element a; Element b; Element c\\nwhere IsProduct( a, b, c )\\n{\\n   shape productShape = Rectangle {\\n      center: ( b.u, c.v )\\n      width: a.width - global.boxPadding\\n      height: a.height - global.boxPadding\\n      cornerRadius: 2.0\\n      fillColor: a.boxColor\\n   }\\n\\n   shape productText = Equation {\\n      string: a.label\\n      center: productShape.center\\n      fontSize: \\\"8px\\\"\\n      fillColor: a.labelColor\\n   }\\n}\\n\\n-- draw a box for each product in the multiplication table\\n-- (since we can't match on non-distinct tuples, we must duplicate and specialize the rule for distinct tuples)\\nforall Element a; Element e\\nwhere IsProduct( a, e, a )\\n{\\n   shape productShape = Rectangle {\\n      center: ( e.u, a.v )\\n      width: a.width - global.boxPadding\\n      height: a.height - global.boxPadding\\n      cornerRadius: 2.0\\n      fillColor: a.boxColor\\n   }\\n\\n   shape productText = Equation {\\n      string: a.label\\n      center: productShape.center\\n      fontSize: \\\"8px\\\"\\n      fillColor: a.labelColor\\n   }\\n}\\n\\n-- draw a box for each product in the multiplication table\\n-- (since we can't match on non-distinct tuples, we must duplicate and specialize the rule for distinct tuples)\\nforall Element a; Element e\\nwhere IsProduct( a, a, e )\\n{\\n   shape productShape = Rectangle {\\n      center: ( a.u, e.v )\\n      width: a.width - global.boxPadding\\n      height: a.height - global.boxPadding\\n      cornerRadius: 2.0\\n      fillColor: a.boxColor\\n   }\\n\\n   shape productText = Equation {\\n      string: a.label\\n      center: productShape.center\\n      fontSize: \\\"8px\\\"\\n      fillColor: a.labelColor\\n   }\\n}\\n\\n-- draw a box for each product in the multiplication table\\n-- (since we can't match on non-distinct tuples, we must duplicate and specialize the rule for distinct tuples)\\nforall Element a; Element b\\nwhere IsProduct( a, b, b )\\n{\\n   shape productShape = Rectangle {\\n      center: ( b.u, b.v )\\n      width: a.width - global.boxPadding\\n      height: a.height - global.boxPadding\\n      cornerRadius: 2.0\\n      fillColor: a.boxColor\\n   }\\n\\n   shape productText = Equation {\\n      string: a.label\\n      center: productShape.center\\n      fontSize: \\\"8px\\\"\\n      fillColor: a.labelColor\\n   }\\n}\\n\\n-- draw a box for each product in the multiplication table\\n-- (since we can't match on non-distinct tuples, we must duplicate and specialize the rule for distinct tuples)\\nforall Element e\\nwhere IsProduct( e, e, e )\\n{\\n   shape productShape = Rectangle {\\n      center: ( e.u, e.v )\\n      width: e.width - global.boxPadding\\n      height: e.height - global.boxPadding\\n      cornerRadius: 2.0\\n      fillColor: e.boxColor\\n   }\\n\\n   shape productText = Equation {\\n      string: e.label\\n      center: productShape.center\\n      fontSize: \\\"8px\\\"\\n      fillColor: e.labelColor\\n   }\\n}\\n\";\n//# sourceMappingURL=MultiplicationTable.style.js.map","import substance from \"./groups/quaternions.substance.js\";\nimport style0, { resolver as resolver0 } from \"./MultiplicationTable.style.js\";\nimport domain from \"./Group.domain.js\";\nexport default {\n    substance,\n    style: [\n        { contents: style0, resolver: resolver0 },\n    ],\n    domain,\n    variation: \"MeadowbrookChimpanzee02726\",\n    excludeWarnings: []\n};\n//# sourceMappingURL=quaternion-multiplication-table.trio.js.map"],"names":["resolver","makeResolver","style0","quaternionMultiplicationTable_trio","substance","resolver0","domain"],"mappings":"8HACO,MAAMA,EAAWC,EAAa,cAAc,EACnDC,EAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECCAC,EAAA,CACX,UAAAC,EACA,MAAO,CACH,CAAE,SAAUF,EAAQ,SAAUG,CAAW,CAC5C,EACD,OAAAC,EACA,UAAW,6BACX,gBAAiB,CAAE,CACvB"}