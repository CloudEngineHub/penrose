canvas {
    width = 240
    height = 200
}

global {
   scalar dotSize = 2
   scalar padding = 5
   string labelSize = "12px"
}

-- If we take a quotient of G by H, then H effectively
-- serves as the identity element of the new group.  So,
-- let's draw it in a distinguished style (a white dot
-- rather than a black one).
forall Group G; Subgroup H
where H := Subgroup(G)
{
   shape H.icon = Circle {
      center: (?,?) -- put it wherever it makes sense with the rest of the constraints
      r: global.dotSize
      fillColor: #fff
      strokeColor: #000
      strokeWidth: 1
   }
}

-- If the subgroup has a name, label the corresponding dot
forall Group G; Subgroup H
where H := Subgroup(G); H has label
{
   shape H.labelText = Equation {
      string: H.label
      fontSize: global.labelSize
   }

   -- put the label near the dot, but not so close that it overlaps
   encourage norm( H.labelText.center - H.icon.center ) == 0
   ensure disjoint( H.labelText, H.icon, global.padding )
}


-- Assuming our (left) cosets come from a normal subgroup, they will correspond
-- to elements of the quotient group.  Draw each of them as a black dot.
forall LeftCoset C {
   shape C.icon = Circle {
      center: (?,?) -- put it wherever it makes sense with the rest of the constraints
      r: global.dotSize
      fillColor: #000
   }
}

-- If a coset has a name, use that same name for the point in the quotient group.
forall LeftCoset C
where C has label {
   shape C.labelText = Equation {
      string: C.label
      fontSize: global.labelSize
   }

   -- put the label near the dot, but not so close that it overlaps
   encourage norm( C.labelText.center - C.icon.center ) == 0
   ensure disjoint( C.labelText, C.icon, global.padding )
}

-- If both G and H have labels, label their
-- quotient using the usual slash notation
forall Group G; Subgroup H
where H := Subgroup(G); G has label; H has label
{
   shape quotientLabel = Equation {
      string: G.label + "/" + H.label
      fontSize: global.labelSize
   }
}

-- Ok, and now the moment you've been avoiding.  What kinds of arrows can
-- we draw between elements of the quotient group?  I don't want to have
-- to name generators for the quotient; just seem like it takes the magic
-- out of the picture.  Can we somehow draw arrows that are automatically
-- labeled by *all* the elements that will take one coset to another?
-- Basically what we have access to is:
--   1. the multiplication table for the original group,
--   2. the elements of the subgroup, and
--   3. the element defining each coset
-- How about this: for each element g of G, we can ask what it does to a
-- given coset aH.  In particular, we can draw an arrow from aH to (ga)H,
-- labeled with g.  If we're clever, we can just draw one arrow, and
-- group the labels (which may require us to define a "string riffle" functionâ€¦)

forall  Subgroup H; Element g; Element a; LeftCoset gH; LeftCoset agH; Element b
where gH := LeftCoset(g,H); IsProduct(b,a,g); agH := LeftCoset(b,H)
{
   vec2 x0 = gH.icon.center
   vec2 x1 = agH.icon.center
   vec2 u = unit(x1-x0)
   vec2 n = rot90(u)
   vec2 m = (x0 + x1)/2

   vec2 p0 = x0
   vec2 p1 = m + 6*n
   vec2 p2 = x1 - 5*u + 2*n

   shape arrow = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: #000
      strokeWidth: 1
      endArrowhead: "straight"
      endArrowheadSize: 0.5
   }
}

