canvas {
    width = 240
    height = 200
}

global {
   scalar dotSize = 2
   scalar padding = 5
   string labelSize = "12px"
}

-- If we take a quotient of G by H, then H effectively
-- serves as the identity element of the new group.  So,
-- let's draw it in a distinguished style (a white dot
-- rather than a black one).
forall Group G; Subgroup H
where H := Subgroup(G)
{
   shape H.icon = Circle {
      center: (?,?) -- put it wherever it makes sense with the rest of the constraints
      r: global.dotSize
      fillColor: #fff
      strokeColor: #000
      strokeWidth: 1
   }
}

-- If the subgroup has a name, label the corresponding dot
forall Group G; Subgroup H
where H := Subgroup(G); H has label
{
   shape H.labelText = Equation {
      string: H.label
      fontSize: global.labelSize
   }

   -- put the label near the dot, but not so close that it overlaps
   encourage norm( H.labelText.center - H.icon.center ) == 0
   ensure disjoint( H.labelText, H.icon, global.padding )
}


-- Assuming our (left) cosets come from a normal subgroup, they will correspond
-- to elements of the quotient group.  Draw each of them as a black dot.
forall LeftCoset C {
   shape C.icon = Circle {
      center: (?,?) -- put it wherever it makes sense with the rest of the constraints
      r: global.dotSize
      fillColor: #000
   }
}

-- If a coset has a name, use that same name for the point in the quotient group.
forall LeftCoset C
where C has label {
   shape C.labelText = Equation {
      string: C.label
      fontSize: global.labelSize
   }

   -- put the label near the dot, but not so close that it overlaps
   encourage norm( C.labelText.center - C.icon.center ) == 0
   ensure disjoint( C.labelText, C.icon, global.padding )
}

-- If both G and H have labels, label their
-- quotient using the usual slash notation
forall Group G; Subgroup H
where H := Subgroup(G); G has label; H has label
{
   shape quotientLabel = Equation {
      center: (-canvas.width, canvas.height)/2 + (20,-20)
      string: G.label + "/" + H.label
      fontSize: global.labelSize
   }
}

-- draw arrows between left cosets
forall  Subgroup H; Element g; Element a; LeftCoset gH; LeftCoset agH; Element b
where gH := LeftCoset(g,H); IsProduct(b,a,g); agH := LeftCoset(b,H)
{
   vec2 x0 = gH.icon.center
   vec2 x1 = agH.icon.center
   vec2 u = unit(x1-x0)
   vec2 n = rot90(u)
   vec2 m = (x0 + x1)/2

   vec2 p0 = x0
   vec2 p1 = m + 10*n
   vec2 p2 = x1 - 5*u + 2*n

   shape arrow = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: #000
      strokeWidth: 1
      endArrowhead: "straight"
      endArrowheadSize: 0.5
   }
}

-- draw arrows from subgroup to left cosets
forall  Subgroup H; Element g; LeftCoset gH
where gH := LeftCoset(g,H)
{
   vec2 x0 = H.icon.center
   vec2 x1 = gH.icon.center
   vec2 u = unit(x1-x0)
   vec2 n = rot90(u)
   vec2 m = (x0 + x1)/2

   vec2 p0 = x0
   vec2 p1 = m + 10*n
   vec2 p2 = x1 - 5*u + 2*n

   shape arrow = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: #000
      strokeWidth: 1
      endArrowhead: "straight"
      endArrowheadSize: 0.5
   }

   layer H.icon above arrow
   layer gH.icon above arrow
}

-- draw arrows from left cosets to subgroup
forall  Subgroup H; Element g; LeftCoset gH
where gH := LeftCoset(g,H)
{
   vec2 x0 = gH.icon.center
   vec2 x1 = H.icon.center
   vec2 u = unit(x1-x0)
   vec2 n = rot90(u)
   vec2 m = (x0 + x1)/2

   vec2 p0 = x0
   vec2 p1 = m + 10*n
   vec2 p2 = x1 - 5*u + 2*n

   shape arrow = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: #000
      strokeWidth: 1
      endArrowhead: "straight"
      endArrowheadSize: 0.5
   }

   layer H.icon above arrow
   layer gH.icon above arrow
}

-- place nodes at evenly-spaced locations
forall Subset S {
   scalar theta = 2*MathPI()*(match_id - 1)/(match_total)
   scalar r = .9 * min( canvas.width, canvas.height ) / 2.
   override S.icon.center = r*(cos(theta),sin(theta))
}

-- -- For each coset aH, collect the elements b such that bH = aH,
-- -- or equivalently such that b^-1 a = h for some element h in H.
-- -- We can then concatenate these elements' labels into a single
-- -- that labels the arrow between cosets.
-- Collect Element b into elements
-- Where IsProduct(a,b,h); In(H,h); aH := LeftCoset(a,H)
-- Foreach LeftCoset aH; Subgroup H; Element h; Element a {
--    labels = listof label from elements
-- }

