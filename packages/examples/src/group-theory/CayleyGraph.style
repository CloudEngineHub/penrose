-- Draws a Cayley graph for a group G, assuming that
--   (i) all elements g of G have been declared as an Element,
--   (ii) all generator s of G have been tagged, via IsGenerator(), and
--   (iii) the group multiplication table has been specified, via IsProduct.
-- For drawing the Cayley graph, it is not strictly necessary to specify the
-- entire multiplication table: one can instead just specify the subset of
-- the table corresponding to right-multiplication by any generator.  However,
-- for other Styles in the domain Group, it may be helpful to generate Substance
-- files that specify the full table.

canvas {
    width = 240
    height = 200
}

colors {
   white = rgba( 1., 1., 1., 1. )
   lightGray = rgba( .8, .8, .8, 1. )
   mediumGray = rgba( .6, .6, .6, 1. )
   darkGray = rgba( .4, .4, .4, 1. )
}

global {
   scalar targetEdgeLength = 40.
   scalar pathWidth = 1.
   scalar pathOutlineWidth = 3.
   string labelSize = "5px"
}

-- draw each group element as a dot
forall Element g
{
   shape g.icon = Circle {
      r: 5.0 -- radius
      fillColor: colors.lightGray
      strokeColor: colors.mediumGray
      strokeWidth: .55
      ensureOnCanvas: true
   }

   shape g.labelText = Equation {
       string: g.label
       center: g.icon.center
       fontSize: global.labelSize
       fillColor: colors.darkGray
   }
}

-- draw a circle around the identity element
forall Element e
where IsIdentity(e)
{
   shape identityMarker = Circle {
      center: e.icon.center
      r: 1.75*e.icon.r
      fillColor: rgba(0,0,0,.1)
      strokeColor: #fff
   }
   layer identityMarker below e.icon
}

 -- highlight any generating element by changing its color
 forall Element s
 where IsGenerator(s)
 {
    scalar r = random(.4,.85)
    scalar g = random(.4,.85)
    scalar b = random(.4,.85)

    override s.icon.fillColor = rgba(r,g,b,1.0)
    override s.icon.strokeColor = rgba(.7*r,.7*g,.7*b,1.0)
    override s.labelText.fillColor = s.icon.strokeColor
 }

-- encourage all nodes to avoid each other
forall Element g1; Element g2
{
   vec2 x1 = g1.icon.center
   vec2 x2 = g2.icon.center
   scalar d = norm( x1 - x2 )

   -- minimize a Coulomb potential
   encourage equal( 0., 2.*sqr(1000./d) )

   -- minimize IPC potential
   -- scalar dhat = 10.*g1.icon.r
   --encourage equal( 0., max(0, -sqr(d - dhat)*log(d/dhat))) 
}

-- rule for any two elements g1, g2 related by a generator s
forall Element g1; Element g2; Element s
where IsGenerator(s); IsProduct( g2, g1, s )
{
   -- draw an arrow from g1 to g2
   vec2 x0 = g1.icon.center
   vec2 x2 = g2.icon.center
   vec2 u = (x2-x0)/norm(x2-x0)
   vec2 n = rot90(u)
   vec2 p0 = x0
   vec2 p2 = x2 - 10*u + 3*n
   vec2 m = (p0+p2)/2
   vec2 p1 = m + 3.*n
   shape orientedPath = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: s.icon.fillColor
      endArrowhead: "straight"
      endArrowheadSize: 0.75
      strokeWidth: global.pathWidth
   }
   shape pathOutline = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: colors.white
      endArrowhead: "none"
      strokeWidth: global.pathOutlineWidth
   }
   layer pathOutline below orientedPath

   layer g1.icon above orientedPath
   layer g2.icon above orientedPath
   layer s.icon above orientedPath

   -- encourage these nodes to be close together, by minimizing a spring energy
   vec2 x1 = g1.icon.center
   scalar d = norm( x1 - x2 )
   scalar k = 1. -- spring stiffness
   scalar L = global.targetEdgeLength -- rest length
   encourage equal( 0., k*(d-L)*(d-L)/2. ) -- minimize ½ k(d-L)²
}

-- same rule as above, but catches the special case where g1 is the identity
-- (since we don't currently support matching on non-distinct tuples)
forall Element s; Element e
where IsGenerator(s); IsProduct( s, e, s )
{
   -- draw an arrow from e to s
   vec2 x0 = e.icon.center
   vec2 x2 = s.icon.center
   vec2 u = (x2-x0)/norm(x2-x0)
   vec2 n = rot90(u)
   vec2 p0 = x0
   vec2 p2 = x2 - 10*u + 3*n
   vec2 m = (p0+p2)/2
   vec2 p1 = m + 3.*n
   shape orientedPath = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: s.icon.fillColor
      endArrowhead: "straight"
      endArrowheadSize: 0.75
      strokeWidth: global.pathWidth
   }
   shape pathOutline = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: colors.white
      endArrowhead: "none"
      strokeWidth: global.pathOutlineWidth
   }
   layer pathOutline below orientedPath

   layer s.icon above orientedPath
   layer e.icon above orientedPath

   -- encourage these nodes to be close together, by minimizing a spring energy
   vec2 x1 = e.icon.center
   scalar d = norm( x1 - x2 )
   scalar k = 1. -- spring stiffness
   scalar L = global.targetEdgeLength -- rest length
   encourage equal( 0., k*(d-L)*(d-L)/2. ) -- minimize ½ k(d-L)²
}

-- same rule as above, but catches the special case where g1 = s
-- (since we don't currently support matching on non-distinct tuples)
forall Element g; Element s
where IsGenerator(s); IsProduct( g, s, s )
{
   -- draw an arrow from s to g
   vec2 x0 = s.icon.center
   vec2 x2 = g.icon.center
   vec2 u = (x2-x0)/norm(x2-x0)
   vec2 n = rot90(u)
   vec2 p0 = x0
   vec2 p2 = x2 - 10*u + 3*n
   vec2 m = (p0+p2)/2
   vec2 p1 = m + 3.*n
   shape orientedPath = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: s.icon.fillColor
      endArrowhead: "straight"
      endArrowheadSize: 0.75
      strokeWidth: global.pathWidth
   }
   shape pathOutline = Path {
      d: interpolateQuadraticFromPoints( "open", p0, p1, p2 )
      strokeColor: colors.white
      endArrowhead: "none"
      strokeWidth: global.pathOutlineWidth
   }
   layer pathOutline below orientedPath

   layer g.icon above orientedPath
   layer s.icon above orientedPath

   -- encourage these nodes to be close together, by minimizing a spring energy
   vec2 x1 = s.icon.center
   scalar d = norm( x1 - x2 )
   scalar k = 1. -- spring stiffness
   scalar L = global.targetEdgeLength -- rest length
   encourage equal( 0., k*(d-L)*(d-L)/2. ) -- minimize ½ k(d-L)²
}

-- draw each Subgroup H as a region that tries to
-- fit snugly around the elements contained in H
forall Subgroup H {

   -- pick a width/height that try to be as small as possible
   scalar w = ? -- width
   scalar h = ? -- height
   ensure w > 0
   ensure h > 0
   encourage 2*w == 0
   encourage 2*h == 0

   -- random bright color
   vec3 p = sphereRandom()
   vec3 C = .5*( abs(p[0]), abs(p[1]), abs(p[2]) )

   shape H.icon = Rectangle {
      center: (?,?)
      width: w
      height: h
      cornerRadius: 10
      fillColor: rgba( C[0], C[1], C[2], .1 )
      strokeColor: rgba( C[0], C[1], C[2], 1 )
      strokeWidth: .75*global.pathWidth
   }
}

-- make sure the region used to represent the subgroup contains all of its elements
forall Element g; Subgroup H
where In(H,g) {
   ensure contains( H.icon, g.icon, 10 )
   layer H.icon above g.icon
}

-- if the subgroup has a label, put it in the lower-left corner
forall Subgroup H
where H has label {
   shape H.labelText = Equation {
       center: H.icon.center - (H.icon.width,H.icon.height)/2 + (7,7)
       string: H.label
       fontSize: global.labelSize
       fillColor: H.icon.strokeColor
   }
}

-- Draw each coset as a rounded rectangle in the same
-- style as its corresponding subgroup, but faded out
forall Coset C; Element g; Subgroup H
where C := Coset(g,H) {

   -- pick a width/height that try to be as small as possible
   scalar w = ? -- width
   scalar h = ? -- height
   ensure w > 0
   ensure h > 0
   encourage 2*w == 0
   encourage 2*h == 0

   shape C.icon = Rectangle {
      center: (?,?)
      width: w
      height: h
      cornerRadius: H.icon.cornerRadius
      fillColor: H.icon.fillColor
      strokeColor: H.icon.strokeColor
      strokeWidth: H.icon.strokeWidth
      opacity: .4
   }
}

forall Coset C; Subgroup H; Element h; Element g; Element f
where C := Coset(g,H); In(H,h); IsProduct(f,g,h) {
   ensure contains( C.icon, f.icon, 10 )
   layer C.icon above f.icon
}
forall Coset C; Subgroup H; Element g; Element f
where C := Coset(g,H); In(H,g); IsProduct(f,g,g) {
   ensure contains( C.icon, f.icon, 10 )
   layer C.icon above f.icon
}
forall Coset C; Subgroup H; Element h; Element g
where C := Coset(g,H); In(H,h); IsProduct(g,g,h) {
   ensure contains( C.icon, g.icon, 10 )
   layer C.icon above g.icon
}

-- if the coset has a label, put it in the lower-left corner
forall Coset C
where C has label {

   vec2 labelCenter = (?,?)

   shape C.labelText = Equation {
       center: labelCenter
       string: C.label
       fontSize: global.labelSize
       fillColor: C.icon.strokeColor
   }

   ensure contains( C.icon, C.labelText, 5 )
}

forall Coset C; Subgroup H; Element h; Element g; Element f
where C has label; C := Coset(g,H); In(H,h); IsProduct(f,g,h) {
   ensure disjoint( C.labelText, f.icon, 4 )
   layer C.labelText above f.icon
}
forall Coset C; Subgroup H; Element g; Element f
where C has label; C := Coset(g,H); In(H,g); IsProduct(f,g,g) {
   ensure disjoint( C.labelText, f.icon, 4 )
   layer C.labelText above f.icon
}
forall Coset C; Subgroup H; Element h; Element g
where C has label; C := Coset(g,H); In(H,h); IsProduct(g,g,h) {
   ensure disjoint( C.labelText, g.icon, 4 )
   layer C.labelText above g.icon
}

