canvas {
  width = 240
  height = 200
}

--------------------------------------------------------------------------------
-- Constants and Styling -------------------------------------------------------
--------------------------------------------------------------------------------

colors {
   color debug = #ff6600

   -- main color for points and lines/curves
   color point = #000
   color line = #000

   -- fill color for solid regions
   color solidRegion = #1b1f8a33 -- #00000033

   -- fill and stroke color for ancillary points
   color secondaryPointFill = #fff
   color secondaryPointStroke = #000

   -- stroke color for ancillary lines
   color secondaryLine = #1b1f8a -- #888

   -- stroke color for lines/curves used to indicate
   -- geometric constructions
   color constructionLine = #000
   scalar constructionLineOpacity = 0.2
}

global {
  -- default size for vertices, points, etc.
  scalar pointSize = 2.0

  -- default width for lines/curves
  scalar lineWidth = 1

  -- width for secondary lines/curves
  scalar secondaryLineWidth = 0.75
  
  -- size of angle markers
  scalar straightAngleRadius = 10 -- 30
  scalar circularAngleRadius = 17 -- 37
  scalar bendAngleRadius = 24 -- 44

  -- size of length markers
  scalar markerOffset = 8 -- distance from marked edge/arc
  scalar markerEndcapSize = 3 -- size of straight end caps

  -- size of dashes
  string dashing = "3 4"

  -- labels
  string labelFont = "Linux Libertine O"
  string labelStyle = "italic"
  string labelSize = "9px"
  scalar labelSizeNum = 9
  scalar labelPadding = 2
}

--------------------------------------------------------------------------------
-- Shape Definitions -----------------------------------------------------------
--------------------------------------------------------------------------------

-- Vertex ----------------------------------------------------------------------

-- Draw vertices as little dots
forall Vertex v
{
  vec2 v.p = (?,?) -- dot location on canvas

  shape v.icon = Circle {
    center: v.p
    r: global.pointSize
    fillColor: colors.point
    ensureOnCanvas: false
  }
}

-- Allow dot location to be set explicitly
forall Vertex v; Number x,y
where SetPosition(v,x,y) {
   override v.p = (x,y)
}

-- Edge ------------------------------------------------------------------------

-- Draw edges as circular arcs, with the option to
-- also draw a straight line connecting endpoints
-- (using ShowStraightEdge(e)), and to hide the circular
-- arc (using HideCircularEdge(e)).
forall Edge e; Vertex u, v
where e := Edge(u,v) {

  -- Edge endpoints
  vec2 e.start = u.p
  vec2 e.end = v.p

  -- Compute the center e.c, radius e.r, and start/end angles e.theta0/theta1
  scalar e.alpha = random( -1, 1 ) * MathPI()/4 -- bend angle
  vec2 m = ( e.start + e.end )/2 -- midpoint
  scalar h = .5 / tan(e.alpha) -- unnormalized distance to circle center
  vec2 n = rot90( e.start - e.end ) -- unnormalized normal
  vec2 e.c = m + n*h -- circle center
  vec2 w0 = e.start - e.c -- vector to start point
  vec2 w1 = e.end - e.c -- vector to end point
  scalar e.theta0 = angleFrom( (1,0), w0 ) -- angle to start point
  scalar e.theta1 = e.theta0 + angleFrom( w0, w1 ) -- angle to end point
  scalar e.r = norm(w0) -- circle radius

  -- Draw the straight edge as an invisible line
  -- (can be made visible with ShowStraightEdge(e))
  shape e.straightEdge = Line {
    start: e.start
    end: e.end
    strokeColor: none()
    strokeWidth: global.secondaryLineWidth
    ensureOnCanvas: false
  }

  -- Draw circular edge as a visible arc
  -- (can be made invisible with HideCircularEdge(e))
  e.bentPath = circularArc( "open", e.c, e.r, e.theta0, e.theta1 )
  shape e.circularEdge = Path {
    d: e.bentPath
    strokeColor: colors.line
    strokeWidth: global.lineWidth
    ensureOnCanvas: false
  }
}

-- Allow edge bend angle to be set explicitly
forall Edge e; Number alpha
where SetBendAngle( e, alpha ) {
   override e.alpha = -alpha
}

-- Triangle --------------------------------------------------------------------

-- Draw triangles as regions bounded by circular arcs,
-- with the option to show the straight-edge region
-- (using ShowStraightRegion(t)) and to hide the circular
-- region (using HideCircularRegion(t)).
forall Triangle t; Edge ij, jk, ki
where t := Triangle(ij,jk,ki) {

   -- Corner locations
   t.pi = ij.start
   t.pj = jk.start
   t.pk = ki.start

   -- Region bounded by three straight segments
   shape t.straightRegion = Polygon {
     points: [ t.pi, t.pj, t.pk ]
     fillColor: none()
     strokeColor: none()
     ensureOnCanvas: false
   }

   -- Region bounded by three circular arcs
   shape t.circularRegion = Path {
     d: joinPaths([ij.bentPath, jk.bentPath, ki.bentPath])
     fillColor: colors.solidRegion
     strokeColor: none()
     ensureOnCanvas: false
   }
}

-- Angle -----------------------------------------------------------------------

-- Draw each angle marker as a circular disk, which gets
-- clipped against some other geometry to make a wedge.
forall Angle A {
   vec2 A.c = (0,0)
   scalar A.r = 20
   scalar A.theta0 = 0
   scalar A.theta1 = MathPI()/3

   shape A.disk = Circle {
      center: A.c
      r: A.r
      fillColor: colors.solidRegion
      ensureOnCanvas: false
   }
   shape A.boundary = Circle {
      center: A.c
      r: A.r
      fillColor: none()
      strokeColor: colors.secondaryLine
      strokeWidth: global.secondaryLineWidth
      ensureOnCanvas: false
   }

   -- The default mask is just the circle itself, so
   -- that an angle not assigned to any shape is still
   -- visible on canvas (as a full circle).  Other rules
   -- will overwrite this mask to draw angles for specific
   -- shapes.
   shape A.mask = Circle {
      center: A.disk.center
      r: A.disk.r
      ensureOnCanvas: false
   }
   shape A.icon = Group {
      shapes: [ A.disk ]
      clipPath: clip( A.mask )
      ensureOnCanvas: false
   }
   shape A.boundaryMask = Circle {
      center: A.disk.center
      r: 2*A.disk.r
      ensureOnCanvas: false
   }
   shape A.boundaryIcon = Group {
      shapes: [ A.boundary ]
      clipPath: clip( A.boundaryMask )
      ensureOnCanvas: false
   }
}

-- Associate an angle with the first, second, or third
-- straight corner of a straight-edge triangle.
forall Angle A; Triangle ijk
where A := FirstStraightCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
   override A.boundaryMask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
}
forall Angle A; Triangle ijk
where A := SecondStraightCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
   override A.boundaryMask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
}
forall Angle A; Triangle ijk
where A := ThirdStraightCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.straightAngleRadius
   override A.mask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
   override A.boundaryMask = Polygon {
      points: ijk.straightRegion.points
      ensureOnCanvas: false
   }
}

-- Associate an angle with the first, second, or third
-- straight corner of a circular-arc triangle.
forall Angle A; Triangle ijk
where A := FirstCircularCorner( ijk ) {
   override A.c = ijk.pi
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
   override A.boundaryMask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
}
forall Angle A; Triangle ijk
where A := SecondCircularCorner( ijk ) {
   override A.c = ijk.pj
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
   override A.boundaryMask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
}
forall Angle A; Triangle ijk
where A := ThirdCircularCorner( ijk ) {
   override A.c = ijk.pk
   override A.r = global.circularAngleRadius
   override A.mask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
   override A.boundaryMask = Path {
      d: ijk.circularRegion.d
      ensureOnCanvas: false
   }
}

-- Associate an angle with the start or end point
-- of a “bent” circular edge
forall Angle A; Edge ij
where A := StartBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.start
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      ensureOnCanvas: false
   }
   override A.boundaryMask = Path {
      d: joinPaths( [ij.bentPath] )
      ensureOnCanvas: false
   }
}
forall Angle A; Edge ij
where A := EndBendAngle( ij ) {
   override A.r = global.bendAngleRadius
   override A.c = ij.end
   override A.mask = Path {
      d: joinPaths( [ij.bentPath] )
      ensureOnCanvas: false
   }
   override A.boundaryMask = Path {
      d: joinPaths( [ij.bentPath] )
      ensureOnCanvas: false
   }
}

-- Circle ----------------------------------------------------------------------

-- Draw circles as empty circles
forall Circle C {
   vec2 C.c = (?,?)
   scalar C.r = abs(?)
   shape C.icon = Circle {
      center: C.c
      r: C.r
      fillColor: none()
      strokeColor: colors.constructionLine
      opacity: colors.constructionLineOpacity
      strokeWidth: global.lineWidth
      ensureOnCanvas: false
   }
}

-- Draw the circle associated with the arc through
-- a given edge
forall Circle C; Edge ij
where C := CircleThrough( ij ) {
   -- copy the center and radius of the
   -- edge's circular arc, so that it
   -- can be more easily referenced by
   -- rules that reference this circle
   override C.c = ij.c
   override C.r = ij.r
   override C.icon.strokeDasharray = global.dashing
}

-- Draw points as little dots
forall Point P {
   vec2 P.p = (?,?)

   shape P.icon = Circle {
      center: P.p
      r: global.pointSize
      fillColor: colors.point
      ensureOnCanvas: false
   }
}

-- Draw circle centers as "secondary points"
forall Circle C; Point P
where P := CenterOf(C) {
   override P.p = C.c
   override P.icon.fillColor = colors.secondaryPointFill
   override P.icon.strokeColor = colors.secondaryPointStroke
   override P.icon.strokeWidth = global.secondaryLineWidth
}

-- Segment ---------------------------------------------------------------------

-- Draw segments as straight lines
forall Segment S {
   vec2 S.start = (?,?)
   vec2 S.end = (?,?)

   shape S.line = Line {
      start: S.start
      end: S.end
      strokeWidth: global.lineWidth
      strokeColor: colors.line
      ensureOnCanvas: false
   }
   shape S.icon = Group {
      shapes: [S.line]
      ensureOnCanvas: false
   }
}

-- Mark the radius of a circle by drawing a line from
-- the center to an arbitrary point on the boundary
forall Segment S; Circle C
where S := RadiusOf(C) {
   vec2 u = circleRandom()
   override S.start = C.c + u*global.pointSize
   override S.end = C.c + u*C.r
   override S.line.strokeDasharray = global.dashing

   shape S.centerPoint = Circle {
      center: C.c
      r: global.pointSize
      fillColor: none()
      strokeColor: colors.constructionLine
      strokeWidth: global.secondaryLineWidth
      ensureOnCanvas: false
   }
   override S.icon = Group {
      shapes: [S.line,S.centerPoint]
      opacity: colors.constructionLineOpacity
      ensureOnCanvas: false
   }
}

-- Indicate a length by drawing a segment with endcaps
forall Segment S; Edge e
where S := LengthMarker(e) {

   -- Compute endpoints for offset marker
   vec2 p0 = e.start
   vec2 p1 = e.end
   vec2 t = unit(p1-p0) -- tangent
   vec2 n = -rot90(t) -- normal
   vec2 a = p0 + global.markerOffset*n
   vec2 b = p1 + global.markerOffset*n

   override S.start = a
   override S.end = b

   override S.line.strokeColor = colors.constructionLine

   shape markerA = Line {
      start: a - global.markerEndcapSize*n
      end: a + global.markerEndcapSize*n
      strokeColor: colors.constructionLine
      strokeWidth: S.line.strokeWidth
      ensureOnCanvas: false
   }
   shape markerB = Line {
      start: b - global.markerEndcapSize*n
      end: b + global.markerEndcapSize*n
      strokeColor: colors.constructionLine
      strokeWidth: S.line.strokeWidth
      ensureOnCanvas: false
   }
   -- Draw the three segments as a group, to make
   -- them easier to edit in external programs
   override S.icon = Group {
      shapes: [ S.line, markerA, markerB ]
      ensureOnCanvas: false
      opacity: colors.constructionLineOpacity
   }
}

-- Arc -------------------------------------------------------------------------

forall Arc A {
   scalar A.theta0 = 0
   scalar A.theta1 = MathPI()/2
   scalar A.r = 30
   vec2 A.c = (?,?)

   shape A.arc = Path {
      d: circularArc( "open", A.c, A.r, A.theta0, A.theta1 )
      strokeColor: colors.constructionLine
      strokeWidth: 1
      ensureOnCanvas: false
   }
   shape A.icon = Group {
      shapes: [A.arc]
      ensureOnCanvas: false
      opacity: colors.constructionLineOpacity
   }
}

-- Indicate an arc length by drawing an arc with endcaps
forall Arc A; Edge e
where A := ArcLengthMarker(e) {

   vec2 u0 = unitVector( e.theta0 )
   vec2 u1 = unitVector( e.theta1 )
   scalar R = e.r + global.markerOffset
   vec2 a = e.c + R*u0
   vec2 b = e.c + R*u1

   override A.c = e.c
   override A.r = R
   override A.theta0 = e.theta0
   override A.theta1 = e.theta1

   shape A.markerA = Line {
      start: a - global.markerEndcapSize*u0
      end: a + global.markerEndcapSize*u0
      strokeColor: A.arc.strokeColor
      strokeWidth: A.arc.strokeWidth
      ensureOnCanvas: false
   }
   shape A.markerB = Line {
      start: b - global.markerEndcapSize*u1
      end: b + global.markerEndcapSize*u1
      strokeColor: A.arc.strokeColor
      strokeWidth: A.arc.strokeWidth
      ensureOnCanvas: false
   }
   override A.icon = Group {
      shapes: [A.arc, A.markerA, A.markerB]
      opacity: colors.constructionLineOpacity
      ensureOnCanvas: false
   }
}

--------------------------------------------------------------------------------
-- Decoration Control ----------------------------------------------------------
--------------------------------------------------------------------------------

-- Hide/show various decorations
forall Triangle t
where ShowStraightRegion(t) {
   override t.straightRegion.fillColor = colors.solidRegion
}
forall Triangle t
where HideCircularRegion(t) {
   override t.circularRegion.fillColor = none()
}
forall Edge e
where ShowStraightEdge(e) {
   -- override e.straightEdge.strokeColor = #fff
   override e.straightEdge.strokeColor = colors.line
   override e.straightEdge.strokeDasharray = global.dashing
}
forall Edge e
where HideCircularEdge(e) {
   override e.circularEdge.strokeColor = none()
}
forall Edge e
where DeemphasizeCircularEdge(e) {
   override e.circularEdge.strokeColor = colors.constructionLine
   override e.circularEdge.opacity = colors.constructionLineOpacity
   override e.circularEdge.strokeDasharray = global.dashing
}
forall Angle A
where HideWedge( A ) {
   override A.disk.fillColor = none()
}

--------------------------------------------------------------------------------
-- Layering --------------------------------------------------------------------
--------------------------------------------------------------------------------

forall Circle C; Point P; Segment S
where P := CenterOf(C); S := RadiusOf(C) {
   layer P.icon above S.icon
   layer S.icon above C.icon
}
forall Point P; Triangle T {
   layer P.icon above T.straightRegion
   layer P.icon above T.circularRegion
}

forall Vertex v; Geometry G
where v has math label {
   layer v.labelText above G.icon
}

forall Triangle T; Edge e {
   layer T.circularRegion below e.straightEdge
   layer T.circularRegion below e.circularEdge
}

forall Angle A; Edge e {
   layer e.circularEdge above A.disk
   layer e.circularEdge above A.boundary
}

forall Angle A; Edge e; Triangle t
where A := FirstCircularCorner(t) {
   layer A.boundary above e.straightEdge
}
forall Angle A; Edge e; Triangle t
where A := SecondCircularCorner(t) {
   layer A.boundary above e.straightEdge
}
forall Angle A; Edge e; Triangle t
where A := ThirdCircularCorner(t) {
   layer A.boundary above e.straightEdge
}

forall Angle A; Edge e; Triangle t
where A := FirstStraightCorner(t) {
   layer A.boundary below e.straightEdge
}
forall Angle A; Edge e; Triangle t
where A := SecondStraightCorner(t) {
   layer A.boundary below e.straightEdge
}
forall Angle A; Edge e; Triangle t
where A := ThirdStraightCorner(t) {
   layer A.boundary below e.straightEdge
}

forall Angle A; Edge e
where A := StartBendAngle(e) {
   layer A.boundary below e.straightEdge
}
forall Angle A; Edge e
where A := EndBendAngle(e) {
   layer A.boundary below e.straightEdge
}



--------------------------------------------------------------------------------
-- Labeling --------------------------------------------------------------------
--------------------------------------------------------------------------------

forall MeshElement E
where E has math label {
   shape E.labelText = Equation {
      string: E.label
      fontSize: global.labelSize
      ensureOnCanvas: false
   }
}

forall Geometry G
where G has math label {
   shape G.labelText = Equation {
      string: G.label
      fontSize: global.labelSize
      ensureOnCanvas: false
   }
}

forall Vertex v
where v has math label {
   encourage near( v.labelText, v.icon )
   ensure disjoint( v.labelText, v.icon, global.labelPadding )
}

forall Edge e
where e has math label {
   encourage near( e.labelText, e.straightEdge )
   ensure disjoint( e.labelText, e.straightEdge, global.labelPadding )
}

forall Triangle t
where t has math label {
   encourage near( t.labelText, (t.pi+t.pj+t.pk)/3 )
}

forall Point p
where p has math label {
   encourage near( p.labelText, p.icon )
   ensure disjoint( p.labelText, p.icon, global.labelPadding )
}

forall Segment S
where S has math label {
   encourage near( S.labelText, S.line )
   ensure disjoint( S.labelText, S.line, global.labelPadding )
}

forall Segment S; Circle C
where S has math label; S := RadiusOf(C) {
   override S.labelText.opacity = colors.constructionLineOpacity
}

forall Segment S; Edge e
where S has math label; S := LengthMarker(e) {
   override S.labelText.opacity = colors.constructionLineOpacity
}

forall Angle A
where A has math label {
   encourage norm( A.labelText.center - A.c ) == 0
}

forall Arc A
where A has math label {
   vec2 u0 = unitVector( A.theta0 )
   vec2 u1 = unitVector( A.theta1 )
   vec2 x = A.c + (A.r + global.labelSizeNum)*unit( (u0+u1)/2 )
   encourage norm( A.labelText.center - x ) == 0
}

forall Arc A; Edge e
where A has math label; A := ArcLengthMarker(e) {
   override A.labelText.opacity = colors.constructionLineOpacity
}

forall Vertex v; Edge e
where v has math label {
   ensure disjoint( v.labelText, e.straightEdge, global.labelPadding )
}

