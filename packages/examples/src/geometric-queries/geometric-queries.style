canvas {
   width = 800
   height = 700
}

global {
   color shapeColor = #0003
   color closestColor = #66d
   color silhouetteColor = #0a0
   color rayColor = #ff6600

   scalar strokeWidth = 2
   scalar arrowSize = 40
   scalar arrowWidth = 2.5
   scalar perpSize = 14

   scalar boxWidth = canvas.width/3
   scalar boxHeight = canvas.height/2
}

-- Rules for drawing each type of shape

forall Point p {
   vec2 p.x = (?,?) -- location

   shape p.icon = Circle {
      center: p.x
      r: 5
      strokeWidth: 1
      fillColor: #000000ff
   } 
}

forall Ray r {
   vec2 r.o = (?,?) -- origin
   vec2 r.d = circleRandom() -- direction

   r.icon = Line {
      start: r.o
      end: r.o + global.arrowSize*r.d
      strokeColor: #000
      strokeWidth: global.arrowWidth
      endArrowhead: "straight"
      endArrowheadSize: .5
   }
}

forall Point p; Ray r
where r := rayFrom(p) {
   override r.o = p.x
}

forall Line L {
   shape L.icon = Line {
      start: (?,?)
      end: (?,?)
      strokeWidth: 5
      strokeColor: global.shapeColor
   }
}

forall Rectangle R {
   shape R.icon = Rectangle {
      center: (?, ?)
      width: ?
      height: ?
      strokeWidth: 1
      fillColor: global.shapeColor
   }

   ensure R.icon.width > 50
   ensure R.icon.height > 50
}

forall Polyline P {
   vec2 p0 = (?,?)
   vec2 p1 = (?,?)
   vec2 p2 = (?,?)
   vec2 p3 = (?,?)
   vec2 p4 = (?,?)
   
   shape P.icon = Polyline {
      points: [ p0, p1, p2, p3, p4 ]
      strokeWidth: 5.0
      strokeLinejoin: "round"
      strokeColor: global.shapeColor
   }

   scalar L0 = norm(p1-p0)
   scalar L1 = norm(p2-p1)
   scalar L2 = norm(p3-p2)
   scalar L3 = norm(p4-p3)
   ensure L0 > 30
   ensure L1 > 30
   ensure L2 > 30
   ensure L3 > 30
   ensure L0 < 80
   ensure L1 < 80
   ensure L2 < 80
   ensure L3 < 80

   scalar theta0 = angleBetween(p1-p0,p2-p1)
   scalar theta1 = angleBetween(p2-p1,p3-p2)
   scalar theta2 = angleBetween(p3-p2,p4-p3)
   ensure theta0 > MathPI()/6
   ensure theta1 > MathPI()/6
   ensure theta2 > MathPI()/6
}

forall Polygon P {
   vec2 p0 = (?,?)
   vec2 p1 = (?,?)
   vec2 p2 = (?,?)
   vec2 p3 = (?,?)
   
   shape P.icon = Polygon {
      points: [ p0, p1, p2, p3 ]
      fillColor: global.shapeColor
   }

   vec2 e01 = p1-p0
   vec2 e12 = p2-p1
   vec2 e23 = p3-p2
   vec2 e30 = p0-p3
   scalar theta0 = angleBetween( e01, -e12 )
   scalar theta1 = angleBetween( e12, -e23 )
   scalar theta2 = angleBetween( e23, -e30 )
   scalar theta3 = angleBetween( e30, -e01 )
   ensure theta0 > toRadians(30)
   ensure theta1 > toRadians(30)
   ensure theta2 > toRadians(30)
   ensure theta3 > toRadians(30)

   ensure abs(cross2D( e01, -e12 )) > 50
   ensure theta0 + theta1 + theta2 + theta3 == 2*MathPI()
}

forall Circle C {
   shape C.icon = Circle {
      center: (?,?)
      r: random(30,80)
      fillColor: global.shapeColor
   }

   -- shape C.box = Rectangle {
   --    center: (-canvas.width + global.boxWidth, -canvas.height + global.boxHeight)/2
   --    width: global.boxWidth
   --    height: global.boxHeight
   --    fillColor: rgba(0,0,0,.1)
   --    strokeColor: #fff
   --    strokeWidth: 4
   --    ensureOnCanvas: false
   -- }
   -- ensure contains( C.box, C.icon )
}

forall Ellipse E {
   shape E.icon = Ellipse {
      center: (?,?)
      rx: random(50,150)
      ry: random(50,150)
      fillColor: global.shapeColor
   }
}

forall Group G {

   vec2 p0 = (?,?)
   vec2 p1 = (?,?)
   vec2 p2 = (?,?)

   shape s1 = Circle {
      r: random(30,70)
   }
   shape s2 = Rectangle {
      width: random(50,150)
      height: random(50,150)
   }
   shape s3 = Polygon {
      points: [p0,p1,p2]
   }

   vec2 u = p1-p0
   vec2 v = p2-p1
   vec2 w = p0-p2
   ensure angleBetween(-u,v) > MathPI()/6
   ensure angleBetween(-v,w) > MathPI()/6
   ensure angleBetween(-w,u) > MathPI()/6

   shape G.icon = Group {
      shapes: [s1,s2,s3]
   }

   shape bbox = Rectangle {
      fillColor: none()
      strokeColor: #ddd
      strokeDasharray: "10 8"
      strokeWidth: 2.0
      center: (0,0)
      width: random(300,500)
      height: random(300,500)
   }
   ensure contains( bbox, s1 )
   ensure contains( bbox, s2 )
   ensure contains( bbox, s3 )
   ensure contains( G.icon, bbox )

}

-- Rules for geometric queries

forall Point q; Shape S; Point p
where q := closestPoint(S,p)
{
   vec2 y = closestPoint( S.icon, p.x )

   override q.x = y
   override q.icon.fillColor = #fff
   override q.icon.strokeColor = global.closestColor
   override q.icon.strokeWidth = global.strokeWidth
   override q.icon.ensureOnCanvas = false

   shape querySegment = Line {
      start: p.x
      end: y
      strokeColor: global.closestColor
      strokeWidth: global.strokeWidth
      ensureOnCanvas: false
   }

   layer q.icon above S.icon
}

forall Point q; Shape S; Point p
where q := closestSilhouettePoint(S,p)
{
   vec2 y = closestSilhouettePoint( S.icon, p.x )

   override q.x = y
   override q.icon.fillColor = #fff
   override q.icon.strokeColor = global.silhouetteColor
   override q.icon.strokeWidth = global.strokeWidth
   override q.icon.ensureOnCanvas = false

   shape querySegment = Line {
      start: p.x
      end: y
      strokeColor: global.silhouetteColor
      strokeWidth: global.strokeWidth
      ensureOnCanvas: false
   }

   layer q.icon above S.icon
}

forall Point q; Shape S; Ray r
where q := rayIntersect(S,r)
{
   vec2 y = rayIntersect( S.icon, r.o, r.d )
   vec2 q.n = rayIntersectNormal( S.icon, r.o, r.d )

   override q.x = y
   override q.icon.fillColor = #fff
   override q.icon.strokeColor = global.rayColor
   override q.icon.strokeWidth = global.strokeWidth
   override q.icon.ensureOnCanvas = false

   shape raySegment = Line {
      start: r.o
      end: y
      strokeColor: global.rayColor
      strokeWidth: global.strokeWidth
      style: "dashed"
      strokeDasharray: "8,6"
      ensureOnCanvas: false
   }

   shape normalArrow = Line {
      start: y
      end: y + global.arrowSize*q.n
      strokeColor: global.rayColor
      strokeWidth: global.arrowWidth
      endArrowhead: "straight"
      endArrowheadSize: .5 * norm(q.n)
      ensureOnCanvas: false
   }

   vec2 u = global.perpSize*q.n
   vec2 v = global.perpSize*rot90(q.n)
   vec2 r.h = (0,0)
   shape perpMark = Polyline {
      points: [ y+u+r.h, y+u+v+r.h, y+v+r.h ]
      ensureOnCanvas: false
      fillColor: none()
      strokeColor: global.rayColor
      strokeWidth: global.strokeWidth
   }

   layer S.icon above perpMark
   layer normalArrow above perpMark
   layer q.icon above normalArrow
   layer q.icon above S.icon
}

forall Point q; Conic C; Ray r
where q := rayIntersect(C,r) {
   override r.h = -.15*global.perpSize*q.n
}

