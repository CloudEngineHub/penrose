canvas {
   width = 800
   height = 700
}

-- Rules for drawing each type of shape

forall Ray r {
   vec2 r.pos = (-canvas.width/2 + 10,?)
   vec2 r.vec = (1000,?)

   shape r.icon = Circle {
      center: r.pos
      r: 5
      fillColor: #000000ff
   } 
   shape r.arrow = Line {
      start: r.pos
      end: r.pos + 75*unit(r.vec)
      strokeWidth: 3
      strokeColor: #000
      endArrowhead: "straight"
      endArrowheadSize: .5
   } 
   shape r.line = Line {
      start: r.pos
      end: r.pos + norm((canvas.width,canvas.height))*unit(r.vec)
      strokeColor: #000
      strokeWidth: 1.5
      style: "dashed"
      strokeDasharray: "8,6"
      ensureOnCanvas: false
   }

   layer r.arrow above r.line
   layer r.icon above r.arrow
}

forall Line L {
   shape L.icon = Line {
      start: (?,?)
      end: (?,?)
      strokeWidth: 5
   }
}

forall Rectangle R {
   shape R.icon = Rectangle {
      center: (?, ?)
      width: ?
      height: ?
      strokeWidth: 1
   }

   ensure R.icon.width > 50
   ensure R.icon.height > 50
}

forall Polyline P {
   scalar w = canvas.width/2
   scalar h = .9*canvas.height/2
   vec2 p0 = (w - random(0,100),h)
   vec2 p1 = (w - random(0,100),h/2)
   vec2 p2 = (w - random(0,100),0)
   vec2 p3 = (w - random(0,100),-h/2)
   vec2 p4 = (w - random(0,100),-h)
   
   shape P.icon = Polyline {
      points: [ p0, p1, p2, p3, p4 ]
      strokeWidth: 5.0
      strokeLinejoin: "round"
      strokeColor: sampleColor(1.0,"rgb")
      ensureOnCanvas: false
   }
}

forall Polygon P {

   vec2 c = (?,?)
   scalar t0 = 0.00 + random(-1,1)
   scalar t1 = 2.09 + random(-1,1)
   scalar t2 = 4.18 + random(-1,1)
   scalar r0 = 60 + random(-5,5)
   scalar r1 = 60 + random(-5,5)
   scalar r2 = 60 + random(-5,5)

   vec2 p0 = c + r0*(cos(t0),sin(t0))
   vec2 p1 = c + r1*(cos(t1),sin(t1))
   vec2 p2 = c + r2*(cos(t2),sin(t2))
   
   shape P.icon = Polygon {
      points: [ p0, p1, p2 ]
   }
}

forall Circle C {
   shape C.icon = Circle {
      center: (?,?)
      r: random(40,80)
   }
}

forall Ellipse E {
   shape E.icon = Ellipse {
      rx: random(5,80)
      ry: random(5,80)
   }
}

forall Group G {
   shape c1 = Circle {
      center: (?,?)
      r: random(20,40)
      fillColor: sampleColor(1,"rgb")
   }

   shape c2 = Circle {
      center: c1.center + 40*diskRandom()
      r: random(20,40)
      fillColor: c1.fillColor
   }

   shape c3 = Circle {
      center: c1.center + 40*diskRandom()
      r: random(20,40)
      fillColor: c1.fillColor
   }

   shape c4 = Circle {
      center: c1.center + 40*diskRandom()
      r: random(20,40)
      fillColor: c1.fillColor
   }

   shape G.icon = Group {
      shapes: [c1,c2,c3,c4]
   }
}

-- Rules for drawing ray intersections

forall Ray r; Shape S
{
   vec2 p = rayIntersect( S.icon, r.pos, r.vec )
   vec2 n = rayIntersectNormal( S.icon, r.pos, r.vec )

   shape intersectDot = Circle {
      r: r.icon.r * norm(n)
      center: p
      fillColor: #ffffffff
      strokeColor: #000
      strokeWidth: 2
      ensureOnCanvas: false
   }

   shape intersectNormal = Line {
      start: p
      end: p + 30*n
      strokeColor: #888
      strokeWidth: 2
      endArrowhead: "straight"
      endArrowheadSize: .5 * norm(n)
      ensureOnCanvas: false
   }

   layer intersectDot above r.arrow
   layer intersectDot below r.icon
   layer intersectDot above S.icon
   layer intersectNormal below intersectDot
}

forall Ray r; Polyline M
{
   vec2 p = rayIntersect( M.icon, r.pos, r.vec )
   vec2 n = rayIntersectNormal( M.icon, r.pos, r.vec )

   shape intersectDot = Circle {
      r: r.icon.r
      center: p
      fillColor: #ffffffff
      strokeColor: #000000ff
      strokeWidth: 2
      ensureOnCanvas: false
   }

   shape intersectNormal = Line {
      start: p
      end: p + 30*n
      strokeColor: #888
      strokeWidth: 2
      endArrowhead: "straight"
      endArrowheadSize: .5
      ensureOnCanvas: false
   }

   layer intersectDot above r.arrow
   layer intersectDot below r.icon
   layer intersectDot above M.icon
   layer intersectNormal below intersectDot
}

forall Shape S; Ray r
{
   layer r.icon above S.icon
}

-- Keep shapes from overlapping
forall Shape S1; Shape S2
{
   ensure disjoint( S1.icon, S2.icon )
}

