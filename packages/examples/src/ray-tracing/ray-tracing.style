layout = [ tracingStage, labelingStage ]

canvas {
   width = 240
   height = 200
}

global {
   scalar pointSize = 2 -- 1

   scalar arrowScale = 15.0 -- 0
   scalar arrowThickness = 1.0
   string arrowShape = "straight"
   string arrowSize = .5 -- 0

   string rayLineDashing = "4,3" -- ""
   color rayLineColor = #000 -- #ff660044
   scalar rayLineWidth = 0.65 -- 1

   scalar eps = 0.1 -- offset distance (to prevent ray from intersecting origin)
}

colors {
   color white = #ffffff
}

forall Scene S {

   -- shape S.geometry = Rectangle {
   --    center: (0,0)
   --    width: canvas.width - 30
   --    height: canvas.height - 30
   --    fillColor: #ddd
   --    strokeColor: #aaa
   --    strokeWidth: 1
   --    ensureOnCanvas: false
   -- }

   -- shape S.g1 = Ellipse {
   --    center: (0,0)
   --    rx: canvas.width/2.
   --    ry: canvas.height/2.
   --    fillColor: #ddd
   --    strokeColor: #aaa
   --    strokeWidth: 1
   --    ensureOnCanvas: false
   -- }
   -- shape S.g2 = Circle {
   --    center: (canvas.width/4,0)
   --    r: canvas.width/8.
   --    fillColor: #fff
   --    strokeColor: #aaa
   --    strokeWidth: 1
   --    ensureOnCanvas: false
   -- }
   -- shape S.g3 = Circle {
   --    center: (-canvas.width/4,0)
   --    r: canvas.width/8.
   --    fillColor: #fff
   --    strokeColor: #aaa
   --    strokeWidth: 1
   --    ensureOnCanvas: false
   -- }
   -- shape S.geometry = Group {
   --    shapes: [S.g1,S.g2]
   -- }

   -- scalar maxPerturbation = 15
   -- vec2 p0 = maxPerturbation*diskRandom()
   -- vec2 p1 = maxPerturbation*diskRandom()
   -- vec2 p2 = maxPerturbation*diskRandom()
   -- vec2 p3 = maxPerturbation*diskRandom()
   -- vec2 p4 = maxPerturbation*diskRandom()
   -- vec2 p5 = maxPerturbation*diskRandom()
   -- scalar w = .8*canvas.width/2
   -- scalar h = .8*canvas.height/2
   shape S.geometry = Polygon {
      points: [(-97,75.3), (-110.5,28.8), (-89.2,-93.1), (104.7,-84.1), (104.7,75.3), (43.8,95.7), (2.9,18.6), (28.5,-18.4), (-4.9,-44.8), (-41.2,6.9), (4.4,42.3), (-36.1,90.9)]
      --points: ( (w,-h)+p0, (0,-h)+p1, (-w,-h)+p2, (-w,h)+p3, (0,h)+p4, (w,h)+p5)
      fillColor: #ddd
      strokeColor: #aaa
      strokeWidth: 1
      ensureOnCanvas: false
   }
}

forall Point p; Scene S {
   vec2 p.x = (?,?) -- location
   vec2 p.n = (0,0) -- normal

   shape p.icon = Circle {
      center: p.x
      r: global.pointSize
      fillColor: #000
      ensureOnCanvas: false
   }

   layer p.icon above S.geometry
}

forall Point p
where p has math label {
   shape p.labelText = Equation {
      string: p.label
      ensureOnCanvas: false
      fontSize: "9px"
      fillColor: #000
      strokeColor: "#ffffff"
      strokeWidth: 2.5
      paintOrder: "stroke"
      strokeLinejoin: "round"
   }

   encourage norm( p.labelText.center - p.x ) == 10 in labelingStage

   layer p.labelText above p.icon
}

forall Ray r {
   vec2 r.o = (?,?) -- origin
   vec2 r.d = circleRandom() -- direction

   shape r.icon = Line {
      start: r.o
      end: r.o + global.arrowScale*r.d
      strokeColor: #000
      strokeWidth: global.arrowThickness
      endArrowhead: global.arrowShape
      endArrowheadSize: global.arrowSize
      ensureOnCanvas: false
   }
}

forall Light L {
   vec2 L.x = (?,?) -- location

   shape L.icon = Image {
      center: L.x
      width: 27
      height: 41
      href: "lightbulb.svg"
      ensureOnCanvas: false
   }
}

forall Light L; Scene S {
   layer L.icon above S.geometry
}

forall Camera C {

   vec2 C.x = (?,?) -- center location

   shape body = Rectangle {
      center: C.x
      width: 1.5*16
      height: 1.5*11
      fillColor: #aaa
      strokeColor: #666
      strokeWidth: 1
      cornerRadius: 2
      ensureOnCanvas: false
   }
   shape viewfinder = Rectangle {
      center: C.x + (0,body.height/2)
      width: .4*body.width
      height: .3*body.height
      fillColor: body.strokeColor
      cornerRadius: 2
      ensureOnCanvas: false
   }
   shape outerLens = Circle {
      center: C.x
      r: .38*body.height
      fillColor: #ccc
      strokeColor: body.strokeColor
      strokeWidth: body.strokeWidth
      ensureOnCanvas: false
   }
   shape C.innerLens = Circle {
      center: C.x
      r: .25*body.height
      fillColor: #227788
      strokeColor: body.strokeColor
      strokeWidth: body.strokeWidth
      ensureOnCanvas: false
   }
   shape flash = Circle {
      center: C.x + (body.width,body.height)/2 - (3,3)
      r: .07*body.height
      fillColor: #fff
      strokeColor: body.strokeColor
      strokeWidth: .8*body.strokeWidth
      ensureOnCanvas: false
   }
   shape shutterRelease = Rectangle {
      center: C.x + (-body.width/3,body.height/2)
      width: .1*body.width
      height: .15*body.height
      fillColor: body.strokeColor
      ensureOnCanvas: false
   }

   layer viewfinder below body
   layer shutterRelease below body

   shape C.icon = Group {
      shapes: [viewfinder,body,outerLens,C.innerLens,flash,shutterRelease]
      ensureOnCanvas: false
   }
}

forall Scene S; Camera C {
   layer C.icon above S.geometry
   ensure signedDistance( S.geometry, C.x ) < -20
}

forall Scene S; Light L {
   layer L.icon above S.geometry
   ensure signedDistance( S.geometry, L.x ) < -20
}

forall Camera C; Light L {
   ensure disjoint( C.icon, L.icon, 20 )
}

forall Ray r; Point p
where r := rayFrom(p) {
   override r.o = p.x
}

forall Ray r0; Ray r1; Point p; Scene S
where p := intersect(r0,S); r1 := rayFrom(p) {
   scalar theta = random(-1.5707963268,1.5707963268)
   override r1.d = rotateBy( p.n, theta )
}

forall Point p; Ray r; Scene S
where p := intersect(r,S) {
   vec2 o = r.o + global.eps*r.d
   override p.x = rayIntersect(S.geometry, o, r.d)
   override p.n = rayIntersectNormal(S.geometry, o, r.d)

   shape r.rayLine = Line {
      start: r.o
      end: p.x
      strokeColor: global.rayLineColor
      strokeWidth: global.rayLineWidth
      style: "dashed"
      strokeDasharray: global.rayLineDashing
      ensureOnCanvas: false
   }

   shape normalArrow = Line {
      start: p.x
      end: p.x + global.arrowScale*p.n
      strokeColor: #5a5
      strokeWidth: global.arrowThickness
      endArrowhead: global.arrowShape
      endArrowheadSize: global.arrowSize
      ensureOnCanvas: false
   }

   layer r.rayLine above S.geometry
   layer normalArrow above S.geometry
   layer p.icon above normalArrow
}

forall Ray r; Point p; Point q; Scene S
where r := rayBetween(p,q) {
   override r.o = p.x
   override r.d = unit(q.x-p.x)
   shape r.rayLine = Line {
      start: p.x
      end: q.x
      strokeColor: global.rayLineColor
      strokeWidth: global.rayLineWidth
      ensureOnCanvas: false
   }

   -- don't draw an outgoing ray direction for a direct connection
   override r.icon.end = r.icon.start
   override r.icon.endArrowhead = "none"

   -- check if there are any intersections along this ray,
   -- and draw a red "X" at the first intersection if so
   vec2 v = unit(q.x-p.x)
   vec2 y = rayIntersect(S.geometry, p.x + global.eps*v, v)
   scalar dy = norm(y-p.x)
   scalar dq = norm(q.x-p.x)
   scalar alpha = min( max(100*(dq-dy),0), 1 ) -- TODO should just expose ifCond in Style
   shape notVisible = Text {
      string: "Ã—"
      center: y
      fillColor: rgba(1,0,0,alpha)
      fontSize: "18px"
      strokeColor: rgba(1,1,1,alpha)
      strokeWidth: 2
      paintOrder: "stroke"
      ensureOnCanvas: false
   }
}

forall Point p; Ray r
where p has math label {
   --ensure disjoint( p.labelText, r.icon )
}

forall Point p; Point q
where p has math label; q has math label {
   --ensure disjoint( p.labelText, q.labelText )
}

forall Point p; Camera C
where p has math label {
   layer p.labelText above C.icon
}

forall Point p; Camera C
where onCamera(p,C) {
   override p.x = C.x
   layer p.icon below C.icon
}

forall Point p; Camera C
where onCamera(p,C); p has label {
   override p.labelText.center = (?,?)
   encourage norm( p.labelText.center - C.x ) == 0 in labelingStage
   ensure disjoint( p.labelText, C.icon )
}

forall Point p; Light L
where onLight(p,L) {
   override p.x = L.x
   override p.n = (0,0)
   layer p.icon below L.icon
}

forall Point p; Light L
where onLight(p,L); p has label {
   override p.labelText.center = (?,?)
   encourage norm( p.labelText.center - L.x ) == 0 in labelingStage
   ensure disjoint( p.labelText, L.icon )
}

forall Ray r; Camera C {
   layer r.icon below C.icon
   layer r.rayLine below C.icon
}

forall Ray r; Light L {
   layer r.icon below L.icon
   layer r.rayLine below L.icon
}

forall Scene S; Point p; Ray r
where p := intersect(r,S); p has label {
   override p.labelText.center = p.x - 8*p.n
}

