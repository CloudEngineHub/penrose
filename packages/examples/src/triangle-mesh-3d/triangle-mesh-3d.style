canvas {
   width = 200
   height = 200
}

global {

   -- style of small dots
   scalar dotSize = 1.0
   color dotColor = rgba(0,0,0,1)
   string dotFontSize = "4.5px"

   -- Ground plane coordinates in 3D
   scalar planeSize = 50 -- plane size
   scalar planeHeight = -40 -- plane height

   -- Use a simple pinhole camera model, where the
   -- only camera parameter is the distance along Z
   scalar cZ = -160 -- camera z coordinate
   scalar cameraθ = ? -- camera y rotation

   -- Corner coordinates of the global ground plane
   vec3 q00 = ( -planeSize, planeHeight, -planeSize )
   vec3 q10 = (  planeSize, planeHeight, -planeSize )
   vec3 q01 = ( -planeSize, planeHeight,  planeSize )
   vec3 q11 = (  planeSize, planeHeight,  planeSize )

   -- Apply a random rotation to the ground plane
   -- (Note that we could also apply this rotation to the triangle
   -- vertices, but since they're sampled randomly, it wouldn't
   -- really change the appearance of the kinds of diagrams we sample).
   scalar θ = cameraθ -- for brevity
   vec3 Q00 = ( q00[0]*cos(θ) + q00[2]*sin(θ), q00[1], q00[2]*cos(θ) - q00[0]*sin(θ) )
   vec3 Q10 = ( q10[0]*cos(θ) + q10[2]*sin(θ), q10[1], q10[2]*cos(θ) - q10[0]*sin(θ) )
   vec3 Q01 = ( q01[0]*cos(θ) + q01[2]*sin(θ), q01[1], q01[2]*cos(θ) - q01[0]*sin(θ) )
   vec3 Q11 = ( q11[0]*cos(θ) + q11[2]*sin(θ), q11[1], q11[2]*cos(θ) - q11[0]*sin(θ) )

   -- Perform perspective projection on 3D coordinates to get 2D coordinates p
   vec2 p00 = canvas.width * (Q00[0],Q00[1])/(Q00[2] - global.cZ)
   vec2 p10 = canvas.width * (Q10[0],Q10[1])/(Q10[2] - global.cZ)
   vec2 p01 = canvas.width * (Q01[0],Q01[1])/(Q01[2] - global.cZ)
   vec2 p11 = canvas.width * (Q11[0],Q11[1])/(Q11[2] - global.cZ)

   -- Draw polygon using projected 2D coordinates p
   shape groundPlane = Polygon {
      points: (p00,p10,p11,p01)
      width: canvas.width
      height: canvas.height
      fillColor: rgba(0,0,0,0.1)
      strokeColor: rgba(.7,.7,.7,1)
      strokeWidth: .5
      ensureOnCanvas: false
   }
}

forall Vertex v
{
   -- Sample 3D location from a bounding box of size c
   scalar c = .9*min( global.planeSize, abs(global.planeHeight) )

   vec3 q = (?,?,?)
   ensure -c < q[0]
   ensure q[0] < c
   ensure -c < q[1]
   ensure q[1] < c
   ensure -c < q[2]
   ensure q[2] < c

   -- perform modelview transformation
   scalar θ = global.cameraθ
   vec3 Q = ( q[0], q[1], q[2] - global.cZ )
   --vec3 Q = ( q[0]*cos(θ) + q[2]*sin(θ), q[1], q[2]*cos(θ) - q[0]*sin(θ) - global.cZ )

   -- Perform perspective projection to get 2D coordinates
   vec2 v.p = canvas.width * (Q[0],Q[1])/(Q[2])

   -- Compute projected shadow coordinates
   vec3 R = (Q[0],global.planeHeight,Q[2])
   vec2 v.s = canvas.width * (R[0],R[1])/(R[2])

   -- draw vertex as black dot
   shape v.icon = Circle {
      center: v.p
      r: global.dotSize
      fillColor: global.dotColor
      ensureOnCanvas: false
   }

   -- draw shadow as semi-transparent black dot
   shape v.shadow = Circle {
      center: v.s
      r: global.dotSize
      fillColor: rgba(0,0,0,.1)
      ensureOnCanvas: false
   }
}


forall Vertex v
where v has label
{
   shape v.labelText = Equation {
       string: v.label
       center: v.p
       fontSize: global.dotFontSize
       ensureOnCanvas: false
   }
}

forall Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k)
{
   -- Draw polygon using projected 2D coordinates p
   shape t.icon = Polygon {
      points: (i.p,j.p,k.p)
      fillColor: #1b1f8a55
      strokeColor: #1b1f8a
      strokeWidth: .5
      ensureOnCanvas: false
   }

   -- Make sure the triangle is positively oriented in the
   -- image plane, and has some- "fat" angles so that it
   -- doesn't degenerate
   vec2 eij = j.p - i.p
   vec2 ejk = k.p - j.p
   vec2 eki = i.p - k.p
   ensure cross2D( eij, -ejk ) < 0
   ensure angleFrom( -ejk, eij ) > toRadians( 45 )
   ensure angleFrom( -eki, ejk ) > toRadians( 45 )
   ensure angleFrom( -eij, eki ) > toRadians( 45 )

   -- Draw shadow polygon using projected 2D coordinates s
   shape t.shadow = Polygon {
      points: (i.s,j.s,k.s)
      fillColor: rgba(0,0,0,0.1)
      strokeColor: none()
      ensureOnCanvas: false
   }

   -- offset labels from vertices
   scalar offset = 6
   i.labelText.center = i.p - offset*unit( eij - eki )
   j.labelText.center = j.p - offset*unit( ejk - eij )
   k.labelText.center = k.p - offset*unit( eki - ejk )
}

-- For any pair of triangles, make sure that triangles
-- don't overlap, and moreover the vertices of one triangle are
-- far from being contained in the other triangle (which helps
-- to avoid overlapping labels).
forall Triangle s; Triangle t; Vertex si; Vertex sj; Vertex sk; Vertex ti; Vertex tj; Vertex tk
where s := MakeTriangle(si,sj,sk); t := MakeTriangle(ti,tj,tk)
{
   scalar padding = 10.0

   -- make sure triangles don't overlap
   ensure disjoint( s.icon, t.icon )

   -- make sure vertices of s are far from t
   ensure disjoint( si.icon, t.icon, padding )
   ensure disjoint( sj.icon, t.icon, padding )
   ensure disjoint( sk.icon, t.icon, padding )

   -- make sure vertices of t are far from s
   ensure disjoint( ti.icon, s.icon, padding )
   ensure disjoint( tj.icon, s.icon, padding )
   ensure disjoint( tk.icon, s.icon, padding )

}


