canvas {
   width = 170
   height = 120
}

colors {
   black = #000000
}

global {

   string labelFontSize = "4.5px"

   shape box = Rectangle {
     center: (0,0)
     width: canvas.width
     height: canvas.height
     fillColor: none()
     strokeColor: #33887733
     strokeWidth: 2.0
   }

   shape codomainLabel = Equation {
      center: .5*(canvas.width,canvas.height) - (20,20)
      string: "\mathbb{R}^3"
      fontSize: labelFontSize
      fontColor: colors.black
   }

   -- style of small dots
   scalar dotSize = 1.0
   color dotColor = rgba(0,0,0,1)

   -- standard triangle colors
   rgba triFill = #1b1f8a55
   rgba triStroke = #1b1f8a
   scalar triStrokeWidth = 0.5

   -- Ground plane coordinates in 3D
   scalar planeSize = 50 -- plane size
   scalar planeHeight = -35 -- plane height

   -- Use a simple pinhole camera model, where the
   -- only camera parameter is the distance along Z
   scalar cZ = -160 -- camera z coordinate
   scalar cameraθ = ? -- camera y rotation
   scalar viewXY = (0,canvas.width/6) -- viewport offset

   -- Corner coordinates of the global ground plane
   vec3 q00 = ( -planeSize, planeHeight, -planeSize )
   vec3 q10 = (  planeSize, planeHeight, -planeSize )
   vec3 q01 = ( -planeSize, planeHeight,  planeSize )
   vec3 q11 = (  planeSize, planeHeight,  planeSize )

   -- Apply a random rotation to the ground plane
   -- (Note that we could also apply this rotation to the triangle
   -- vertices, but since they're sampled randomly, it wouldn't
   -- really change the appearance of the kinds of diagrams we sample).
   scalar θ = cameraθ -- for brevity
   vec3 Q00 = ( q00[0]*cos(θ) + q00[2]*sin(θ), q00[1], q00[2]*cos(θ) - q00[0]*sin(θ) )
   vec3 Q10 = ( q10[0]*cos(θ) + q10[2]*sin(θ), q10[1], q10[2]*cos(θ) - q10[0]*sin(θ) )
   vec3 Q01 = ( q01[0]*cos(θ) + q01[2]*sin(θ), q01[1], q01[2]*cos(θ) - q01[0]*sin(θ) )
   vec3 Q11 = ( q11[0]*cos(θ) + q11[2]*sin(θ), q11[1], q11[2]*cos(θ) - q11[0]*sin(θ) )

   -- Perform perspective projection on 3D coordinates to get 2D coordinates p
   vec2 p00 = canvas.width * (Q00[0],Q00[1])/(Q00[2] - global.cZ) + global.viewXY
   vec2 p10 = canvas.width * (Q10[0],Q10[1])/(Q10[2] - global.cZ) + global.viewXY
   vec2 p01 = canvas.width * (Q01[0],Q01[1])/(Q01[2] - global.cZ) + global.viewXY
   vec2 p11 = canvas.width * (Q11[0],Q11[1])/(Q11[2] - global.cZ) + global.viewXY

   -- Draw polygon using projected 2D coordinates p
   shape groundPlane = Polygon {
      points: (p00,p10,p11,p01)
      width: canvas.width
      height: canvas.height
      fillColor: rgba(0,0,0,0.1)
      strokeColor: rgba(.7,.7,.7,1)
      strokeWidth: .5
      ensureOnCanvas: false
   }
}

forall Vertex v
{
   -- Sample 3D location from a bounding box of size c
   scalar c = .9*min( global.planeSize, abs(global.planeHeight) )
   vec3 q = (?,?,?)
   ensure -c < q[0]
   ensure q[0] < c
   ensure -c < q[1]
   ensure q[1] < c
   ensure -c < q[2]
   ensure q[2] < c

   -- perform modelview transformation
   scalar θ = global.cameraθ
   vec3 Q = ( q[0], q[1], q[2] - global.cZ )
   --vec3 Q = ( q[0]*cos(θ) + q[2]*sin(θ), q[1], q[2]*cos(θ) - q[0]*sin(θ) - global.cZ )

   -- Perform perspective projection to get 2D coordinates
   vec2 v.p = canvas.width * (Q[0],Q[1])/(Q[2]) + global.viewXY

   -- Compute projected shadow coordinates
   vec3 R = (Q[0],global.planeHeight,Q[2])
   vec2 v.s = canvas.width * (R[0],R[1])/(R[2]) + global.viewXY

   -- draw vertex as black dot
   shape v.icon = Circle {
      center: v.p
      r: global.dotSize
      fillColor: global.dotColor
   }

   -- draw shadow as semi-transparent black dot
   shape v.shadow = Circle {
      center: v.s
      r: global.dotSize
      fillColor: rgba(0,0,0,.1)
      ensureOnCanvas: false
   }
}

forall Vertex v
where v has math label
{
   shape v.labelText = Equation {
       string: v.label
       center: v.p
       fontSize: global.labelFontSize
   }
}

-- avoid overlapping vertex labels
forall Vertex i; Vertex j
where i has math label; j has math label
{
   ensure disjoint( i.labelText, j.labelText )
}

forall Triangle t; Vertex i; Vertex j; Vertex k
where t := MakeTriangle(i,j,k)
{
   -- make local aliases to vertex coordinates, for
   -- use by future rules that reference t but not
   -- its vertices
   t.p0 = i.p
   t.p1 = j.p
   t.p2 = k.p

   -- Draw polygon using projected 2D coordinates p
   shape t.icon = Polygon {
      points: (i.p,j.p,k.p)
      fillColor: global.triFill
      strokeColor: global.triStroke
      strokeWidth: global.triStrokeWidth
   }

   -- Make sure the triangle is positively oriented in the
   -- image plane, and has some- "fat" angles so that it
   -- doesn't degenerate
   vec2 eij = j.p - i.p
   vec2 ejk = k.p - j.p
   vec2 eki = i.p - k.p
   constraint t.orientation = ensure cross2D( eij, -ejk ) < 0
   constraint t.angleSizeI = ensure angleFrom( -eij, eki ) > toRadians( 45 )
   constraint t.angleSizeJ = ensure angleFrom( -ejk, eij ) > toRadians( 45 )
   constraint t.angleSizeK = ensure angleFrom( -eki, ejk ) > toRadians( 45 )

   -- Draw shadow polygon using projected 2D coordinates s
   shape t.shadow = Polygon {
      points: (i.s,j.s,k.s)
      fillColor: rgba(0,0,0,0.1)
      strokeColor: none()
      ensureOnCanvas: false
   }

   -- offset labels from vertices
   scalar offset = 6
   i.labelText.center = i.p - offset*unit( eij - eki )
   j.labelText.center = j.p - offset*unit( ejk - eij )
   k.labelText.center = k.p - offset*unit( eki - ejk )
}

-- For any pair of triangles, make sure that triangles
-- don't overlap, and moreover the vertices of one triangle are
-- far from being contained in the other triangle (which helps
-- to avoid overlapping labels).
forall Triangle s; Triangle t; Vertex si; Vertex sj; Vertex sk; Vertex ti; Vertex tj; Vertex tk
where s := MakeTriangle(si,sj,sk); t := MakeTriangle(ti,tj,tk)
{
   scalar padding = 10.0

   -- make sure triangles don't overlap
   ensure disjoint( s.icon, t.icon )

   -- make sure vertices of s are far from t
   ensure disjoint( si.icon, t.icon, padding )
   ensure disjoint( sj.icon, t.icon, padding )
   ensure disjoint( sk.icon, t.icon, padding )

   -- make sure vertices of t are far from s
   ensure disjoint( ti.icon, s.icon, padding )
   ensure disjoint( tj.icon, s.icon, padding )
   ensure disjoint( tk.icon, s.icon, padding )

}

forall StandardTriangle t
{
   -- size s
   scalar s = canvas.width/4

   -- coordinate system origin o and axes e1,e2
   vec2 o = -.9*(canvas.width,canvas.height)/2 + (0,5)
   vec2 e1 = (s,0)
   vec2 e2 = (0,s)

   -- vertices p0, p1, p2
   vec2 t.p0 = o
   vec2 t.p1 = o + e1
   vec2 t.p2 = o + e2

   -- standard triangle
   shape t.icon = Polygon {
      fillColor: global.triFill
      strokeColor: global.triStroke
      strokeWidth: global.triStrokeWidth
      points: ( t.p0, t.p1, t.p2 )
   }

   -- standard axes
   shape xAxis = Line {
      start: o
      end: o + 1.15*e1
      strokeColor: colors.black
      strokeWidth: 0.65
      endArrowhead: "straight"
      endArrowheadSize: 0.65
   }
   shape yAxis = Line {
      start: o
      end: o + 1.15*e2
      strokeColor: colors.black
      strokeWidth: 0.65
      endArrowhead: "straight"
      endArrowheadSize: 0.65
   }
   shape xAxisLabel = Equation {
      center:  o + 1.225*e1
      string: "s"
      fontSize: global.labelFontSize
      fontColor: colors.black
      ensureOnCanvas: false
   }
   shape yAxisLabel = Equation {
      center:  o + 1.25*e2
      string: "t"
      fontSize: global.labelFontSize
      fontColor: colors.black
      ensureOnCanvas: false
   }

   -- unit ticks
   scalar tickSize = 2.5
   shape xAxisTick = Line {
      start: o + e1 - (0,tickSize)
      end:   o + e1 + (0,tickSize)
      strokeColor: t.icon.strokeColor
      strokeWidth: .75 * xAxis.strokeWidth
      ensureOnCanvas: false
   }
   shape yAxisTick = Line {
      start: o + e2 - (tickSize,0)
      end:   o + e2 + (tickSize,0)
      strokeColor: t.icon.strokeColor
      strokeWidth: .75 * yAxis.strokeWidth
      ensureOnCanvas: false
   }
   shape xTickLabel = Equation {
      center: xAxisTick.start - (0,5)
      string: "1"
      fontColor: colors.black
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
   shape yTickLabel = Equation {
      center: yAxisTick.start - (2.5,0)
      string: "1"
      fontColor: colors.black
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
}

forall Map f; StandardTriangle t0; Triangle t
where f := TriangleEmbedding(t0,t) {

   vec2 m01 = (t.p0 + t.p1)/2
   vec2 m12 = (t.p1 + t.p2)/2
   vec2 m20 = (t.p2 + t.p0)/2

   scalar w = 1/16
   scalar s = .5-w/2 + w*(match_id - 1)/(match_total - 1)

   vec2 a = (1-s)*t0.p1 + s*t0.p2
   vec2 b = closestTo( a, [m01,m12,m20] )

   vec2 u = unit((1,1))
   vec2 a1 = a + 5*u

   vec2 v = (b-t.p0) + (b-t.p1) + (b-t.p2)
   vec2 b1 = b + 5*unit(v)

   vec2 f.n = rot90(b1-a1)/norm(b1-a1)
   vec2 f.c = (a1+b1)/2 + 5*f.n

   shape f.arrow = Path {
      d: interpolateQuadraticFromPoints( "open", a1, f.c, b1 )
      strokeColor: colors.black
      endArrowhead: "straight"
      endArrowheadSize: 0.5
      strokeWidth: 1
   }
}

-- arrows shouldn't overlap triangles
forall Map f; Map g; StandardTriangle t0; Triangle t
where f := TriangleEmbedding(t0,t) {
   ensure disjoint( g.arrow, t.icon )
}

-- draw labels for maps that have them
forall Map f; StandardTriangle t0; Triangle t
where f has math label {
   shape f.labelText = Equation {
      string: f.label
      center: f.c + 5*f.n
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
}

-- avoid overlapping map labels
forall Map f; Map g
where f has math label; g has math label {
   ensure disjoint( f.labelText, g.labelText )
}

-- avoid overlapping map and vertex labels
forall Map f; Vertex v
where f has math label; v has math label {
   ensure disjoint( f.labelText, v.labelText )
}

