canvas {
   width = 170
   height = 120
}

colors {
   black = #000000
   white = #ffffff
   shadow = rgba(0,0,0,.1)
}

global {

   string labelFontSize = "4.5px"

   shape box = Rectangle {
     center: (0,0)
     width: canvas.width
     height: canvas.height
     fillColor: #66666633
     strokeColor: none()
   }

   shape codomainLabel = Equation {
      center: .5*(canvas.width,canvas.height) - (10,10)
      string: "\mathbb{R}^3"
      fontSize: labelFontSize
      fontColor: colors.black
   }

   -- style of small dots
   scalar dotSize = 1.0
   color dotColor = colors.black

   -- standard triangle colors
   rgba triFill = #1b1f8a55
   rgba triStroke = #1b1f8a
   scalar triStrokeWidth = 0.5

   -- Ground plane coordinates in 3D
   scalar planeSize = 50 -- plane size
   scalar planeHeight = -35 -- plane height

   -- Use a simple pinhole camera model, where the
   -- only camera parameter is the distance along Z
   scalar cZ = -160 -- camera z coordinate
   scalar cameraθ = ? -- camera y rotation
   scalar viewXY = (0,canvas.width/6) -- viewport offset

   -- Corner coordinates of the global ground plane
   vec3 q00 = ( -planeSize, planeHeight, -planeSize )
   vec3 q10 = (  planeSize, planeHeight, -planeSize )
   vec3 q01 = ( -planeSize, planeHeight,  planeSize )
   vec3 q11 = (  planeSize, planeHeight,  planeSize )

   -- Apply a random rotation to the ground plane
   -- (Note that we could also apply this rotation to the triangle
   -- vertices, but since they're sampled randomly, it wouldn't
   -- really change the appearance of the kinds of diagrams we sample).
   scalar θ = cameraθ -- for brevity
   vec3 Q00 = ( q00[0]*cos(θ) + q00[2]*sin(θ), q00[1], q00[2]*cos(θ) - q00[0]*sin(θ) )
   vec3 Q10 = ( q10[0]*cos(θ) + q10[2]*sin(θ), q10[1], q10[2]*cos(θ) - q10[0]*sin(θ) )
   vec3 Q01 = ( q01[0]*cos(θ) + q01[2]*sin(θ), q01[1], q01[2]*cos(θ) - q01[0]*sin(θ) )
   vec3 Q11 = ( q11[0]*cos(θ) + q11[2]*sin(θ), q11[1], q11[2]*cos(θ) - q11[0]*sin(θ) )

   -- Perform perspective projection on 3D coordinates to get 2D coordinates p
   vec2 p00 = canvas.width * (Q00[0],Q00[1])/(Q00[2] - global.cZ) + global.viewXY
   vec2 p10 = canvas.width * (Q10[0],Q10[1])/(Q10[2] - global.cZ) + global.viewXY
   vec2 p01 = canvas.width * (Q01[0],Q01[1])/(Q01[2] - global.cZ) + global.viewXY
   vec2 p11 = canvas.width * (Q11[0],Q11[1])/(Q11[2] - global.cZ) + global.viewXY

   -- Draw polygon using projected 2D coordinates p
   shape groundPlane = Polygon {
      points: (p00,p10,p11,p01)
      width: canvas.width
      height: canvas.height
      fillColor: rgba(0,0,0,0.1)
      strokeColor: rgba(.7,.7,.7,1)
      strokeWidth: .5
      ensureOnCanvas: false
   }
}

forall Point v
{
   -- Sample 3D location from a bounding box of size c
   scalar c = .9*min( global.planeSize, abs(global.planeHeight) )
   vec3 v.q = (?,?,?)
   ensure -c < v.q[0]
   ensure v.q[0] < c
   ensure -c < v.q[1]
   ensure v.q[1] < c
   ensure -c < v.q[2]
   ensure v.q[2] < c

   -- perform modelview transformation
   vec3 Q = ( v.q[0], v.q[1], v.q[2] - global.cZ )

   -- Perform perspective projection to get 2D coordinates
   vec2 v.p = canvas.width * (Q[0],Q[1])/(Q[2]) + global.viewXY

   -- Compute projected shadow coordinates
   vec3 R = (Q[0],global.planeHeight,Q[2])
   vec2 v.s = canvas.width * (R[0],R[1])/(R[2]) + global.viewXY

   -- draw point as small dot
   shape v.icon = Circle {
      center: v.p
      r: global.dotSize
      fillColor: global.dotColor
   }

   -- draw shadow as semi-transparent dot
   shape v.shadow = Circle {
      center: v.s
      r: global.dotSize
      fillColor: colors.shadow
      ensureOnCanvas: false
   }
}

-- avoid overlapping point labels
forall Point i; Point j
where i has math label; j has math label
{
   ensure disjoint( i.labelText, j.labelText )
}

forall Triangle t; Point i; Point j; Point k
where t := MakeTriangle(i,j,k)
{
   -- make local aliases to point coordinates, for
   -- use by future rules that reference t but not
   -- its vertices
   t.p0 = i.p
   t.p1 = j.p
   t.p2 = k.p
   t.q0 = i.q
   t.q1 = j.q
   t.q2 = k.q

   -- Draw polygon using projected 2D coordinates p
   shape t.icon = Polygon {
      points: (i.p,j.p,k.p)
      fillColor: global.triFill
      strokeColor: global.triStroke
      strokeWidth: global.triStrokeWidth
   }

   -- Make sure the triangle is positively oriented in the
   -- image plane, and has some- "fat" angles so that it
   -- doesn't degenerate
   vec2 t.eij = j.p - i.p
   vec2 t.ejk = k.p - j.p
   vec2 t.eki = i.p - k.p
   scalar minArea = 200
   constraint t.orientation = ensure cross2D(   t.eij, -t.ejk ) < -minArea
   constraint t.angleSizeI = ensure angleFrom( -t.eij,  t.eki ) > toRadians( 45 )
   constraint t.angleSizeJ = ensure angleFrom( -t.ejk,  t.eij ) > toRadians( 45 )
   constraint t.angleSizeK = ensure angleFrom( -t.eki,  t.ejk ) > toRadians( 45 )

   -- Draw shadow polygon using projected 2D coordinates s
   shape t.shadow = Polygon {
      points: (i.s,j.s,k.s)
      fillColor: colors.shadow
      strokeColor: none()
      ensureOnCanvas: false
   }
}

forall Triangle t; Point i; Point j; Point k
where t := MakeTriangle(i,j,k); i has math label; j has math label; k has math label
{
   -- offset labels from vertices
   scalar offset = 6
   i.labelText.center = i.p - offset*unit( t.eij - t.eki )
   j.labelText.center = j.p - offset*unit( t.ejk - t.eij )
   k.labelText.center = k.p - offset*unit( t.eki - t.ejk )
}

forall Triangle t
where t has math label
{
   vec2 mij = (t.p0 + t.p1)/2
   vec2 nij = unit(rot90(t.eij))

   shape t.labelText = Equation {
      string: t.label
      center: mij - 6*nij
      fontSize: global.labelFontSize
      fontColor: colors.black
   }
}

-- For any pair of triangles, make sure that triangles
-- don't overlap, and moreover the vertices of one triangle are
-- far from being contained in the other triangle (which helps
-- to avoid overlapping labels).
forall Triangle s; Triangle t; Point si; Point sj; Point sk; Point ti; Point tj; Point tk
where s := MakeTriangle(si,sj,sk); t := MakeTriangle(ti,tj,tk)
{
   scalar padding = 10.0

   -- make sure triangles don't overlap
   ensure disjoint( s.icon, t.icon )

   -- make sure vertices of s are far from t
   ensure disjoint( si.icon, t.icon, padding )
   ensure disjoint( sj.icon, t.icon, padding )
   ensure disjoint( sk.icon, t.icon, padding )

   -- make sure vertices of t are far from s
   ensure disjoint( ti.icon, s.icon, padding )
   ensure disjoint( tj.icon, s.icon, padding )
   ensure disjoint( tk.icon, s.icon, padding )

}

forall Point p
where p has math label
{
   shape p.labelText = Equation {
      string: p.label
      fontSize: global.labelFontSize
      fillColor: colors.black
      ensureOnCanvas: false
   }

   vec2 u = (?,?)
   ensure norm(u) == 1
   p.labelText.center = p.p + 5.5*u
}

forall Point p; Triangle t
where p := Barycenter(t)
{
   override p.q = (t.q0 + t.q1 + t.q2)/3
   override p.icon.fillColor = colors.white
   override p.icon.strokeColor = colors.black
   override p.icon.strokeWidth = .35
}

forall Vector v
{
   vec3 v.a = (?,?,?) -- tail
   vec3 v.b = (?,?,?) -- head

   -- perform modelview transformation
   vec3 A = ( v.a[0], v.a[1], v.a[2] - global.cZ )
   vec3 B = ( v.b[0], v.b[1], v.b[2] - global.cZ )

   -- Perform perspective projection to get 2D coordinates
   vec2 v.p = canvas.width * (A[0],A[1])/(A[2]) + global.viewXY
   vec2 v.q = canvas.width * (B[0],B[1])/(B[2]) + global.viewXY

   -- Compute projected shadow coordinates
   vec3 R = (A[0],global.planeHeight,A[2])
   vec3 S = (B[0],global.planeHeight,B[2])
   vec2 v.r = canvas.width * (R[0],R[1])/(R[2]) + global.viewXY
   vec2 v.s = canvas.width * (S[0],S[1])/(S[2]) + global.viewXY

   -- draw vector as arrow
   shape v.icon = Line {
      start: v.p
      end: v.q
      strokeColor: colors.black
      strokeWidth: .75
      endArrowhead: "straight"
      endArrowheadSize: 0.5
      ensureOnCanvas: false
   }

   -- draw shadow as semi-transparent arrow
   shape v.shadow = Line {
      start: v.r
      end: v.s
      strokeColor: colors.shadow
      strokeWidth: .75
      endArrowhead: "straight"
      endArrowheadSize: 0.5
      ensureOnCanvas: false
   }
}

forall Vector v
where v has math label
{
   shape v.labelText = Equation {
      string: v.label
      fontSize: global.labelFontSize
      fillColor: colors.black
      ensureOnCanvas: false
   }

   vec2 u = unit(v.q - v.p)
   encourage norm(v.labelText.center - (v.q + 4.5*u)) == 0
}

forall Vector v; Triangle t
where v := TriangleNormal(t)
{
   scalar normalLength = 25
   vec3 c = (t.q0 + t.q1 + t.q2)/3
   vec3 n = unit(cross(t.q1 - t.q0, t.q2 - t.q0))
   vec3 e1 = unit(t.q1 - t.q0)
   override v.a = c
   override v.b = v.a + normalLength * n

   -- draw perpendicular marker
   scalar s = 3
   vec2 x0 = c
   vec2 x1 = c + s*n 
   vec2 x2 = c + s*(n+e1)
   vec2 x3 = c + s*e1
   vec2 X0 = canvas.width * (x0[0],x0[1])/(x0[2]-global.cZ) + global.viewXY
   vec2 X1 = canvas.width * (x1[0],x1[1])/(x1[2]-global.cZ) + global.viewXY
   vec2 X2 = canvas.width * (x2[0],x2[1])/(x2[2]-global.cZ) + global.viewXY
   vec2 X3 = canvas.width * (x3[0],x3[1])/(x3[2]-global.cZ) + global.viewXY
   shape perpMarker = Polygon {
      points: [ X0, X1, X2, X3 ]
      fillColor: colors.white
   }
   shape perpMarkerLine = Polyline {
      points: [ X0, X1, X2, X3 ]
      strokeColor: #1b1f8a
      strokeWidth: .35
   }

   layer perpMarker above t.icon
   layer perpMarkerLine above perpMarker

   -- make sure perpendicular marker is visible
   scalar minArea = 10
   ensure abs(cross2D(X0,X1) + cross2D(X1,X2) + cross2D(X2,X3) + cross2D(X3,X0)) > minArea
}

forall Segment s; Point a; Point b
where s := LineSegment(a,b)
{
   s.icon = Line {
      start: a.p
      end: b.p
      strokeColor: colors.black
      strokeWidth: .35
      strokeDasharray: "1.5 1.5"
      ensureOnCanvas: false
   }

   s.shadow = Line {
      start: a.s
      end: b.s
      strokeColor: colors.shadow
      strokeWidth: .35
      strokeDasharray: "1.5 1.5"
      ensureOnCanvas: false
   }
}

forall StandardTriangle t
{
   -- size s
   scalar s = canvas.width/4

   -- coordinate system origin o and axes e1,e2
   vec2 o = -.9*(canvas.width,canvas.height)/2 + (0,5)
   vec2 e1 = (s,0)
   vec2 e2 = (0,s)

   -- vertices p0, p1, p2
   vec2 t.p0 = o
   vec2 t.p1 = o + e1
   vec2 t.p2 = o + e2

   -- standard triangle
   shape t.icon = Polygon {
      fillColor: global.triFill
      strokeColor: global.triStroke
      strokeWidth: global.triStrokeWidth
      points: ( t.p0, t.p1, t.p2 )
   }

   -- standard axes
   shape xAxis = Line {
      start: o
      end: o + 1.15*e1
      strokeColor: colors.black
      strokeWidth: 0.65
      endArrowhead: "straight"
      endArrowheadSize: 0.65
   }
   shape yAxis = Line {
      start: o
      end: o + 1.15*e2
      strokeColor: colors.black
      strokeWidth: 0.65
      endArrowhead: "straight"
      endArrowheadSize: 0.65
   }
   shape xAxisLabel = Equation {
      center:  o + 1.225*e1
      string: "s"
      fontSize: global.labelFontSize
      fontColor: colors.black
      ensureOnCanvas: false
   }
   shape yAxisLabel = Equation {
      center:  o + 1.25*e2
      string: "t"
      fontSize: global.labelFontSize
      fontColor: colors.black
      ensureOnCanvas: false
   }

   -- unit ticks
   scalar tickSize = 2.5
   shape xAxisTick = Line {
      start: o + e1 - (0,tickSize)
      end:   o + e1 + (0,tickSize)
      strokeColor: t.icon.strokeColor
      strokeWidth: .75 * xAxis.strokeWidth
      ensureOnCanvas: false
   }
   shape yAxisTick = Line {
      start: o + e2 - (tickSize,0)
      end:   o + e2 + (tickSize,0)
      strokeColor: t.icon.strokeColor
      strokeWidth: .75 * yAxis.strokeWidth
      ensureOnCanvas: false
   }
   shape xTickLabel = Equation {
      center: xAxisTick.start - (0,5)
      string: "1"
      fontColor: colors.black
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
   shape yTickLabel = Equation {
      center: yAxisTick.start - (2.5,0)
      string: "1"
      fontColor: colors.black
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
}

forall Map f; StandardTriangle t0; Triangle t
where f := TriangleEmbedding(t0,t) {

   vec2 m01 = (t.p0 + t.p1)/2
   vec2 m12 = (t.p1 + t.p2)/2
   vec2 m20 = (t.p2 + t.p0)/2

   scalar w = 1/16
   scalar s = .5-w/2 + w*(match_id - 1)/(match_total - 1)

   vec2 a = (1-s)*t0.p1 + s*t0.p2
   vec2 b = closestTo( a, [m01,m12,m20] )

   vec2 u = unit((1,1))
   vec2 a1 = a + 5*u

   vec2 v = (b-t.p0) + (b-t.p1) + (b-t.p2)
   vec2 b1 = b + 5*unit(v)

   vec2 f.n = unit(rot90(b1-a1))
   vec2 f.c = (a1+b1)/2 + 5*f.n

   shape f.arrow = Path {
      d: interpolateQuadraticFromPoints( "open", a1, f.c, b1 )
      strokeColor: colors.black
      endArrowhead: "straight"
      endArrowheadSize: 0.5
      strokeWidth: 1
   }
}

-- arrows shouldn't overlap triangles
forall Map f; Map g; StandardTriangle t0; Triangle t
where f := TriangleEmbedding(t0,t) {
   ensure disjoint( g.arrow, t.icon )
}

-- draw labels for maps that have them
forall Map f; StandardTriangle t0; Triangle t
where f has math label {
   shape f.labelText = Equation {
      string: f.label
      center: f.c + 5*f.n
      fontSize: global.labelFontSize
      ensureOnCanvas: false
   }
}

-- avoid overlapping map labels
forall Map f; Map g
where f has math label; g has math label {
   ensure disjoint( f.labelText, g.labelText )
}

-- avoid overlapping map and point labels
forall Map f; Point v
where f has math label; v has math label {
   ensure disjoint( f.labelText, v.labelText )
}

