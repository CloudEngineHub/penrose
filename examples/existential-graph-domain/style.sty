variable {
    -- TODO: when making a color strip, might want to keep the colors the same. Find a way to pick just once. In other words, "anchor"/"freeze" sampled instances
    primary = sampleColor(1.0, "rgb")
    secondary = sampleColor(1.0, "rgb")
}

forall Graph A
{
    -- By default, a graph is an invisible circle and a text label, where the label is contained in the invisible circle.
    -- Cory: we should also allow invisible circle and label, which can be "turned on" depending on the role it plays in the Substance program?
    A.icon = Circle {
        strokeWidth: 0.0
        color: rgba(0.0, 0.0, 0.0, 0.0)
    }

    A.text = Text{
        string: A.label
        fontSize: "28pt"
    }

    -- Also, each graph has a counter for which "layer" it is in.
    A.level = 0

    ensure minSize(A.icon)
    ensure maxSize(A.icon)
    ensure contains(A.icon, A.text)
    ensure contains(A.icon, A.text)

    A.text above A.icon
}

forall Variable V
{
    V.icon = Path {
        fill: rgba(0.0, 0.0, 0.0, 0.0)
        color: rgba(0.0, 0.0, 0.0, 0.0)
        strokeWidth: 2.0
    }
}

forall Variable V; Graph A; Graph B where some(V, A, B)
{
    override V.icon.pathData = makePath(A.text.center, B.text.center, 50, 10)
    override V.icon.color = rgba(0.0, 0.0, 0.0, 1.0)

    V.start = A.text.center
    V.end = B.text.center

    V.icon above A.text
    V.icon above B.text
}

forall Variable v1; Variable v2 where equal(v1, v2) {
    -- make v1's icon the joined curve
    override v1.icon.pathData = makePath(v1.start, v2.start, 50, 10)
    -- hide v2's icon by setting the stroke width to zero
    override v2.icon.strokeWidth = 0.0
}

forall Graph A; Graph B; Graph Result 
where Result := or(A, B) 
{
    -- make the operands' icons (i.e. circles) visible
    override A.icon.color = variable.primary
    override B.icon.color = variable.primary

    -- increment the layering count of the result
    override Result.level = A.level + 1

    -- make another circle
    -- TODO: whenever changing this to `icon`, will get max stack call error (why?)
    Result.icon2 = Circle {
        strokeWidth: 0.0
        center: Result.icon.center
        -- NOTE: this shows double negation
        -- TODO: `- { n | n > 6.2 }` will cause NaNs. Maybe the padding in `contains`
        r: Result.icon.r - 6.2
        -- The alternative: set the radii to be the same to remove the double negation
        -- r: Result.icon.r
        -- NOTE: see `Functions.ts` for comments
        color: selectColor(variable.primary, variable.secondary, Result.level)
    }

    override Result.text = Circle{
        strokeWidth: 0.0
        r : 0.0
    }

    ensure smallerThan(A.icon, Result.icon2)
    ensure smallerThan(B.icon, Result.icon2)
    ensure contains(Result.icon2, A.icon, 5.0)
    ensure contains(Result.icon2, B.icon, 5.0)
    ensure disjoint(A.icon, B.icon)

    A.icon above Result.icon2
    B.icon above Result.icon2
    A.text above Result.icon2
    B.text above Result.icon2
}

forall Graph a where invisibleGraph(a){
    override a.text.color = rgba(1.0, 0.0, 0.0, 0.0)
}

forall Graph A; Graph B; Graph Result 
where Result := if(A, B) 
{
    override Result.level = A.level + 1

    override A.level = B.level + 1

    override Result.icon = Circle {
        strokeWidth: 0.0
        color: selectColor(variable.primary, variable.secondary, Result.level)
    }

    override Result.icon2 = Circle {
        strokeWidth: 0.0
        color: selectColor(variable.primary, variable.secondary, Result.level + 1)
    }

    -- Make the result label disappear
    -- TODO: alternative - make labels invisible by default and show them on canvas on demand
    override Result.text.string = ""

    override Result.icon2.r = Result.icon.r / 1.6

    ensure outsideOf(A.text, Result.icon2)
    ensure contains(Result.icon, A.text)
    ensure contains(Result.icon2, B.text)

    ensure maxSize(Result.icon)
    ensure minSize(Result.icon)
    ensure maxSize(Result.icon2)
    ensure minSize(Result.icon2)
    ensure contains(Result.icon, Result.icon2, 20.0)

    ensure contains(Result.icon2, B.icon, 20.0)


    Result.icon2 above Result.icon
    Result.icon2 below A.icon
    Result.icon2 below B.icon

}

forall Graph A; Graph B where and(A, B) {
    ensure disjoint(A.icon, B.icon)
}

forall Graph R where doubleElliminate(R) {
    override R.icon.color = rgba(0, 0, 0, 0)
    override R.icon2.color = rgba(0, 0, 0, 0)
}

forall Graph A; Graph B where deiterate(A); connect(A, B) {
    -- NOTE: this is one of the "ways of disappearing"
    -- TODO: although the text is hidden, the dimensions aren't, and shape placement will be affacted. Find a way to make shapes disappear.
    color1 = rgba(0, 0, 0, 1)
    color2 = rgba(0, 0, 0, 0)
    override A.text.color = deiterateSelect(A.level, B.level, color1, color2)
    override B.text.color = deiterateSelect(B.level, A.level, color1, color2)
}

forall Graph A where erase(A) {
    color1 = rgba(0, 0, 0, 1)
    color2 = rgba(0, 0, 0, 0)
    override A.text.color = eraseSelect(A.level, color1, color2)
}