variable {
    primary = sampleColor(1.0, "rgb")
    secondary = sampleColor(1.0, "rgb")
}

forall Graph A
{
    A.icon = Circle {
        strokeWidth: 0.0
        color: rgba(0.0, 0.0, 0.0, 0.0)
    }

    A.text = Text{
        string: A.label
        fontSize: "28pt"
    }

    A.level = 0

    ensure minSize(A.icon)
    ensure maxSize(A.icon)
    ensure contains(A.icon, A.text)
    ensure contains(A.icon, A.text)

    A.text above A.icon
}

forall Variable V
{
    V.icon = Path {
        fill: rgba(0.0, 0.0, 0.0, 0.0)
        color: rgba(0.0, 0.0, 0.0, 0.0)
        strokeWidth: 2.0
    }
}

forall Variable V; Graph A; Graph B where some(V, A, B)
{
    override V.icon.pathData = makePath(A.text.center, B.text.center, 50, 10)
    override V.icon.color = rgba(0.0, 0.0, 0.0, 1.0)

    V.start = A.text.center
    V.end = B.text.center

    V.icon above A.text
    V.icon above B.text
}

forall Variable v1; Variable v2 where equal(v1, v2) {
    -- make v1's icon the joined curve
    override v1.icon.pathData = makePath(v1.start, v2.start, 50, 10)
    -- hide v2's icon by setting the stroke width to zero
    override v2.icon.strokeWidth = 0.0
}

forall Graph A; Graph B; Graph Result 
where Result := or(A, B) 
{
    override A.icon.color = variable.primary
    override B.icon.color = variable.primary

    override Result.level = A.level + 1

    Result.icon2 = Circle {
        strokeWidth: 0.0
        center: Result.icon.center
        r: Result.icon.r - 1.0
        color: selectColor(variable.primary, variable.secondary, Result.level)
    }

    override Result.text = Circle{
        strokeWidth: 0.0
        r : 0.0
    }

    ensure smallerThan(A.icon, Result.icon)
    ensure smallerThan(B.icon, Result.icon)
    ensure contains(Result.icon2, A.icon, 5.0)
    ensure contains(Result.icon2, B.icon, 5.0)
    ensure disjoint(A.icon, B.icon)

    A.icon above Result.icon2
    B.icon above Result.icon2
    A.text above Result.icon2
    B.text above Result.icon2
}

forall Graph a where invisibleGraph(a){
    override a.text.color = rgba(1.0, 0.0, 0.0, 0.0)
}

forall Graph A; Graph B; Graph Result 
where Result := if(A, B) 
{
    override Result.level = A.level + 1

    override A.level = B.level + 1

    override Result.icon = Circle{
        strokeWidth: 0.0
        color: selectColor(variable.primary, variable.secondary, Result.level)
    }

    override Result.icon2 = Circle{
        strokeWidth: 0.0
        color: selectColor(variable.primary, variable.secondary, Result.level + 1)
    }

    override Result.text.string = ""

    override Result.icon2.r = Result.icon.r / 1.6

    ensure outsideOf(A.text, Result.icon2)
    ensure contains(Result.icon, A.text)
    ensure contains(Result.icon2, B.text)

    ensure maxSize(Result.icon)
    ensure minSize(Result.icon)
    ensure maxSize(Result.icon2)
    ensure minSize(Result.icon2)
    ensure contains(Result.icon, Result.icon2, 20.0)

    ensure contains(Result.icon2, B.icon, 20.0)


    Result.icon2 above Result.icon
    Result.icon2 below A.icon
    Result.icon2 below B.icon

}

forall Graph A; Graph B where and(A, B) {
    ensure disjoint(A.icon, B.icon)
}

forall Graph R where doubleElliminate(R) {
    override R.icon.color = rgba(0, 0, 0, 0)
    override R.icon2.color = rgba(0, 0, 0, 0)
}

forall Graph A; Graph B where deiterate(A); connect(A, B) {
    color1 = rgba(0, 0, 0, 1)
    color2 = rgba(0, 0, 0, 0)
    override A.text.color = deiterateSelect(A.level, B.level, color1, color2)
    override B.text.color = deiterateSelect(B.level, A.level, color1, color2)
}

forall Graph A where erase(A) {
    color1 = rgba(0, 0, 0, 1)
    color2 = rgba(0, 0, 0, 0)
    override A.text.color = eraseSelect(A.level, color1, color2)
}